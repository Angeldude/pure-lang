#! /bin/bash

# NOTE: To make this script self-contained, it includes embedded awk
# scripts. Do not remove the marker comments at the beginning and end of the
# awk scripts, otherwise we won't be able to find and extract them from the
# script source!

# Prerequisites:

# Make sure that you have Pandoc and GNU awk (as `gawk`) installed. The script
# probably needs a fairly recent Pandoc version (1.12.3 has been tested). To
# install the script, simply run `make install` (the installation prefix
# defaults to `/usr/local`; you can set this with the `prefix` make variable).

# To get proper syntax highlighting for Pure, at present you have to build
# your own versions of the pandoc and highlighting-kate Haskell modules.
# To do this, grab the latest sources from https://github.com/jgm/pandoc and
# https://github.com/jgm/highlighting-kate, drop the Kate syntax-highlighting
# for Pure from pure/etc/pure.xml into the highlighting-kate/xml folder, then
# rebuild highlighting-kate and pandoc. Detailed instructions can be found at
# http://bakerjd99.wordpress.com/2012/09/20/pandoc-based-j-syntax-highlighting/.

# Usage: rst-markdown [options ...] [files ...]

# The input files must all be in RST format. If none are specified, input is
# read from stdin. Output goes to stdout, unless an output filename is given
# with -o / --output. Use `rst-markdown -h` to get a brief summary of the
# available options.

# This script acts as a frontend to Pandoc which allows you to convert plain
# RST documents and (some) Sphinx elements to Markdown format (or any other
# output format supported by Pandoc). It was primarily written for converting
# the Pure documentation files, but might also work with other, similar
# RST-based documents. (The recognition of Sphinx description items assumes
# the Pure domain, though, so the awk scripts will surely need some work if
# you want to use them for anything else.)

# Some effort is made to keep the internal document links to RST section
# headers intact, as well as RST link targets and Sphinx markup for
# descriptions of program options, functions, variables, etc. For the rest of
# the conversion we rely on Pandoc. The script certainly isn't perfect, but it
# does a reasonably good job (much better than just pandoc on its own), and it
# gives you a quick way to obtain Markdown documents from the Pure manuals
# which can then be edited and formatted in various ways.

# The output format is usually auto-detected if an output filename is
# specified with -o / --output, otherwise you can specify the desired target
# format with the -t / --to option. The script understands a number of other
# options which are mostly passed to pandoc, and the -O / --options option
# lets you pass any other options not directly supported by the script. There
# are also a number of special pre-, post-processing and formatting options
# which affect the generated output:

# -d / --date and -V / --version allow you to substitute values for the most
# commonly used meta variables (|today| and @version@) in RST source files.
# By default, the current date is used, and the script also tries to detect
# the version number from the `version` variable in a Makefile in the current
# directory, if present.

# -C / --callouts uses a somewhat fancier formatting for RST note blocks
# (`.. note::`), which makes the Markdown rendering look a bit more like in
# the Sphinx-formatted docs.

# -c / --collapse-items collapses adjacent item headers in Sphinx markup for
# options, functions, variables, etc., if possible. This gives a denser format
# if there are multiple items for the same description text, but only works if
# the items are rendered as Markdown definition lists (which is the default,
# but can be disabled with the -H / --headers option, see below). This option
# takes an optional argument which, if specified, denotes the desired maximum
# number of items per header line.

# -D / --describe lets you adjust the format generic Sphinx descriptions
# (`.. describe::`). The optional argument takes the form of a regex
# replacement `/pattern/replacement/` which is applied to the description
# text; the result should be valid Markdown text. The default format is
# `/.*/`\0`/` which formats the entire description as literal (typewriter)
# text. Something like, e.g., `/(\w+(\s+\w+)*):\s+(.*)/\1: `\3`/` might be
# used to format a description of the form `Some text: foo bar` so that the
# text before the `:` is set in regular text font (you can use -D / --describe
# without argument to give this specific example a try). This option is not
# straightforward to use (it's much too easy to mess up the replacement and
# end up with invalid Markdown), but may be useful for scripted conversions if
# you're not content with the default formatting of these items.

# -H / --headers uses Markdown section headers rather than definition lists
# for Sphinx descriptions of options, functions, variables, etc., which
# potentially makes links to these items work in some output
# formats other than html. Please check the notes below for details.

# -i / --index creates an index file in order to make cross references between
# separate documents work (see the notes below for details). This option has a
# mandatory argument, the name of the index file to be created or updated.

# -n / --no-links strips all inline and reference links from the Markdown
# output, leaving just the link text in single quotes. This is useful when
# generating Pandoc output formats such as manpages (-tman) which don't
# support links and where the resulting output looks confusing if they are
# included.

# -R / --raw includes raw sections from the RST source (`.. raw::`). Pandoc
# seems to unconditionally include these sections, which usually messes up the
# output, so rst-markdown will by default strip them from the RST source
# during pre-processing, so that Pandoc never sees them. But if you really
# want to have this material included in the output then this option will give
# you that.

# -T / --title-block scrapes a Pandoc-style title block from the RST source.
# The title block should be formatted as follows (please also check the Pandoc
# documentation for a description of the title block syntax):

# .. % Title
# .. % Author
# .. % Date

# This will be treated as a comment by RST processors. If the -T option is
# used, then any additional frontmatter (i.e., everything leading up to the
# title block) will be stripped from the RST source, so that the output
# document begins with the Pandoc title block. (Note that this means that the
# resulting document will be empty if there's no title block in the source at
# all, so beware!)

# Notes:

# - At present, the script only recognizes a subset of the RST and Sphinx
#   cross-referencing syntax, so complex documents will most likely give funky
#   results or not work at all.

# - Internal section links are rendered as Markdown inline links by default.
#   If you prefer, you can force implicit reference links of the form [name][]
#   by specifying the -r / --reference-links option on the command line (this
#   option is simply passed to pandoc in the post-processing stage).

# - Other RST link targets (`.. _name:`) in the source document should also
#   work, and references to these will use implicit reference links in
#   Markdown. Note, however, that inline html will be used to create the
#   anchors for internal link targets, which may not work with Pandoc target
#   document types other than html.

# - Sphinx definitions for options, functions, variables, etc. are by default
#   rendered as Markdown definition lists. This works fairly well, but has the
#   downside that the corresponding link targets are coded using inline html,
#   which may not work with Pandoc target document types other than html. As a
#   remedy, you can also translate such descriptions to Markdown section
#   headers instead, by using the -H / --headers option. Definition lists
#   often look better in formatted documents, but using section headers has
#   the advantage that Pandoc supports special PHP Markdown-style syntax for
#   the section link targets. This syntax isn't widely supported by 3rd party
#   tools, but it works with a few of Pandoc's own writer backends, and so
#   might be useful in cases where you want the links to work and the target
#   document type doesn't support inline html anchors.

# - Cross-references to sections, RST link targets and definition items in
#   other documents will work (in html output at least), if you explicitly
#   create an index file for all the documents using the -i / --index option.
#   This generally requires that you run rst-markdown on all individual source
#   documents *twice* (the index entries will be created or updated during the
#   first round of invocations, then the correct link targets will be inserted
#   during the second round). For instance, if you have two documents a.rst
#   and b.rst which link to each other, then you can run rst-markdown twice as
#   follows:

#   rst-markdown a.rst -o a.md -i index && rst-markdown a.rst -o a.md -i index
#   rst-markdown a.rst -o a.md -i index && rst-markdown a.rst -o a.md -i index

#   The resulting Markdown documents a.md and b.md will have cross-document
#   links of the form a.html#... and b.html#... so that the links can be
#   correctly resolved in generated html output. This generally assumes that
#   the final output will be html documents located in the same directory, and
#   that the final documents have the same basenames as the corresponding
#   output files (if -o is given; otherwise, the script uses the basename of
#   the first RST input file for each document). If necessary (i.e., to use
#   other filename extensions and/or document paths), you can also specify a
#   printf-style template for the document part of the link targets with the
#   -N / --name option; the default naming corresponds to `-N "%s.html"`.

#   Please note that this somewhat complicated procedure is only necessary if
#   individual Markdown documents are created from each RST source. If you
#   pass the entire collection of source documents to rst-markdown in one go,
#   then only a single output file will be created, so all links between
#   documents become internal links in the output document.

prog=`basename "$0"`

usage() {
  echo "USAGE: $prog [options ...] [file ...]" >&2
  echo "Options marked [pandoc] are simply passed to pandoc." >&2
  echo "General options:" >&2
  echo "-h, --help:            print this message and exit" >&2
  echo "-O, --options:         pass any options to pandoc (cumulative)" >&2
  echo "-v, --verbose:         print debugging information to stderr" >&2
  echo "Preprocessing options:" >&2
  echo "-d, --date:            insert date for |today|" >&2
  echo "-i, --index:           create/update given index file" >&2
  echo "-N, --name:            printf template for document names" >&2
  echo "-R, --raw:             include raw markup in document" >&2
  echo "-T, --title-block:     include Pandoc-style title block" >&2
  echo "-V, --version:         insert version number for @version@" >&2
  echo "Formatting options:" >&2
  echo "-c, --collapse-items:  collapse adjacent description items" >&2
  echo "-C, --callouts:        fancier formatting of note blocks" >&2
  echo "-D, --describe:        formatting of describe blocks (regex)" >&2
  echo "-H, --headers:         use section headers for definitions" >&2
  echo "-n, --no-links:        suppress all links (show link text only)" >&2
  echo "Output options:" >&2
  echo "-o, --output:          [pandoc] name of pandoc output file" >&2
  echo "-r, --reference-links: [pandoc] use reference rather than inline links" >&2
  echo "-s, --standalone:      [pandoc] produce a standalone document" >&2
  echo "-S, --smart:           [pandoc] smart quotes, dashes etc." >&2
  echo "-t, --to:              [pandoc] pandoc output format" >&2
}

infiles=/dev/stdin
outfile=
date=`date "+%B %d, %Y"`
version="0.0"
template="%s.html"
index=
options=
headers=no
no_links=no
raw=no
title_block=no
callouts=no
describe=
max_items=0
verbose=no

# If we have a Makefile in the current directory, try to determine the version
# number from there.
if [ -r Makefile ]; then
  version=`sed -E -n -e 's/^version[[:space:]]*=[[:space:]]*([^[:space:]]+)[[:space:]]*$/\1/p' Makefile`
fi

# Parse options using getopt(1).
args=`getopt -o hvd:V:i:N:To:O:c::CD::HnrRsSt: -l help,verbose,date:,version:,index:,name:,title-block,output:,options:,collapse-items::,callouts,describe::,headers,no-links,reference-links,rawstandalone,smart,to: -n "$prog" -- "$@"`
if [ $? != 0 ] ; then exit 1 ; fi
eval set -- "$args"

while true; do
  case "$1" in
    -h|--help) usage; exit 1 ;;
    -v|--verbose) verbose=yes; shift ;;
    -d|--date) date="$2"; shift 2 ;;
    -V|--version) version="$2"; shift 2 ;;
    -i|--index) index="$2"; shift 2 ;;
    -N|--name) template="$2"; shift 2 ;;
    -T|--title-block) title_block=yes; shift ;;
    -o|--output) options="$options -o $2"; outfile="$2"; shift 2 ;;
    -O|--options) options="$options $2"; shift 2 ;;
    -c|--collapse-items) max_items=${2:-9999}; shift 2 ;;
    -C|--callouts) callouts=yes; shift ;;
    -D|--describe) describe=${2:-'/(\w+(\s+\w+)*):\s+(.*)/\1: `\3`/'}; shift 2 ;;
    -H|--headers) headers=yes; shift ;;
    -n|--no-links) no_links=yes; shift ;;
    -r|--reference-links) options="$options --reference-links"; shift ;;
    -R|--raw) raw=yes; shift ;;
    -s|--standalone) options="$options -s"; shift ;;
    -S|--smart) options="$options -S"; shift ;;
    -t|--to) options="$options -t $2"; shift 2 ;;
    --) shift; break ;;
  esac
done

infiles="$@"
if [ -n "$outfile" ]; then
    outfile=`echo "$outfile" | sed -e 's?.[^./]*$??'`
    outfile=`basename $outfile`
    outfile="-v filename=$outfile"
fi

describe=$(echo $describe | sed -e 's/\\/\\\\/g')

tmpdir=`mktemp -d /tmp/rst-markdown.XXXXXX`
auxfile=${index:-"$tmpdir/targets"}
tmpout="$tmpdir/outfile.md"

rm -Rf "$tmpdir"
mkdir -p "$tmpdir"

if [ "$verbose" == "yes" ]; then
    echo "rst-markdown      : pandoc $options"
fi

# Note that these two commands *must* be executed in sequence, to give
# rst-pre.awk the opportunity to finish writing the index file with the RST
# link targets before rst-post.awk is run.
gawk -f <(sed -e '/^# rst-pre[.]awk$/,/^# end rst-pre[.]awk$/!d' $0) $outfile -v verbose="$verbose" -v raw="$raw" -v version="$version" -v date="$date" -v template="$template" -v title_block="$title_block" -v callouts="$callouts" -v auxfile="$auxfile" "$@" > "$tmpout" && \
pandoc -f rst -t markdown --no-wrap "$tmpout" | gawk -f <(sed -e '/^# rst-post[.]awk$/,/^# end rst-post[.]awk$/!d' $0) -v verbose="$verbose" -v headers="$headers" -v max_items="$max_items" -v describe="$describe" -v no_links="$no_links" -v auxfile="$auxfile" - | pandoc -f markdown --columns 78 $options

rc=$?
rm -Rf "$tmpdir"

exit $rc
