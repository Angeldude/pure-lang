<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="modern.css" type="text/css" />
</head>
<body>
<p><a name="doc-pure-octave"></a></p>
<h1 id="pure-octave">pure-octave</h1>
<p><a name="module-octave"></a></p>
<p>Version 0.9, March 06, 2017</p>
<p>Albert Graef &lt;<a href="mailto:aggraef@gmail.com">aggraef@gmail.com</a>&gt;</p>
<p>A Pure interface to <a href="http://www.octave.org">GNU Octave</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>This is an Octave module for the Pure programming language, based on Paul Kienzle’s <a href="">octave_embed</a> which allows Octave to be embedded in other languages. It allows you to execute arbitrary Octave commands and Octave functions from Pure.</p>
<h2 id="copying">Copying</h2>
<p>pure-octave is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>pure-octave is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p>Please see the accompanying COPYING file for the precise license terms. The GPL can also be read online at <a href="http://www.gnu.org/licenses/" class="uri">http://www.gnu.org/licenses/</a>.</p>
<h2 id="installation">Installation</h2>
<p>Get the latest source from <a href="https://bitbucket.org/purelang/pure-lang/downloads/pure-octave-0.9.tar.gz" class="uri">https://bitbucket.org/purelang/pure-lang/downloads/pure-octave-0.9.tar.gz</a>.</p>
<p>Run <code>make</code> to compile the module and <code>make install</code> (as root) to install it in the Pure library directory. This requires GNU make, and of course you need to have both Pure and Octave installed (including Octave’s <code>mkoctfile</code> utility and the corresponding header files and libraries).</p>
<p><code>make</code> tries to guess your Pure installation directory and platform-specific setup. If it gets this wrong, you can set some variables manually. In particular, <code>make install prefix=/usr</code> sets the installation prefix. Please see the Makefile for details.</p>
<p>This release of pure-octave has been tested and is known to work with Octave 3.6.2, 3.8, 4.0 and (development version) 4.3. Older versions might require some fiddling with the sources to get the embedded Octave interface working.</p>
<p><strong>NOTE:</strong> At the time of this writing, the embedded interpreter is broken with Octave <strong>4.2</strong>, so you’ll either have to stick to Octave 4.0 for the time being, or use the 4.3 development version.</p>
<h2 id="basic-usage">Basic Usage</h2>
<p>Import this module into your Pure scripts as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> octave;</code></pre></div>
<p>This will add an embedded instance of the Octave interpreter to your program. (You can import this module as often as you want, but there’s always only one instance of Octave in each process.)</p>
<dl>
<dt><a name="octave_eval"></a><code>octave_eval s</code></dt>
<dd>Executes arbitrary Octave code.
</dd>
</dl>
<!-- -->
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_eval <span class="st">&quot;eig([1 2;3 4])&quot;</span>;
ans =

  -<span class="dv">0.37228</span>
   <span class="dv">5.37228</span>

<span class="dv">0</span></code></pre></div>
<p>This prints the result on stdout and returns a result code (zero if everything went fine). To suppress the printing of the result, simply terminate the Octave statement with a semicolon:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_eval <span class="st">&quot;eig([1 2;3 4]);&quot;</span>;
<span class="dv">0</span></code></pre></div>
<dl>
<dt><a name="octave_set"></a><code>octave_set var val</code>, <a name="octave_get"></a><code>octave_get var</code></dt>
<dd>Set and get global variables in the Octave interpreter.
</dd>
</dl>
<!-- -->
<p>This allows you to define values to be used when evaluating Octave code, and to transfer results back to Pure. However, before such globals can be accessed in Octave, you must explicitly declare them as globals:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_eval <span class="st">&quot;global x y ans&quot;</span>;
<span class="dv">0</span></code></pre></div>
<p>Now you can use <a href="#octave_set"><code>octave_set</code></a> and <a href="#octave_get"><code>octave_get</code></a> to transfer values between Pure and Octave as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_set <span class="st">&quot;x&quot;</span> {<span class="dv">1.0</span>,<span class="dv">2.0</span>;<span class="dv">3.0</span>,<span class="dv">4.0</span>};
{<span class="dv">1.0</span>,<span class="dv">2.0</span>;<span class="dv">3.0</span>,<span class="dv">4.0</span>}
&gt; octave_eval <span class="st">&quot;eig(x);&quot;</span>;
<span class="dv">0</span>
&gt; octave_get <span class="st">&quot;ans&quot;</span>;
{-<span class="dv">0.372281323269014</span>;<span class="dv">5.37228132326901</span>}</code></pre></div>
<p>Note that the most recent result can always be accessed through Octave’s <code>ans</code> variable. You can also use an explicit variable definition as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_eval <span class="st">&quot;y = eig(x);&quot;</span>;
<span class="dv">0</span>
&gt; octave_get <span class="st">&quot;y&quot;</span>;
{-<span class="dv">0.372281323269014</span>;<span class="dv">5.37228132326901</span>}</code></pre></div>
<h2 id="direct-function-calls">Direct Function Calls</h2>
<dl>
<dt><a name="octave_call"></a><code>octave_call fun n args</code></dt>
<dd>Call an octave function in a direct fashion. <code>fun</code> denotes the name of the function, <code>n</code> the number of function results and <code>args</code> the function arguments.
</dd>
</dl>
<!-- -->
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = {<span class="dv">1.0</span>,<span class="dv">2.0</span>;<span class="dv">3.0</span>,<span class="dv">4.0</span>};
&gt; octave_call <span class="st">&quot;eig&quot;</span> <span class="dv">1</span> x;
{-<span class="dv">0.372281323269014</span>;<span class="dv">5.37228132326901</span>}</code></pre></div>
<p>Note the second argument, which denotes the desired number of <em>return</em> values. This will usually be 1 (or 0 if you don’t care about the result), but some Octave functions may return a variable number of results, depending on how they’re called. Multiple values are returned as tuples in Pure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_call <span class="st">&quot;eig&quot;</span> <span class="dv">2</span> x;
{-<span class="dv">0.824564840132394</span>,-<span class="dv">0.415973557919284</span>;<span class="dv">0.565767464968992</span>,-<span class="dv">0.909376709132124</span>},
{-<span class="dv">0.372281323269014</span>,<span class="dv">0.0</span>;<span class="dv">0.0</span>,<span class="dv">5.37228132326901</span>}</code></pre></div>
<p>Multiple <em>arguments</em> are also specified as a tuple:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_call <span class="st">&quot;norm&quot;</span> <span class="dv">1</span> (x, <span class="dv">2</span>);
<span class="dv">5.46498570421904</span>
&gt; octave_call <span class="st">&quot;norm&quot;</span> <span class="dv">1</span> (x, <span class="dv">1</span>);
<span class="dv">6.0</span></code></pre></div>
<p>Instead of a function name, you can also specify the function to be called using a special kind of Octave object, a function value. These are returned, e.g., by Octave’s <code>str2func</code> and <code>inline</code> builtins. For your convenience, pure-octave provides a frontend to these builtins, the <a href="#octave_func"><code>octave_func</code></a> function, which lets you specify an Octave function in one of two ways:</p>
<dl>
<dt><a name="octave_func/name"></a><code>octave_func name</code></dt>
<dd>Returns the Octave function with the given name. This works like Octave’s <code>str2func</code> builtin.
</dd>
<dt><a name="octave_func/expr"></a><code>octave_func expr</code></dt>
<dd>Returns an “inline” function, where <code>expr</code> is an Octave expression (as a string) describing the function value. This works like Octave’s <code>inline</code> builtin. Instead of just an Octave expression, you can also specify a tuple consisting of the inline expression and the parameter names. (Otherwise the parameters are determined automatically, see the description of the <code>inline</code> function in the Octave manual for details.)
</dd>
</dl>
<!-- -->
<p>Note that inline functions allow you to call stuff that is not an Octave function and hence cannot be specified directly in <a href="#octave_call"><code>octave_call</code></a>, such as an operator. Examples:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> eig = octave_func <span class="st">&quot;eig&quot;</span>;
&gt; <span class="kw">let</span> mul = octave_func <span class="st">&quot;x*y&quot;</span>;
&gt; octave_call eig <span class="dv">1</span> (octave_call mul <span class="dv">1</span> (x,x));
{<span class="dv">0.138593383654928</span>;<span class="dv">28.8614066163451</span>}
&gt; <span class="kw">let</span> add = octave_func (<span class="st">&quot;x+y&quot;</span>,<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>);
&gt; octave_call add <span class="dv">1</span> (x,x);
{<span class="dv">2.0</span>,<span class="dv">4.0</span>;<span class="dv">6.0</span>,<span class="dv">8.0</span>}</code></pre></div>
<h2 id="data-conversions">Data Conversions</h2>
<p>As shown above, the <a href="#octave_set"><code>octave_set</code></a>, <a href="#octave_get"><code>octave_get</code></a> and <a href="#octave_call"><code>octave_call</code></a> functions convert Pure data to corresponding Octave values and vice versa. Octave scalars and matrices of boolean, integer, double, complex and character data are all directly supported by this interface, and are mapped to the corresponding Pure data types in a straightforward manner (scalars to scalars, matrices to matrices and strings to strings). Note that in any case these conversions create <em>copies</em> of the data, so modifying, say, an Octave matrix received via <a href="#octave_get"><code>octave_get</code></a> in Pure only affects the Pure copy of the matrix and leaves the original Octave matrix unchanged.</p>
<p>Octave’s higher-dimensional numeric arrays, cell arrays and structures are not natively supported by the interface, but are implemented using special conversion hooks defined in the octave.pure module (see the <code>__pure2oct__</code> and <code>__oct2pure__</code> functions in octave.pure). This simplifies the implementation and makes these conversions customizable if the need arises. It also makes it possible to extend the interface for further special data structures in the future. Please check the octave.pure module for details. It’s possible to disable these custom conversions with the <a href="#octave_converters"><code>octave_converters</code></a> function:</p>
<dl>
<dt><a name="octave_converters"></a><code>octave_converters flag</code></dt>
<dd>Enable or disable custom data conversions between Pure and Octave. The given flag must be a truth value (zero means disable, any nonzero value enable). The function returns the previous value of the flag.
</dd>
</dl>
<!-- -->
<p>Octave objects which are neither handled natively by the interface nor through the auxiliary converters (if enabled) are just passed through as is, in the form of a cooked pointer to an Octave value which frees itself when garbage-collected. This allows these objects to be passed around freely, but you can’t inspect or modify them in Pure. This applies, in particular, to Octave function objects, see <a href="#direct-function-calls">Direct Function Calls</a>. You can check for such objects with the <a href="#octave_valuep"><code>octave_valuep</code></a> predicate:</p>
<dl>
<dt><a name="octave_valuep"></a><code>octave_valuep x</code></dt>
<dd>Check for Octave value pointers.
</dd>
</dl>
<!-- -->
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> eig = octave_func <span class="st">&quot;eig&quot;</span>;
&gt; eig; octave_valuep eig;
#&lt;<span class="dt">pointer</span> <span class="dv">0x230dba0</span>&gt;
<span class="dv">1</span></code></pre></div>
<p>Such Octave value pointers can be used freely whereever an Octave value is needed (i.e., in invocations of <a href="#octave_set"><code>octave_set</code></a> and <a href="#octave_call"><code>octave_call</code></a>).</p>
<p>You should also note the following:</p>
<ul>
<li>Scalars and 1x1 matrices are indistinguishable in Octave, thus any 1x1 matrix will be returned as a scalar from Octave to Pure.</li>
<li><p>All types of boolean and integer matrices are returned from Octave to Pure as (machine) integer matrices. When converted back to Octave, these all become Octave <code>int32</code> matrices, but you can easily convert them to boolean or other types of matrices in Octave as needed. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_set <span class="st">&quot;a&quot;</span> {<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>};
{<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>}
&gt; octave_eval <span class="st">&quot;global a ans&quot;</span>;
<span class="dv">0</span>
&gt; octave_eval <span class="st">&quot;eig(a)&quot;</span>;
error: eig: wrong <span class="kw">type</span> argument `int32 matrix&#39;
<span class="dv">1</span>
&gt; octave_eval <span class="st">&quot;eig(double(a))&quot;</span>;
ans =

  -<span class="dv">0.37228</span>
   <span class="dv">5.37228</span>

<span class="dv">0</span>
&gt; octave_eval <span class="st">&quot;a&gt;2&quot;</span>;
ans =

   <span class="dv">0</span>   <span class="dv">0</span>
   <span class="dv">1</span>   <span class="dv">1</span>

<span class="dv">0</span>
&gt; octave_get <span class="st">&quot;ans&quot;</span>;
{<span class="dv">0</span>,<span class="dv">0</span>;<span class="dv">1</span>,<span class="dv">1</span>}</code></pre></div></li>
<li><p>Octave strings are mapped to Pure strings, and character matrices with more than one row are mapped to (symbolic) column vectors of Pure strings. Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_set <span class="st">&quot;a&quot;</span> <span class="st">&quot;Hello, world!&quot;</span>;
<span class="st">&quot;Hello, world!&quot;</span>
&gt; octave_eval <span class="st">&quot;a&quot;</span>;
a = Hello, world!
<span class="dv">0</span>
&gt; octave_eval <span class="st">&quot;[a;&#39;abc&#39;]&quot;</span>;
ans =

Hello, world!
abc          

<span class="dv">0</span>
&gt; octave_get <span class="st">&quot;ans&quot;</span>;
{<span class="st">&quot;Hello, world!&quot;</span>;<span class="st">&quot;abc          &quot;</span>}</code></pre></div></li>
<li><p>With the default converters, Octave numeric and cell arrays are represented as symbolic Pure matrices, structs as Pure records. This is still experimental and minor details of the Pure data representations are subject to change; please check octave.pure for more information. Here are some examples:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_call <span class="st">&quot;rand&quot;</span> <span class="dv">1</span> (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);
{{<span class="dv">0.775409654288678</span>,<span class="dv">0.946392719372485</span>,<span class="dv">0.351919625087157</span>},
{<span class="dv">0.388835562237807</span>,<span class="dv">0.589476406910984</span>,<span class="dv">0.839694088469728</span>}}
&gt; octave_call <span class="st">&quot;size&quot;</span> <span class="dv">1</span> ans;
{<span class="dv">1.0</span>,<span class="dv">2.0</span>,<span class="dv">3.0</span>}

&gt; octave_eval <span class="st">&quot;struct(&#39;name&#39;, &#39;Peter&#39;, &#39;age&#39;, 23);&quot;</span>; octave_get <span class="st">&quot;ans&quot;</span>;
<span class="dv">0</span>
{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;Peter&quot;</span>,<span class="st">&quot;age&quot;</span>=&gt;<span class="dv">23.0</span>}
&gt; octave_call (octave_func (<span class="st">&quot;x.age&quot;</span>,<span class="st">&quot;x&quot;</span>)) <span class="dv">1</span> ans;
<span class="dv">23.0</span></code></pre></div>
<p>Nested cell arrays and structs are set off with the special <code>cell</code> and <code>struct</code> constructors:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_eval <span class="st">&quot;x = {[1,2,3], {1,2,3}}; x{3}.name = &#39;Peter&#39;; x{3}.age = 23;&quot;</span>;
<span class="dv">0</span>
&gt; octave_get <span class="st">&quot;x&quot;</span>;
{{<span class="dv">1.0</span>,<span class="dv">2.0</span>,<span class="dv">3.0</span>},cell {<span class="dv">1.0</span>,<span class="dv">2.0</span>,<span class="dv">3.0</span>},struct {<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;Peter&quot;</span>,<span class="st">&quot;age&quot;</span>=&gt;<span class="dv">23.0</span>}}</code></pre></div>
<p>Struct arrays are also supported:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; octave_eval <span class="st">&quot;y = struct(&#39;name&#39;, {&#39;Peter&#39;,&#39;Hannah&#39;}, &#39;age&#39;, {23, 16});&quot;</span>;
<span class="dv">0</span>
&gt; octave_get <span class="st">&quot;y&quot;</span>;
{{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;Peter&quot;</span>,<span class="st">&quot;age&quot;</span>=&gt;<span class="dv">23.0</span>},{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;Hannah&quot;</span>,<span class="st">&quot;age&quot;</span>=&gt;<span class="dv">16.0</span>}}</code></pre></div>
<p>There’s also a little convenience function to factor a struct array into a more condensed form (this format can also be used to denote a struct array in Pure):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; struct_array ans;
{<span class="st">&quot;name&quot;</span>=&gt;{<span class="st">&quot;Peter&quot;</span>,<span class="st">&quot;Hannah&quot;</span>},<span class="st">&quot;age&quot;</span>=&gt;{<span class="dv">23.0</span>,<span class="dv">16.0</span>}}
&gt; octave_call <span class="st">&quot;disp&quot;</span> <span class="dv">0</span> ans;

  1x2 struct array containing the fields:

    name
    age
()</code></pre></div></li>
</ul>
<h2 id="calling-back-into-pure">Calling Back Into Pure</h2>
<p>The embedded Octave interpreter provides one special builtin, the <code>pure_call</code> function which can be used to call any function defined in the executing Pure script from Octave. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; even m::<span class="dt">matrix</span> = {~(<span class="dt">int</span> x mod <span class="dv">2</span>) | x=m};
&gt; octave_eval <span class="st">&quot;pure_call(&#39;even&#39;, 1:12)&quot;</span>;
ans =

  <span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">0</span>  <span class="dv">1</span>

<span class="dv">0</span></code></pre></div>
<p>Here’s the description of the <code>pure_call</code> function, as it is printed with Octave’s <code>help</code> command:</p>
<pre class="sourceCode none"><code>`pure_call&#39; is a built-in function

  RES = pure_call(NAME, ARG, ...)
  [RES, ...] = pure_call(NAME, ARG, ...)

  Execute the Pure function named NAME (a string) with the given arguments.
  The Pure function may return multiple results as a tuple. Example:
  pure_call(&#39;succ&#39;, 99) =&gt; 100.</code></pre>
<h2 id="gnuplot-interface">Gnuplot Interface</h2>
<p>Octave has a comprehensive plotting interface based on Gnuplot. To make the plotting capabilities available in a convenient form in Pure, the distribution includes an additional gnuplot.pure module which provides simple wrappers of the most important plotting functions. Please check gnuplot.pure for details. For instance, here are a few simple plotting commands:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> gnuplot;
<span class="kw">using</span> <span class="kw">namespace</span> gnuplot;

sombrero(); <span class="co">// sample &quot;sombrero&quot; plot (3d)</span>
popup();    <span class="co">// show the plot window</span>
peaks <span class="dv">25</span>;   <span class="co">// another sample 3d plot</span>
refresh();  <span class="co">// update the window</span>
popdn();    <span class="co">// hide the plot window</span>
print <span class="st">&quot;plot.eps&quot;</span>; <span class="co">// print the plot to an encapsulated PostScript file</span></code></pre></div>
<p>Note that most of the operations are in their own <code>gnuplot</code> namespace, so we used a <code>using namespace</code> declaration for convenience here. The following example does the “sombrero” plot again, but shows some of the explicit plotting commands and helper functions to generate the data:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> math;
<span class="kw">let</span> u = linspace (-<span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">41</span>);
<span class="kw">let</span> x,y = meshgrid2 u;
<span class="kw">let</span> z = {sin r/r | r = {sqrt (x^<span class="dv">2</span>+y^<span class="dv">2</span>)+eps() | x,y = zip x y}};
mesh (u, u, z);
popup();</code></pre></div>
<p>Note the commands that are needed to actually show the plot window and update its contents after doing each plot. Octave normally handles this automatically in its command loop, but since the embedded Octave interpreter doesn’t have an interactive command line, you’ll have to take care of this yourself when using this module.</p>
<p>Also note that there doesn’t seem to be a direct way to specify the default output terminal in the Octave gnuplot interface, so if you need to do this then you’ll have to set the <code>GNUTERM</code> environment variable as described in the gnuplot manual page.</p>
<h2 id="caveats-and-notes">Caveats and Notes</h2>
<p>Directly embedding Octave in Pure programs is convenient because it allows easy exchange of data between Pure and Octave, and you can also call Octave functions directly from Pure and vice versa. However, it also comes at a cost. A default build of Octave pulls in quite a few dependencies of its own which might conflict with other modules loaded in a Pure script. Specifically, we have found that older Octave versions may give problems with third-party graphics libraries such as <a href="http://www.vtk.org/">VTK</a>, if used in the same program as Octave. (These seem to be fixed in the latest Octave and VTK versions, however.)</p>
</body>
</html>
