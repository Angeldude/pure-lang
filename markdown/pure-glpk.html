<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="modern.css" type="text/css" />
</head>
<body>
<p><a name="doc-pure-glpk"></a></p>
<h1 id="pure-glpk---glpk-interface-for-the-pure-programming-language">Pure-GLPK - GLPK interface for the Pure programming language</h1>
<p>Version 0.5, March 06, 2017</p>
<p>Jiri Spitz &lt;<a href="mailto:jiri.spitz@bluetone.cz">jiri.spitz@bluetone.cz</a>&gt;</p>
<p>This module provides a feature complete GLPK interface for the Pure programming language, which lets you use all capabilities of the GNU Linear Programming Kit (GLPK) directly from Pure.</p>
<p>GLPK (see <a href="http://www.gnu.org/software/glpk" class="uri">http://www.gnu.org/software/glpk</a>) contains an efficient simplex LP solver, a simplex LP solver in exact arithmetics, an interior-point solver, a branch-and-cut solver for mixed integer programming and some specialized algorithms for net/grid problems. Using this interface you can build, modify and solve the problem, retrieve the solution, load and save the problem and solution data in standard formats and use any of advanced GLPK features.</p>
<p>The interface uses native Pure data types - lists and tuples - so that you need not perform any data conversions to/from GLPK internal data structures.</p>
<p>To make this module work, you must have a GLPK installation on your system, the version 4.42 or higher is required.</p>
<h2 id="installation">Installation</h2>
<p>Get the latest source from <a href="https://bitbucket.org/purelang/pure-lang/downloads/pure-glpk-0.5.tar.gz" class="uri">https://bitbucket.org/purelang/pure-lang/downloads/pure-glpk-0.5.tar.gz</a>.</p>
<p>Run <code>make</code> to compile the module and <code>make install</code> (as root) to install it in the Pure library directory. This requires GNU make, and of course you need to have Pure installed.</p>
<p>The default make options suppose that GLPK was configured with the following options: <code>--enable-dl --enable-odbc --enable-mysql --with-zlib --with-gmp</code></p>
<p>The zlib library is a part of the GLPK source distribution from the version 4.46 onwards, so the the configure options for newer GLPK versions are: <code>--enable-dl --enable-odbc --enable-mysql --with-gmp</code></p>
<p>Using the given options the depndencies are:</p>
<ul>
<li>GNU Multiprecision Library (GMP) - serves for the exact simplex solver. When disabled, the exact solver still works but it is much slower.</li>
<li>ODBC library - serves for reading data directly from database tables within the GNU MathProg language translator through the ODBC interface.</li>
<li>MySQL client library - serves for reading data directly from MySQL tables within the GNU MathProg language translator.</li>
<li>zlib compression library - enables reading and writing gzip compressed problem and solution files.</li>
<li>ltdl dlopen library - must be enabled together with any of ODBC or MySQL (or zlib for GLPK versions 4.45 and earlier).</li>
</ul>
<p><code>make</code> tries to guess your Pure installation directory and platform-specific setup. If it gets this wrong, you can set some variables manually. In particular, <code>make install prefix=/usr</code> sets the installation prefix, and <code>make PIC=-fPIC</code> or some similar flag might be needed for compilation on 64 bit systems. The variable <code>ODBCLIB</code> specifies the ODBC library to be linked with. The default value is <code>ODBCLIB=-lodbc</code>. Please see the Makefile for details.</p>
<h2 id="error-handling">Error Handling</h2>
<p>When an error condition occurs, the GLPK library itself prints an error mesage and terminates the application. This behaviour is not pleasant when working within an interpreter. Therefore, the Pure - GLPK bindings catches at least the most common errors like indices out of bounds. On such an error an appropriate message is returned to the interpreter. The less common errors are still trapped by the GLPK library.</p>
<p>When one of the most common errors occurs, an error term of the form <code>glp::error message</code> will be returned, which specifies what kind of error happend. For instance, an index out of boundsd will cause a report like the following:</p>
<p><code>glp::error &quot;[Pure GLPK error] row index out of bounds&quot;</code></p>
<p>You can check for such return values and take some appropriate action. By redefining <code>glp::error</code> accordingly, you can also have it generate exceptions or print an error message. For instance:</p>
<p><code>glp::error message = fprintf stderr &quot;%s\n&quot; message $$ ();</code></p>
<p><strong>NOTE:</strong> When redefining <code>glp::error</code> in this manner, you should be aware that the return value of <code>glp::error</code> is what will be returned by the other operations of this module in case of an error condition. These return values are checked by other functions. Thus the return value should still indicate that an error has happened, and not be something that might be interpreted as a legal return value, such as an integer or a nonempty tuple. It is usually safe to have <code>glp::error</code> return an empty tuple or throw an exception, but other types of return values should be avoided.</p>
<p><strong>IMPORTANT:</strong> It is really good to define a <code>glp::error</code> function, otherwise the errors might remain unnoticed.</p>
<h2 id="further-information-and-examples">Further Information and Examples</h2>
<p>For further details about the operations provided by this module please see the GLPK Reference Manual. Sample scripts illustrating the usage of the module can be found in the examples directory.</p>
<h2 id="interface-description">Interface description</h2>
<p>Most GLPK functions and symbols live in the namespace <code>glp</code>. There are a few functions and symbols in the namespace <code>lpx</code>. These functions and symbols are likely to be removed and replaced by new ones in the future.</p>
<p>In general, when you replace the <code>glp_</code> prefix from the GLPK Reference Manual with the namespace specification <code>glp::</code> then you receive the function name in this module. The same is valid for <code>lpx_</code> and <code>lpx::</code>. The symbolic constants are converted into lower case in this module, again obeying the same prefix rules.</p>
<h2 id="descriptions-of-interface-functions">Descriptions of interface functions</h2>
<h3 id="basic-api-routines">Basic API routines</h3>
<h4 id="problem-creating-and-modifying-routines">Problem creating and modifying routines</h4>
<h5 id="create-the-glpk-problem-object">Create the GLPK problem object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::create_prob</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<p>none</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>pointer to the LP problem object</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> lp = glp::create_prob;
&gt; lp;
#&lt;<span class="dt">pointer</span> <span class="dv">0x9de7168</span>&gt;</code></pre></div>
<h5 id="set-the-problem-name">Set the problem name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_prob_name lp name</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>name</dt>
<dd><p>problem name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_prob_name lp <span class="st">&quot;Testing problem&quot;</span>;
()</code></pre></div>
<h5 id="set-objective-name">Set objective name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_obj_name lp name</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>name</dt>
<dd><p>objective name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_obj_name lp <span class="st">&quot;Total costs&quot;</span>;
()</code></pre></div>
<h5 id="set-the-objective-direction">Set the objective direction</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_obj_dir lp direction</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>direction</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::min: minimize :glp::max: maximize</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_obj_dir lp glp::min;
()</code></pre></div>
<h5 id="add-new-rows-to-the-problem">Add new rows to the problem</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::add_rows lp count</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>count</dt>
<dd><p>number of rows to add</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>index of the first row added</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> first_added_row = glp_add_rows lp <span class="dv">3</span>;
&gt; first_added_row;
<span class="dv">6</span></code></pre></div>
<h5 id="add-new-columns-to-the-problem">Add new columns to the problem</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::add_cols lp count</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>count</dt>
<dd><p>number of columns to add</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>index of the first column added</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> first_added_col = glp_add_cols lp <span class="dv">3</span>;
&gt; first_added_col;
<span class="dv">5</span></code></pre></div>
<h5 id="set-the-row-name">Set the row name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_row_name lp (rowindex, rowname)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
<dt>rowname</dt>
<dd><p>row name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_row_name lp (<span class="dv">3</span>, <span class="st">&quot;The third row&quot;</span>);
()</code></pre></div>
<h5 id="set-the-column-name">Set the column name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_col_name lp (colindex, colname)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
<dt>colname</dt>
<dd><p>column name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_col_name lp (<span class="dv">3</span>, <span class="st">&quot;The third column&quot;</span>);
()</code></pre></div>
<h5 id="set-change-row-bounds">Set (change) row bounds</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
<dt>rowtype</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::fr: free variable (both bounds are ignored) :glp::lo: variable with lower bound (upper bound is ignored) :glp::up: variable with upper bound (lower bound is ignored) :glp::db: double bounded variable :glp::fx: fixed variable (lower bound applies, upper bound is ignored)</p>
</blockquote>
<dl>
<dt>lowerbound</dt>
<dd><p>lower row bound</p>
</dd>
<dt>upperbound</dt>
<dd><p>upper row bound</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p>: <code>()</code></p>
<dl>
<dt><strong>Example</strong>::</dt>
<dd><p><code>glp::set_row_bnds lp (3, glp::up, 0.0, 150.0);</code></p>
</dd>
</dl>
<h5 id="set-change-column-bounds">Set (change) column bounds</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
<dt>coltype</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::fr: free variable (both bounds are ignored) :glp::lo: variable with lower bound (upper bound is ignored) :glp::up: variable with upper bound (lower bound is ignored) :glp::db: double bounded variable :glp::fx: fixed variable (lower bound applies, upper bound is ignored)</p>
</blockquote>
<dl>
<dt>lowerbound</dt>
<dd><p>lower column bound</p>
</dd>
<dt>upperbound</dt>
<dd><p>upper column bound</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_col_bnds lp (<span class="dv">3</span>, glp::db, <span class="dv">100.0</span>, <span class="dv">150.0</span>);
()</code></pre></div>
<h5 id="set-change-objective-coefficient-or-constant-term">Set (change) objective coefficient or constant term</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_obj_coef lp (colindex, coefficient)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index, zero index denotes the constant term (objective shift)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_obj_coef lp (<span class="dv">3</span>, <span class="dv">15.8</span>);
()</code></pre></div>
<h5 id="load-or-replace-matrix-row">Load or replace matrix row</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_mat_row lp (rowindex, rowvector)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
<dt>rowvector</dt>
<dd><p>list of tuples (colindex, coefficient); only non-zero coefficients have to be specified, the order of column indices is not important, duplicates are <strong>not</strong> allowed</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_mat_row lp (<span class="dv">3</span>, [(<span class="dv">1</span>, <span class="dv">3.0</span>), (<span class="dv">4</span>, <span class="dv">5.2</span>)]);
()</code></pre></div>
<h5 id="load-or-replace-matrix-column">Load or replace matrix column</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_mat_col lp (colindex, colvector)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
<dt>colvector</dt>
<dd><p>list of tuples (rowindex, coefficient); only non-zero coefficients have to be specified, the order of row indices is not important, duplicates are <strong>not</strong> allowed</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_mat_col lp (<span class="dv">2</span>, [(<span class="dv">4</span>, <span class="dv">2.0</span>), (<span class="dv">2</span>, <span class="dv">1.5</span>)]);
()</code></pre></div>
<h5 id="load-or-replace-the-whole-problem-matrix">Load or replace the whole problem matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::load_matrix lp <span class="dt">matrix</span></code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>matrix</dt>
<dd><p>list of tuples (rowindex, colindex, coefficient); only non-zero coefficients have to be specified, the order of indices is not important, duplicates are <strong>not</strong> allowed</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::load_matrix lp [(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5.0</span>), (<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3.5</span>), (<span class="dv">3</span>, <span class="dv">1</span>, -<span class="dv">2.0</span>), (<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1.0</span>)];
()</code></pre></div>
<h5 id="check-for-duplicate-elements-in-sparse-matrix">Check for duplicate elements in sparse matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::check_dup numrows numcols indices</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>numrows</dt>
<dd><p>number of rows</p>
</dd>
<dt>numcols</dt>
<dd><p>number of columns</p>
</dd>
<dt>indices</dt>
<dd><p>list of tuples (rowindex, colindex); indices of only non-zero coefficients have to be specified, the order of indices is not important</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<dl>
<dt>0</dt>
<dd><p>the matrix has no duplicate elements</p>
</dd>
<dt>-k</dt>
<dd><p>rowindex or colindex of the k-th element in indices is out of range</p>
</dd>
<dt>+k</dt>
<dd><p>the k-th element in indices is duplicate</p>
</dd>
</dl>
<p><strong>Remark:</strong></p>
</blockquote>
</blockquote>
<blockquote>
<p>Notice, that <code>k</code> counts from 1, whereas list members are counted from 0.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::check_dup <span class="dv">3</span> <span class="dv">3</span>  [(<span class="dv">1</span>, <span class="dv">3</span>), (<span class="dv">2</span>, <span class="dv">2</span>), (<span class="dv">3</span>, <span class="dv">1</span>), (<span class="dv">2</span>, <span class="dv">2</span>)];
<span class="dv">4</span></code></pre></div>
<h5 id="sort-elements-of-the-constraint-matrix">Sort elements of the constraint matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::sort_matrix lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::sort_matrix lp;
()</code></pre></div>
<h5 id="delete-rows-from-the-matrix">Delete rows from the matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::del_rows lp rows</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rows</dt>
<dd><p>list of indices of rows to be deleted; the order of indices is not important, duplicates are <strong>not</strong> allowed</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Remark:</strong></p>
<blockquote>
<p>Deleting rows involves changing ordinal numbers of other rows remaining in the problem object. New ordinal numbers of the remaining rows are assigned under the assumption that the original order of rows is not changed.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::del_rows lp [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">7</span>];
()</code></pre></div>
<h5 id="delete-columns-from-the-matrix">Delete columns from the matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::del_cols lp cols</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>cols</dt>
<dd><p>list of indices of columns to be deleted; the order of indices is not important, duplicates are <strong>not</strong> allowed</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Remark:</strong></p>
<blockquote>
<p>Deleting columns involves changing ordinal numbers of other columns remaining in the problem object. New ordinal numbers of the remaining columns are assigned under the assumption that the original order of columns is not changed.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::del_cols lp [<span class="dv">6</span>, <span class="dv">4</span>, <span class="dv">5</span>];
()</code></pre></div>
<h5 id="copy-the-whole-content-of-the-glpk-problem-object-to-another-one">Copy the whole content of the GLPK problem object to another one</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::copy_prob destination source names</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>destination</dt>
<dd><p>pointer to the destination LP problem object (must already exist)</p>
</dd>
<dt>source</dt>
<dd><p>pointer to the source LP problem object</p>
</dd>
<dt>names</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::on: copy all symbolic names as well :glp::off: do not copy the symbolic names</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::copy_prob lp_dest lp_src glp::on;
()</code></pre></div>
<h5 id="erase-all-data-from-the-glpk-problem-object">Erase all data from the GLPK problem object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::erase_prob lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object, it remains still valid after the function call</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::erase_prob lp;
()</code></pre></div>
<h5 id="delete-the-glpk-problem-object">Delete the GLPK problem object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::delete_prob lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object, it is not valid any more after the function call</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::delete_prob lp;
()</code></pre></div>
<h4 id="problem-retrieving-routines">Problem retrieving routines</h4>
<h5 id="get-the-problem-name">Get the problem name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_prob_name lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>name of the problem</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_prob_name lp;
<span class="st">&quot;Testing problem&quot;</span></code></pre></div>
<h5 id="get-the-objective-name">Get the objective name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_obj_name lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>name of the objective</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_obj_name lp;
<span class="st">&quot;Total costs&quot;</span></code></pre></div>
<h5 id="get-the-objective-direction">Get the objective direction</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_obj_dir lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<p>:glp::min: minimize :glp::max: maximize</p>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_obj_dir lp;
glp::min</code></pre></div>
<h5 id="get-number-of-rows">Get number of rows</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_num_rows lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>number of rows (constraints)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_num_rows lp;
<span class="dv">58</span></code></pre></div>
<h5 id="get-number-of-columns">Get number of columns</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_num_cols lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>number of columns (structural variables)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_num_cols lp;
<span class="dv">65</span></code></pre></div>
<h5 id="get-name-of-a-row">Get name of a row</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_name lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>name of the given row</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_name lp <span class="dv">3</span>;
<span class="st">&quot;The third row&quot;</span></code></pre></div>
<h5 id="get-name-of-a-column">Get name of a column</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_name lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>name of the given column</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_name lp <span class="dv">2</span>;
<span class="st">&quot;The second column&quot;</span></code></pre></div>
<h5 id="get-row-type">Get row type</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_type lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<p>:glp::fr: free variable :glp::lo: variable with lower bound :glp::up: variable with upper bound :glp::db: double bounded variable :glp::fx: fixed variable</p>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_type lp <span class="dv">3</span>;
glp::db</code></pre></div>
<h5 id="get-row-lower-bound">Get row lower bound</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_lb lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the row lower bound; if the row has no lower bound then it returns the smallest double number</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_lb lp <span class="dv">3</span>;
<span class="dv">50.0</span></code></pre></div>
<h5 id="get-row-upper-bound">Get row upper bound</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_ub lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the row upper bound; if the row has no upper bound then it returns the biggest double number</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_ub lp <span class="dv">3</span>;
<span class="dv">150.0</span></code></pre></div>
<h5 id="get-column-type">Get column type</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_type lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>returns one of the following:</p>
<blockquote>
<p>:glp::fr: free variable :glp::lo: variable with lower bound :glp::up: variable with upper bound :glp::db: double bounded variable :glp::fx: fixed variable</p>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_type lp <span class="dv">2</span>;
glp::up</code></pre></div>
<h5 id="get-column-lower-bound">Get column lower bound</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_lb lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the column lower bound; if the column has no lower bound then it returns the smallest double number</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_lb lp <span class="dv">3</span>;
-<span class="dv">1.79769313486232e+308</span></code></pre></div>
<h5 id="get-column-upper-bound">Get column upper bound</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_ub lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the column upper bound; if the column has no upper bound then it returns the biggest double number</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_lb lp <span class="dv">3</span>;
<span class="dv">150.0</span></code></pre></div>
<h5 id="get-objective-coefficient">Get objective coefficient</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_obj_coef lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index; zero index denotes the constant term (objective shift)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the coefficient of given column in the objective</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_obj_coef lp <span class="dv">3</span>;
<span class="dv">5.8</span></code></pre></div>
<h5 id="get-number-of-nonzero-coefficients">Get number of nonzero coefficients</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_num_nz lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>number of non-zero coefficients in the problem matrix</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_num_nz lp;
<span class="dv">158</span></code></pre></div>
<h5 id="retrive-a-row-from-the-problem-matrix">Retrive a row from the problem matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_mat_row lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>non-zero coefficients of the given row in a list form of tuples (colindex, coefficient)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; get_mat_row lp <span class="dv">3</span>;
[(<span class="dv">3</span>,<span class="dv">6.0</span>),(<span class="dv">2</span>,<span class="dv">2.0</span>),(<span class="dv">1</span>,<span class="dv">2.0</span>)]</code></pre></div>
<h5 id="retrive-a-column-from-the-problem-matrix">Retrive a column from the problem matrix</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_mat_col lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>non-zero coefficients of the given column in a list form of tuples (rowindex, coefficient)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; get_mat_col lp <span class="dv">2</span>;
[(<span class="dv">3</span>,<span class="dv">2.0</span>),(<span class="dv">2</span>,<span class="dv">4.0</span>),(<span class="dv">1</span>,<span class="dv">1.0</span>)]</code></pre></div>
<h4 id="row-and-column-searching-routines">Row and column searching routines</h4>
<h5 id="create-index-for-searching-rows-and-columns-by-their-names">Create index for searching rows and columns by their names</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::create_index lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::create_index lp;
()</code></pre></div>
<h5 id="find-a-row-number-by-name">Find a row number by name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::find_row lp rowname</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowname</dt>
<dd><p>row name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>ordinal number (index) of the row</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>The search index is automatically created if it does not already exists.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::find_row lp <span class="st">&quot;The third row&quot;</span>;
<span class="dv">3</span></code></pre></div>
<h5 id="find-a-column-number-by-name">Find a column number by name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::find_col lp colname</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colname</dt>
<dd><p>column name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>ordinal number (index) of the column</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>The search index is automatically created if it does not already exists.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::find_col lp <span class="st">&quot;The second row&quot;</span>;
<span class="dv">2</span></code></pre></div>
<h5 id="delete-index-for-searching-rows-and-columns-by-their-names">Delete index for searching rows and columns by their names</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::delete_index lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::delete:index lp;
()</code></pre></div>
<h4 id="problem-scaling-routines">Problem scaling routines</h4>
<h5 id="set-the-row-scale-factor">Set the row scale factor</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_rii lp (rowindex, coefficient)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
<dt>coefficient</dt>
<dd><p>scaling coefficient</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_rii lp (<span class="dv">3</span>, <span class="dv">258.6</span>);
()</code></pre></div>
<h5 id="set-the-column-scale-factor">Set the column scale factor</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_sjj lp (colindex, coefficient)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
<dt>coefficient</dt>
<dd><p>scaling coefficient</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_sjj lp (<span class="dv">2</span>, <span class="dv">12.8</span>);
()</code></pre></div>
<h5 id="retrieve-the-row-scale-factor">Retrieve the row scale factor</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_rii lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>scaling coefficient of given row</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_rii lp <span class="dv">3</span>;
<span class="dv">258.6</span></code></pre></div>
<h5 id="retrieve-the-column-scale-factor">Retrieve the column scale factor</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_sjj lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>scaling coefficient of given column</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_sjj lp <span class="dv">2</span>;
<span class="dv">12.8</span></code></pre></div>
<h5 id="scale-the-problem-data-according-to-supplied-flags">Scale the problem data according to supplied flags</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::scale_prob lp flags</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>flags</dt>
<dd><p>symbolic integer constants which can be combined together by arithmetic <em>or</em>; the possible constants are:</p>
<p>:glp::sf_gm: perform geometric mean scaling :glp::sf_eq: perform equilibration scaling :glp::sf_2n: round scale factors to power of two :glp::sf_skip: skip if problem is well scaled :glp::sf_auto: choose scaling options automatically</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::scale_prob lp (glp::sf_gm || glp::sf_2n);
()</code></pre></div>
<h5 id="unscale-the-problem-data">Unscale the problem data</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::unscale_prob lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::unscale_prob lp;
()</code></pre></div>
<h4 id="lp-basis-constructing-routines">LP basis constructing routines</h4>
<h5 id="set-the-row-status">Set the row status</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_row_stat lp (rowindex, status)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
<dt>status</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::bs: make the row basic (make the constraint inactive) :glp::nl: make the row non-basic (make the constraint active) :glp::nu: make the row non-basic and set it to the upper bound; if the row is not double-bounded, this status is equivalent to glp::nl (only in the case of this routine) :glp::nf: the same as glp::nl (only in the case of this routine) :glp::ns: the same as glp::nl (only in the case of this routine)</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_row_stat lp (<span class="dv">3</span>, glp::nu);
()</code></pre></div>
<h5 id="set-the-column-status">Set the column status</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_col_stat lp (colindex, status)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
<dt>status</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::bs: make the column basic :glp::nl: make the column non-basic :glp::nu: make the column non-basic and set it to the upper bound; if the column is not double-bounded, this status is equivalent to glp::nl (only in the case of this routine) :glp::nf: the same as glp::nl (only in the case of this routine) :glp::ns: the same as glp::nl (only in the case of this routine)</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_col_stat lp (<span class="dv">2</span>, glp::bs);
()</code></pre></div>
<h5 id="construct-standard-problem-basis">Construct standard problem basis</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::std_basis lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::std_basis lp;
()</code></pre></div>
<h5 id="construct-advanced-problem-basis">Construct advanced problem basis</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::adv_basis lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::adv_basis lp;
()</code></pre></div>
<h5 id="construct-bixbys-problem-basis">Construct Bixby’s problem basis</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::cpx_basis lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::cpx_basis lp;
()</code></pre></div>
<h4 id="simplex-method-routines">Simplex method routines</h4>
<h5 id="solve-the-lp-problem-using-simplex-method">Solve the LP problem using simplex method</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::simplex lp options</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>options</dt>
<dd><p>list of solver options in the form of tuples (option_name, value):</p>
</dd>
</dl>
<blockquote>
<dl>
<dt>:glp::msg_lev: (default: glp::msg_all) - message level for</dt>
<dd><p>terminal output:</p>
</dd>
<dt>| <strong>glp::msg_off:</strong> no output</dt>
<dd><div style="white-space: pre-line;"><strong>glp::msg_err:</strong> error and warning messages only
<strong>glp::msg_on:</strong> normal output;
<strong>glp::msg_all:</strong> full output (including informational messages)</div>
</dd>
</dl>
<p>:glp::meth: (default: glp::primal) - simplex method option</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::primal:</strong> use two-phase primal simplex
<strong>glp::dual:</strong> use two-phase dual simplex;
<strong>glp::dualp:</strong> use two-phase dual simplex, and if it fails, switch to the primal simplex</div>
</blockquote>
<p>:glp::pricing: (default: glp::pt_pse) - pricing technique</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::pt_std:</strong> standard (textbook)
<strong>glp::pt_pse:</strong> projected steepest edge</div>
</blockquote>
<p>:glp::r_test: (default: glp::rt_har) - ratio test technique</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::rt_std:</strong> standard (textbook)
<strong>glp::rt_har:</strong> Harris’ two-pass ratio test</div>
</blockquote>
<dl>
<dt>:glp::tol_bnd: (default: 1e-7) - tolerance used to check if the</dt>
<dd><p>basic solution is primal feasible</p>
</dd>
<dt>:glp::tol_dj: (default: 1e-7) - tolerance used to check if the</dt>
<dd><p>basic solution is dual feasible</p>
</dd>
<dt>:glp::tol_piv: (default: 1e-10) - tolerance used to choose</dt>
<dd><p>eligble pivotal elements of the simplex table</p>
</dd>
<dt>:glp::obj_ll: (default: -DBL_MAX) - lower limit of the objective</dt>
<dd><p>function - if the objective function reaches this limit and continues decreasing, the solver terminates the search - used in the dual simplex only</p>
</dd>
<dt>:glp::obj_ul: (default: +DBL_MAX) - upper limit of the objective</dt>
<dd><p>function. If the objective function reaches this limit and continues increasing, the solver terminates the search - used in the dual simplex only</p>
</dd>
</dl>
<p>:glp::it_lim: (default: INT_MAX) - simplex iteration limit :glp::tm lim: (default: INT_MAX) - searching time limit, in milliseconds :glp::out_frq: (default: 200) - output frequency, in iterations - this parameter specifies how frequently the solver sends information about the solution process to the terminal :glp::out_dly: (default: 0) - output delay, in milliseconds - this parameter specifies how long the solver should delay sending information about the solution process to the terminal :glp::presolve: (default: glp::off) - LP presolver option:</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::on:</strong> enable using the LP presolver
<strong>glp::off:</strong> disable using the LP presolver</div>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<dl>
<dt>:glp::ok: the LP problem instance has been successfully solved; this code</dt>
<dd><p>does not necessarily mean that the solver has found optimal solution, it only means that the solution process was successful</p>
</dd>
<dt>:glp::ebadb: unable to start the search, because the initial basis</dt>
<dd><p>specified in the problem object is invalid - the number of basic (auxiliary and structural) variables is not the same as the number of rows in the problem object</p>
</dd>
<dt>:glp::esing: unable to start the search, because the basis matrix</dt>
<dd><p>corresponding to the initial basis is singular within the working precision</p>
</dd>
<dt>:glp::econd: unable to start the search, because the basis matrix</dt>
<dd><p>corresponding to the initial basis is ill-conditioned, i.e. its condition number is too large</p>
</dd>
<dt>:glp::ebound: unable to start the search, because some double-bounded</dt>
<dd><p>(auxiliary or structural) variables have incorrect bounds</p>
</dd>
<dt>:glp::efail: the search was prematurely terminated due to the solver</dt>
<dd><p>failure</p>
</dd>
<dt>:glp::eobjll: the search was prematurely terminated, because the objective</dt>
<dd><p>function being maximized has reached its lower limit and continues decreasing (the dual simplex only)</p>
</dd>
<dt>:glp::eobjul: the search was prematurely terminated, because the objective</dt>
<dd><p>function being minimized has reached its upper limit and continues increasing (the dual simplex only)</p>
</dd>
<dt>:glp::eitlim: the search was prematurely terminated, because the simplex</dt>
<dd><p>iteration limit has been exceeded</p>
</dd>
<dt>:glp::etmlim: the search was prematurely terminated, because the time</dt>
<dd><p>limit has been exceeded</p>
</dd>
<dt>:glp::enopfs: the LP problem instance has no primal feasible solution</dt>
<dd><p>(only if the LP presolver is used)</p>
</dd>
<dt>:glp::enodfs: the LP problem instance has no dual feasible solution</dt>
<dd><p>(only if the LP presolver is used)</p>
</dd>
</dl>
<p>When the list of options contains some bad option(s) then a list of bad options is returned instead.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>Options not mentioned in the option list are set to their default values.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::simplex lp [(glp::presolve, glp::on), (glp::msg_lev, glp::msg_all)];
glp_simplex: original LP has <span class="dv">3</span> rows, <span class="dv">3</span> columns, <span class="dv">9</span> non-zeros
glp_simplex: presolved LP has <span class="dv">3</span> rows, <span class="dv">3</span> columns, <span class="dv">9</span> non-zeros
Scaling...
 A: min|aij| = <span class="dv">1</span>,<span class="dv">000e+000</span>  max|aij| = <span class="dv">1</span>,<span class="dv">000e+001</span>  ratio = <span class="dv">1</span>,<span class="dv">000e+001</span>
Problem data seem to be well scaled
Crashing...
Size <span class="kw">of</span> triangular part = <span class="dv">3</span>
*     <span class="dv">0</span>: obj =  <span class="dv">0</span>,<span class="dv">000000000e+000</span>  infeas = <span class="dv">0</span>,<span class="dv">000e+000</span> (<span class="dv">0</span>)
*     <span class="dv">2</span>: obj =  <span class="dv">7</span>,<span class="dv">333333333e+002</span>  infeas = <span class="dv">0</span>,<span class="dv">000e+000</span> (<span class="dv">0</span>)
OPTIMAL SOLUTION FOUND
glp::ok</code></pre></div>
<h5 id="solve-the-lp-problem-using-simplex-method-in-exact-arithmetics">Solve the LP problem using simplex method in exact arithmetics</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::exact lp options</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>options</dt>
<dd><p>list of solver options in the form of tuples (option_name, value):</p>
</dd>
</dl>
<blockquote>
<p>:glp::it_lim: (default: INT_MAX) - simplex iteration limit :glp::tm lim: (default: INT_MAX) - searching time limit, in milliseconds</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<dl>
<dt>:glp::ok: the LP problem instance has been successfully solved; this code</dt>
<dd><p>does not necessarily mean that the solver has found optimal solution, it only means that the solution process was successful</p>
</dd>
<dt>:glp::ebadb: unable to start the search, because the initial basis</dt>
<dd><p>specified in the problem object is invalid - the number of basic (auxiliary and structural) variables is not the same as the number of rows in the problem object</p>
</dd>
<dt>:glp::esing: unable to start the search, because the basis matrix</dt>
<dd><p>corresponding to the initial basis is singular within the working precision</p>
</dd>
<dt>:glp::ebound: unable to start the search, because some double-bounded</dt>
<dd><p>(auxiliary or structural) variables have incorrect bounds</p>
</dd>
<dt>:glp::efail: the search was prematurely terminated due to the solver</dt>
<dd><p>failure</p>
</dd>
<dt>:glp::eitlim: the search was prematurely terminated, because the simplex</dt>
<dd><p>iteration limit has been exceeded</p>
</dd>
<dt>:glp::etmlim: the search was prematurely terminated, because the time</dt>
<dd><p>limit has been exceeded</p>
</dd>
</dl>
<p>When the list of options contains some bad option(s) then a list of bad options is returned instead.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>Options not mentioned in the option list are set to their default values.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::exact lp [];
glp_exact: <span class="dv">3</span> rows, <span class="dv">3</span> columns, <span class="dv">9</span> non-zeros
GNU MP bignum library is being used
*     <span class="dv">2</span>:   objval =                      <span class="dv">0</span>   (<span class="dv">0</span>)
*     <span class="dv">4</span>:   objval =       <span class="dv">733</span>,<span class="dv">333333333333</span>   (<span class="dv">0</span>)
OPTIMAL SOLUTION FOUND
glp::ok</code></pre></div>
<h5 id="retrieve-generic-status-of-basic-solution">Retrieve generic status of basic solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_status lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::undef: solution is undefined :glp::feas: solution is feasible :glp::infeas: solution is infeasible :glp::nofeas: no feasible solution exists :glp::opt: solution is optimal :glp::unbnd: solution is unbounded</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_status lp;
glp::opt</code></pre></div>
<h5 id="retrieve-generic-status-of-primal-solution">Retrieve generic status of primal solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_prim_stat lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::undef: primal solution is undefined :glp::feas: primal solution is feasible :glp::infeas: primal solution is infeasible :glp::nofeas: no primal feasible solution exists</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_prim_stat lp;
glp::feas</code></pre></div>
<h5 id="retrieve-generic-status-of-dual-solution">Retrieve generic status of dual solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_dual_stat lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::undef: dual solution is undefined :glp::feas: dual solution is feasible :glp::infeas: dual solution is infeasible :glp::nofeas: no dual feasible solution exists</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_dual_stat lp;
glp::feas</code></pre></div>
<h5 id="retrieve-value-of-the-objective-function">Retrieve value of the objective function</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_obj_val lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>value of the objective function</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_obj_val lp
<span class="dv">733.333333333333</span></code></pre></div>
<h5 id="retrieve-generic-status-of-a-row-variable">Retrieve generic status of a row variable</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_stat lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::bs: basic variable :glp::nl: non-basic variable on its lower bound :glp::nu: non-basic variable on its upper bound :glp::nf: non-basic free (unbounded) variable :glp::ns: non-basic fixed variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_stat lp <span class="dv">3</span>;
glp::bs</code></pre></div>
<h5 id="retrieve-row-primal-value">Retrieve row primal value</h5>
<dl>
<dt><strong>Synopsis</strong>::</dt>
<dd><p>glp::get_row_prim lp rowindex</p>
</dd>
</dl>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>primal value of the row (auxiliary) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_prim lp <span class="dv">3</span>;
<span class="dv">200.0</span></code></pre></div>
<h5 id="retrieve-row-dual-value">Retrieve row dual value</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_dual lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>dual value of the row (auxiliary) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_dual lp <span class="dv">3</span>;
<span class="dv">0.0</span></code></pre></div>
<h5 id="retrieve-generic-status-of-a-column-variable">Retrieve generic status of a column variable</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_stat lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::bs: basic variable :glp::nl: non-basic variable on its lower bound :glp::nu: non-basic variable on its upper bound :glp::nf: non-basic free (unbounded) variable :glp::ns: non-basic fixed variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_stat lp <span class="dv">2</span>;
glp::bs</code></pre></div>
<h5 id="retrieve-column-primal-value">Retrieve column primal value</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_prim lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>primal value of the column (structural) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_prim lp <span class="dv">2</span>;
<span class="dv">66.6666666666667</span></code></pre></div>
<h5 id="retrieve-column-dual-value">Retrieve column dual value</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_dual lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>dual value of the column (structural) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_dual lp <span class="dv">2</span>;
<span class="dv">0.0</span></code></pre></div>
<h5 id="determine-variable-causing-unboundedness">Determine variable causing unboundedness</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_unbnd_ray lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine glp_get_unbnd_ray returns the number k of a variable, which causes primal or dual unboundedness. If 1 &lt;= k &lt;= m, it is k-th auxiliary variable, and if m + 1 &lt;= k &lt;= m + n, it is (k - m)-th structural variable, where m is the number of rows, n is the number of columns in the problem object. If such variable is not defined, the routine returns 0.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>If it is not exactly known which version of the simplex solver detected unboundedness, i.e. whether the unboundedness is primal or dual, it is sufficient to check the status of the variable with the routine glp::get_row_stat or glp::get_col_stat. If the variable is non-basic, the unboundedness is primal, otherwise, if the variable is basic, the unboundedness is dual (the latter case means that the problem has no primal feasible dolution).</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_unbnd_ray lp;
<span class="dv">0</span></code></pre></div>
<h4 id="interior-point-method-routines">Interior-point method routines</h4>
<h5 id="solve-the-lp-problem-using-interior-point-method">Solve the LP problem using interior-point method</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::interior lp options</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>options</dt>
<dd><p>list of solver options in the form of tuples (option_name, value):</p>
</dd>
</dl>
<blockquote>
<dl>
<dt>:glp::msg_lev: (default: glp::msg_all) - message level for</dt>
<dd><p>terminal output:</p>
</dd>
<dt>| <strong>glp::msg_off:</strong> no output</dt>
<dd><div style="white-space: pre-line;"><strong>glp::msg_err:</strong> error and warning messages only
<strong>glp::msg_on:</strong> normal output;
<strong>glp::msg_all:</strong> full output (including informational messages)</div>
</dd>
</dl>
<p>:glp::ord_alg: (default: glp::ord_amd) - ordering algorithm option</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::ord_none:</strong> use natural (original) ordering
<strong>glp::ord_qmd:</strong> quotient minimum degree (QMD)
<strong>glp::ord_amd:</strong> approximate minimum degree (AMD)
<strong>glp::ord_sysamd:</strong> approximate minimum degree (SYSAMD)</div>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>one of the following:</p>
<dl>
<dt>:glp::ok: the LP problem instance has been successfully solved;</dt>
<dd><p>this code does not necessarily mean that the solver has found optimal solution, it only means that the solution process was successful</p>
</dd>
</dl>
<p>:glp::efail: the problem has no rows/columns :glp::enocvg: very slow convergence or divergence :glp::eitlim: iteration limit exceeded :glp::einstab: numerical instability on solving Newtonian system</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::interior lp [(glp::ord_alg, glp::ord_amd)];
Original LP has <span class="dv">3</span> row(s), <span class="dv">3</span> column(s), and <span class="dv">9</span> non-zero(s)
Working LP has <span class="dv">3</span> row(s), <span class="dv">6</span> column(s), and <span class="dv">12</span> non-zero(s)
Matrix A has <span class="dv">12</span> non-zeros
Matrix S = A*A&#39; has <span class="dv">6</span> non-zeros (upper triangle)
Approximate minimum degree ordering (AMD)...
Computing Cholesky factorization S = L*L&#39;...
Matrix L has <span class="dv">6</span> non-zeros
Guessing initial point...
Optimization begins...
  <span class="dv">0</span>: obj = -<span class="dv">8</span>,<span class="dv">218489503e+002</span>; rpi = <span class="dv">3</span>,<span class="dv">6e-001</span>; rdi = <span class="dv">6</span>,<span class="dv">8e-001</span>; gap = <span class="dv">2</span>,<span class="dv">5e-001</span>
  <span class="dv">1</span>: obj = -<span class="dv">6</span>,<span class="dv">719060895e+002</span>; rpi = <span class="dv">3</span>,<span class="dv">6e-002</span>; rdi = <span class="dv">1</span>,<span class="dv">9e-001</span>; gap = <span class="dv">1</span>,<span class="dv">4e-002</span>
  <span class="dv">2</span>: obj = -<span class="dv">6</span>,<span class="dv">917210389e+002</span>; rpi = <span class="dv">3</span>,<span class="dv">6e-003</span>; rdi = <span class="dv">9</span>,<span class="dv">3e-002</span>; gap = <span class="dv">3</span>,<span class="dv">0e-002</span>
  <span class="dv">3</span>: obj = -<span class="dv">7</span>,<span class="dv">267557732e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-003</span>; rdi = <span class="dv">9</span>,<span class="dv">3e-003</span>; gap = <span class="dv">4</span>,<span class="dv">4e-002</span>
  <span class="dv">4</span>: obj = -<span class="dv">7</span>,<span class="dv">323038146e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-004</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-003</span>; gap = <span class="dv">4</span>,<span class="dv">8e-003</span>
  <span class="dv">5</span>: obj = -<span class="dv">7</span>,<span class="dv">332295932e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-005</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-004</span>; gap = <span class="dv">4</span>,<span class="dv">8e-004</span>
  <span class="dv">6</span>: obj = -<span class="dv">7</span>,<span class="dv">333229585e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-006</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-005</span>; gap = <span class="dv">4</span>,<span class="dv">8e-005</span>
  <span class="dv">7</span>: obj = -<span class="dv">7</span>,<span class="dv">333322959e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-007</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-006</span>; gap = <span class="dv">4</span>,<span class="dv">8e-006</span>
  <span class="dv">8</span>: obj = -<span class="dv">7</span>,<span class="dv">333332296e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-008</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-007</span>; gap = <span class="dv">4</span>,<span class="dv">8e-007</span>
  <span class="dv">9</span>: obj = -<span class="dv">7</span>,<span class="dv">333333230e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-009</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-008</span>; gap = <span class="dv">4</span>,<span class="dv">8e-008</span>
 <span class="dv">10</span>: obj = -<span class="dv">7</span>,<span class="dv">333333323e+002</span>; rpi = <span class="dv">2</span>,<span class="dv">1e-010</span>; rdi = <span class="dv">1</span>,<span class="dv">1e-009</span>; gap = <span class="dv">4</span>,<span class="dv">8e-009</span>
OPTIMAL SOLUTION FOUND
glp::ok</code></pre></div>
<h5 id="retrieve-status-of-interior-point-solution">Retrieve status of interior-point solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ipt_status lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following</p>
<p>:glp::undef: interior-point solution is undefined :glp::opt: interior-point solution is optimal :glp::infeas: interior-point solution is infeasible :glp::nofeas: no feasible primal-dual solution exists</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ipt_status lp;
glp::opt</code></pre></div>
<h5 id="retrieve-the-objective-function-value-of-interior-point-solution">Retrieve the objective function value of interior-point solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ipt_obj_val lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>objective function value of interior-point solution</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ipt_obj_val lp;
<span class="dv">733.333332295849</span></code></pre></div>
<h5 id="retrieve-row-primal-value-of-interior-point-solution">Retrieve row primal value of interior-point solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ipt_row_prim lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>primal value of the row (auxiliary) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ipt_row_prim lp <span class="dv">3</span>;
<span class="dv">200.000000920688</span></code></pre></div>
<h5 id="retrieve-row-dual-value-of-interior-point-solution">Retrieve row dual value of interior-point solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ipt_row_dual lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>dual value of the row (auxiliary) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ipt_row_dual lp <span class="dv">3</span>;
<span class="dv">2.50607466186742e-008</span></code></pre></div>
<h5 id="retrieve-column-primal-value-of-interior-point-solution">Retrieve column primal value of interior-point solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ipt_col_prim lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>primal value of the column (structural) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ipt_col_prim lp <span class="dv">2</span>;
<span class="dv">66.666666406779</span></code></pre></div>
<h5 id="retrieve-column-dual-value-of-interior-point-solution">Retrieve column dual value of interior-point solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ipt_col_dual lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>dual value of the column (structural) variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ipt_col_dual lp <span class="dv">2</span>;
<span class="dv">2.00019467655466e-009</span></code></pre></div>
<h4 id="mixed-integer-programming-routines">Mixed integer programming routines</h4>
<h5 id="set-column-kind">Set column kind</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_col_kind lp (colindex, colkind)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
<dt>colkind</dt>
<dd><p>column kind - one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::cv: continuous variable :glp::iv: integer variable :glp::bv: binary variable</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_col_kind lp (<span class="dv">1</span>, glp::iv);
()</code></pre></div>
<h5 id="retrieve-column-kind">Retrieve column kind</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_kind lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::cv: continuous variable :glp::iv: integer variable :glp::bv: binary variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_kind lp <span class="dv">1</span>;
glp::iv</code></pre></div>
<h5 id="retrieve-number-of-integer-columns">Retrieve number of integer columns</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_num_int lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>number of integer columns (including binary columns)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp_get_num_int lp;
<span class="dv">1</span></code></pre></div>
<h5 id="retrieve-number-of-binary-columns">Retrieve number of binary columns</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_num_bin lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>number of binary columns</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_num_bin lp
<span class="dv">0</span></code></pre></div>
<h5 id="solve-the-mip-problem-using-branch-and-cut-method">Solve the MIP problem using branch-and-cut method</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::intopt lp options</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>options</dt>
<dd><p>list of solver options in the form of tuples (option_name, value):</p>
</dd>
</dl>
<blockquote>
<dl>
<dt>:glp::msg_lev: (default: glp::msg_all) - message level for</dt>
<dd><p>terminal output:</p>
</dd>
<dt>| <strong>glp::msg_off:</strong> no output</dt>
<dd><div style="white-space: pre-line;"><strong>glp::msg_err:</strong> error and warning messages only
<strong>glp::msg_on:</strong> normal output;
<strong>glp::msg_all:</strong> full output (including informational messages)</div>
</dd>
</dl>
<p>:glp::br_tech: (default: glp::bt::blb) - branching technique</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::br_ffv:</strong> first fractional variable
<strong>glp::br_lfv:</strong> last fractional variable
<strong>glp::br_mfv:</strong> most fractional variable
<strong>glp::br_dth:</strong> heuristic by Driebeck and Tomlin
<strong>glp::br_pch:</strong> hybrid pseudocost heuristic</div>
</blockquote>
<p>:glp::bt_tech: (default: glp::pt_pse) - backtracking technique</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::bt_dfs:</strong> depth first search;
<strong>glp::bt_bfs:</strong> breadth first search;
<strong>glp::bt_blb:</strong> best local bound;
<strong>glp::bt_bph:</strong> best projection heuristic.</div>
</blockquote>
<p>:glp::pp_tech: (default: glp::pp_all) - preprocessing technique</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::pp_none:</strong> disable preprocessing;
<strong>glp::pp_root:</strong> perform preprocessing only on the root level
<strong>glp::pp_all:</strong> perform preprocessing on all levels</div>
</blockquote>
<p>:glp::fp_heur: (default: glp::off) - feasibility pump heuristic:</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::on:</strong> enable applying the feasibility pump heuristic
<strong>glp::off:</strong> disable applying the feasibility pump heuristic</div>
</blockquote>
<dl>
<dt>:glp::gmi_cuts: (default: glp::off) - Gomory’s mixed integer</dt>
<dd><p>cuts:</p>
</dd>
<dt>| *<em>glp::on:</em>* enable generating Gomory’s cuts;</dt>
<dd><div style="white-space: pre-line;"><strong>glp::off:</strong> disable generating Gomory’s cuts.</div>
</dd>
<dt>:glp::mir_cuts: (default: glp::off) - mixed integer rounding</dt>
<dd><p>(MIR) cuts:</p>
</dd>
<dt>| <strong>glp::on:</strong> enable generating MIR cuts;</dt>
<dd><div style="white-space: pre-line;"><strong>glp::off:</strong> disable generating MIR cuts.</div>
</dd>
</dl>
<p>:glp::cov_cuts: (default: glp::off) - mixed cover cuts:</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::on:</strong> enable generating mixed cover cuts;
<strong>glp::off:</strong> disable generating mixed cover cuts.</div>
</blockquote>
<p>:glp::clq_cuts (default: glp::off) - clique cuts:</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::on:</strong> enable generating clique cuts;
<strong>glp::off:</strong> disable generating clique cuts.</div>
</blockquote>
<dl>
<dt>:glp::tol_int: (default: 1e-5) - absolute tolerance used to</dt>
<dd><p>check if optimal solution to the current LP relaxation is integer feasible</p>
</dd>
<dt>:glp::tol_obj: (default: 1e-7) - relative tolerance used to</dt>
<dd><p>check if the objective value in optimal solution to the current LP relaxation is not better than in the best known integer feasible solution</p>
</dd>
<dt>:glp::mip_gap: (default: 0.0) - the relative mip gap tolerance;</dt>
<dd><p>if the relative mip gap for currently known best integer feasible solution falls below this tolerance, the solver terminates the search -this allows obtainig suboptimal integer feasible solutions if solving the problem to optimality takes too long time</p>
</dd>
<dt>:glp::tm lim: (default: INT_MAX) - searching time limit, in</dt>
<dd><p>milliseconds</p>
</dd>
<dt>:glp::out_frq: (default: 5000) - output frequency, in</dt>
<dd><p>miliseconds - this parameter specifies how frequently the solver sends information about the solution process to the terminal</p>
</dd>
<dt>:glp::out_dly: (default: 10000) - output delay, in milliseconds</dt>
<dd><ul>
<li>this parameter specifies how long the solver should delay sending information about the solution of the current LP relaxation with the simplex method to the terminal</li>
</ul>
</dd>
<dt>:glp::cb_func: (default: glp::off) - specifies whether to use</dt>
<dd><p>the user-defined callback routine</p>
</dd>
<dt>| <strong>glp::on:</strong> use user-defined callback function - the function</dt>
<dd><p><code>glp::mip_cb tree info</code> <strong>must</strong> be defined by the user</p>
</dd>
</dl>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::off:</strong> do not use user-defined callback function</div>
</blockquote>
<dl>
<dt>:glp::cb_info: (default: NULL) - transit pointer passed to the</dt>
<dd><p>routine <code>glp::mip_cb tree info</code> (see above)</p>
</dd>
<dt>:glp::cb_size: (default: 0) - the number of extra (up to 256)</dt>
<dd><p>bytes allocated for each node of the branch-and-bound tree to store application-specific data - on creating a node these bytes are initialized by binary zeros</p>
</dd>
</dl>
<p>:glp::presolve: (default: glp::off) - LP presolver option:</p>
<blockquote>
<div style="white-space: pre-line;"><strong>glp::on:</strong> enable using the MIP presolver
<strong>glp::off:</strong> disable using the MIP presolver</div>
</blockquote>
<dl>
<dt>:glp::binarize: (default: glp::off) - binarization (used only if</dt>
<dd><p>the presolver is enabled):</p>
</dd>
<dt>| <strong>glp::on:</strong> replace general integer variables by binary ones</dt>
<dd><div style="white-space: pre-line;"><strong>glp::off:</strong> do not use binarization</div>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
</blockquote>
<blockquote>
<p>one of the following:</p>
<dl>
<dt>:glp::ok: the MIP problem instance has been successfully solved; this code</dt>
<dd><p>does not necessarily mean that the solver has found optimal solution, it only means that the solution process was successful</p>
</dd>
<dt>:glp::ebound: unable to start the search, because some double-bounded</dt>
<dd><p>(auxiliary or structural) variables have incorrect bounds or some integer variables have non-integer (fractional) bounds</p>
</dd>
<dt>:glp::eroot: unable to start the search, because optimal basis for initial</dt>
<dd><p>LP relaxation is not provided - this code may appear only if the presolver is disabled</p>
</dd>
<dt>:glp::enopfs: unable to start the search, because LP relaxation of the</dt>
<dd><p>MIP problem instance has no primal feasible solution -this code may appear only if the presolver is enabled</p>
</dd>
<dt>:glp::enodfs: unable to start the search, because LP relaxation of the</dt>
<dd><p>MIP problem instance has no dual feasible solution; in other word, this code means that if the LP relaxation has at least one primal feasible solution, its optimal solution is unbounded, so if the MIP problem has at least one integer feasible solution, its (integer) optimal solution is also unbounded - this code may appear only if the presolver is enabled</p>
</dd>
<dt>:glp::efail: the search was prematurely terminated due to the solver</dt>
<dd><p>failure</p>
</dd>
<dt>:glp::emipgap: the search was prematurely terminated, because the</dt>
<dd><p>relative mip gap tolerance has been reached</p>
</dd>
<dt>:glp::etmlim: the search was prematurely terminated, because the time</dt>
<dd><p>limit has been exceeded</p>
</dd>
<dt>:glp::estop: the search was prematurely terminated by application - this code may appear only if the advanced solver</dt>
<dd><p>interface is used</p>
</dd>
</dl>
<p>When the list of options contains some bad option(s) then a list of bad options is returned instead.</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>Options not mentioned in the option list are set to their default values.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::intopt lp [(glp::presolve, glp::on)];
ipp_basic_tech:  <span class="dv">0</span> row(s) and <span class="dv">0</span> column(s) removed
ipp_reduce_bnds: <span class="dv">2</span> pass(es) made, <span class="dv">3</span> bound(s) reduced
ipp_basic_tech:  <span class="dv">0</span> row(s) and <span class="dv">0</span> column(s) removed
ipp_reduce_coef: <span class="dv">1</span> pass(es) made, <span class="dv">0</span> coefficient(s) reduced
glp_intopt: presolved MIP has <span class="dv">3</span> rows, <span class="dv">3</span> columns, <span class="dv">9</span> non-zeros
glp_intopt: <span class="dv">3</span> integer columns, none <span class="kw">of</span> which are binary
Scaling...
 A: min|aij| =  <span class="dv">1</span>,<span class="dv">000e+00</span>  max|aij| =  <span class="dv">1</span>,<span class="dv">000e+01</span>  ratio =  <span class="dv">1</span>,<span class="dv">000e+01</span>
Problem data seem to be well scaled
Crashing...
Size <span class="kw">of</span> triangular part = <span class="dv">3</span>
Solving LP relaxation...
*     <span class="dv">2</span>: obj =   <span class="dv">0</span>,<span class="dv">000000000e+00</span>  infeas =  <span class="dv">0</span>,<span class="dv">000e+00</span> (<span class="dv">0</span>)
*     <span class="dv">5</span>: obj =   <span class="dv">7</span>,<span class="dv">333333333e+02</span>  infeas =  <span class="dv">0</span>,<span class="dv">000e+00</span> (<span class="dv">0</span>)
OPTIMAL SOLUTION FOUND
Integer optimization begins...
+     <span class="dv">5</span>: mip =     not found yet &lt;=              +inf        (<span class="dv">1</span>; <span class="dv">0</span>)
+     <span class="dv">6</span>: &gt;&gt;&gt;&gt;&gt;   <span class="dv">7</span>,<span class="dv">320000000e+02</span> &lt;=   <span class="dv">7</span>,<span class="dv">320000000e+02</span>   <span class="dv">0.0</span>% (<span class="dv">2</span>; <span class="dv">0</span>)
+     <span class="dv">6</span>: mip =   <span class="dv">7</span>,<span class="dv">320000000e+02</span> &lt;=     tree is empty   <span class="dv">0.0</span>% (<span class="dv">0</span>; <span class="dv">3</span>)
INTEGER OPTIMAL SOLUTION FOUND
glp::ok</code></pre></div>
<h5 id="retrieve-status-of-mip-solution">Retrieve status of mip solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mip_status lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::undef: MIP solution is undefined :glp::opt: MIP solution is integer optimal :glp::feas: MIP solution is integer feasible, however, its optimality (or non-optimality) has not been proven, perhaps due to premature termination of the search :glp::nofeas: problem has no integer feasible solution (proven by the solver)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mip_status lp;
glp::opt</code></pre></div>
<h5 id="retrieve-the-objective-function-value-of-mip-solution">Retrieve the objective function value of mip solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mip_obj_val lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>objective function value of mip solution</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mip_obj_val lp;
<span class="dv">732.0</span></code></pre></div>
<h5 id="retrieve-row-value-of-mip-solution">Retrieve row value of mip solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mip_row_val lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>row value (value of auxiliary variable)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mip_row_val lp <span class="dv">3</span>;
<span class="dv">200.0</span></code></pre></div>
<h5 id="retrieve-column-value-of-mip-solution">Retrieve column value of mip solution</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mip_col_val lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>column value (value of structural variable)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mip_col_val lp <span class="dv">2</span>;
<span class="dv">67.0</span></code></pre></div>
<h4 id="additional-routines">Additional routines</h4>
<h5 id="check-karush-kuhn-tucker-conditions">Check Karush-Kuhn-Tucker conditions</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::check_kkt lp solution condition</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>solution</dt>
<dd><p>one of the following</p>
</dd>
</dl>
<blockquote>
<p>:glp::sol: check basic solution :glp::ipt: check interior-point solution :glp::mip: check mixed integer solution</p>
</blockquote>
<dl>
<dt>condition</dt>
<dd><p>one of the following</p>
</dd>
</dl>
<blockquote>
<p>:glp::kkt_pe: check primal equality constraints :glp::kkt_pb: check primal bound constraints :glp::kkt_de: check dual equality constraints (not available for MIP) :glp::kkt_db: check dual bound constraints (not available for MIP)</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>tuple with four members (ae_max, ae_ind, re_max, re_ind) where the variables indicate:</p>
<dl>
<dt>ae_max</dt>
<dd><p>largest absolute error</p>
</dd>
<dt>ae_ind</dt>
<dd><p>number of row (kkt_pe), column (kkt_de), or variable (kkt_pb, kkt_db) with the largest absolute error</p>
</dd>
<dt>re_max</dt>
<dd><p>largest relative error</p>
</dd>
<dt>re_ind</dt>
<dd><p>number of row (kkt_pe), column (kkt_de), or variable (kkt_pb, kkt_db) with the largest relative error</p>
</dd>
</dl>
<p>where the variable index is (1 &lt;= k &lt;= m) for auxiliary variable and (m+1 &lt;= k &lt;= m+n) for structural variable</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::check_kkt lp glp::sol glp::kkt_pe;
<span class="dv">0.0</span>,<span class="dv">0</span>,<span class="dv">0.0</span>,<span class="dv">0</span>
&gt; glp::check_kkt lp glp::mip glp::kkt_pe;
<span class="dv">2.23517417907715e-008</span>,<span class="dv">1</span>,<span class="dv">7.50126764193079e-016</span>,<span class="dv">34169</span>
&gt;</code></pre></div>
<h3 id="utility-api-routines">Utility API routines</h3>
<h4 id="problem-data-readingwriting-routines">Problem data reading/writing routines</h4>
<h5 id="read-lp-problem-data-from-a-mps-file">Read LP problem data from a MPS file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_mps lp format filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>format</dt>
<dd><p>one of the following</p>
</dd>
</dl>
<blockquote>
<p>:glp::mps_deck: fixed (ancient) MPS file format :glp::mps_file: free (modern) MPS file format</p>
</blockquote>
<dl>
<dt>filename</dt>
<dd><p>file name - if the file name ends with suffix <strong>.gz</strong>, the file is assumed to be compressed, in which case the routine glp::read_mps decompresses it “on the fly”</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_mps lp glp::mps_deck <span class="st">&quot;examples/plan.mps&quot;</span>;
Reading problem data from `examples/plan.mps&#39;...
Problem PLAN
Objective R0000000
<span class="dv">8</span> rows, <span class="dv">7</span> columns, <span class="dv">55</span> non-zeros
<span class="dv">63</span> records were read
<span class="dv">0</span></code></pre></div>
<h5 id="write-lp-problem-data-into-a-mps-file">Write LP problem data into a MPS file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_mps lp format filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>format</dt>
<dd><p>one of the following</p>
</dd>
</dl>
<blockquote>
<p>:glp::mps_deck: fixed (ancient) MPS file format :glp::mps_file: free (modern) MPS file format</p>
</blockquote>
<dl>
<dt>filename</dt>
<dd><p>file name - if the file name ends with suffix <strong>.gz</strong>, the file is assumed to be compressed, in which case the routine glp_write_mps performs automatic compression on writing it</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_mps lp glp::mps_file <span class="st">&quot;examples/plan1.mps&quot;</span>;
Writing problem data to `examples/plan1.mps&#39;...
<span class="dv">63</span> records were written
<span class="dv">0</span></code></pre></div>
<h5 id="read-lp-problem-data-from-a-cplex-file">Read LP problem data from a CPLEX file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_lp lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name - if the file name ends with suffix <strong>.gz</strong>, the file is assumed to be compressed, in which case the routine glp::read_lp decompresses it “on the fly”</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_lp lp <span class="st">&quot;examples/plan.lp&quot;</span>;
reading problem data from `examples/plan.lp&#39;...
<span class="dv">8</span> rows, <span class="dv">7</span> columns, <span class="dv">48</span> non-zeros
<span class="dv">39</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="write-lp-problem-data-into-a-cplex-file">Write LP problem data into a CPLEX file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_lp lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name - if the file name ends with suffix <strong>.gz</strong>, the file is assumed to be compressed, in which case the routine glp::write_lp performs automatic compression on writing it</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_lp lp <span class="st">&quot;examples/plan1.lp&quot;</span>;
writing problem data to `examples/plan1.lp&#39;...
<span class="dv">29</span> lines were written
<span class="dv">0</span></code></pre></div>
<h5 id="read-lp-problem-data-in-glpk-format">Read LP problem data in GLPK format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_prob lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name - if the file name ends with suffix <strong>.gz</strong>, the file is assumed to be compressed, in which case the routine glp::read_prob decompresses it “on the fly”</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_prob lp <span class="st">&quot;examples/plan.glpk&quot;</span>;
reading problem data from `examples/plan.glpk&#39;...
<span class="dv">8</span> rows, <span class="dv">7</span> columns, <span class="dv">48</span> non-zeros
<span class="dv">86</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="write-lp-problem-data-in-glpk-format">Write LP problem data in GLPK format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_prob lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name - if the file name ends with suffix <strong>.gz</strong>, the file is assumed to be compressed, in which case the routine glp::write_prob performs automatic compression on writing it</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_prob lp <span class="st">&quot;examples/plan1.glpk&quot;</span>;
writing problem data to `examples/plan1.glpk&#39;...
<span class="dv">86</span> lines were written
<span class="dv">0</span></code></pre></div>
<h4 id="routines-for-mathprog-models">Routines for MathProg models</h4>
<h5 id="create-the-mathprog-translator-object">Create the MathProg translator object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_alloc_wksp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<p>none</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>pointer to the MathProg translator object</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> mpt = glp::mpl_alloc_wksp;
&gt; mpt;
#&lt;<span class="dt">pointer</span> <span class="dv">0xa0d0180</span>&gt;</code></pre></div>
<h5 id="read-and-translate-model-section">Read and translate model section</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_read_model tranobject filename skip</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tranobject</dt>
<dd><p>pointer to the MathProg translator object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
<dt>skip</dt>
<dd><p>if <strong>0</strong> then the data section from the model file is read; if non-zero, the data section in the data model is skipped</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; mpl_read_model mpt <span class="st">&quot;examples/sudoku.mod&quot;</span> <span class="dv">1</span>;
Reading model section from examples/sudoku.mod...
examples/sudoku.mod:<span class="dv">69</span>: warning: data section ignored
<span class="dv">69</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="read-and-translate-data-section">Read and translate data section</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_read_data tranobject filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tranobject</dt>
<dd><p>pointer to the MathProg translator object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mpl_read_data mpt <span class="st">&quot;examples/sudoku.dat&quot;</span>;
Reading data section from examples/sudoku.dat...
<span class="dv">16</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="generate-the-model">Generate the model</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_generate tranobject filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tranobject</dt>
<dd><p>pointer to the MathProg translator object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if generating went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mpl_generate mpt <span class="st">&quot;examples/sudoku.lst&quot;</span>;
Generating fa...
Generating fb...
Generating fc...
Generating fd...
Generating fe...
Model has been successfully generated
<span class="dv">0</span></code></pre></div>
<h5 id="build-problem-instance-from-the-model">Build problem instance from the model</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_build_prob tranobject lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tranobject</dt>
<dd><p>pointer to the MathProg translator object</p>
</dd>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mpl_build_prob mpt lp;
()</code></pre></div>
<h5 id="postsolve-the-model">Postsolve the model</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_postsolve tran lp solution</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tranobject</dt>
<dd><p>pointer to the MathProg translator object</p>
</dd>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>solution</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::sol: use the basic solution :glp::ipt: use the interior-point solution :glp::mip: use mixed integer solution</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><strong>0</strong> if postsolve went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mpl_postsolve mpt lp glp::sol;
Model has been successfully processed
<span class="dv">0</span></code></pre></div>
<h5 id="delete-the-mathprog-translator-object">Delete the MathProg translator object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mpl_free_wksp tranobject</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tranobject</dt>
<dd><p>pointer to the MathProg translator object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mpl_free_wksp mpt;
()</code></pre></div>
<h4 id="problem-solution-readingwriting-routines">Problem solution reading/writing routines</h4>
<h5 id="write-basic-solution-in-printable-format">Write basic solution in printable format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::print_sol lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::print_sol lp <span class="st">&quot;examples/test.txt&quot;</span>;
Writing basic solution to `examples/test.txt&#39;...
<span class="dv">0</span></code></pre></div>
<h5 id="read-basic-solution-from-a-text-file">Read basic solution from a text file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_sol lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_sol lp <span class="st">&quot;examples/test.txt&quot;</span>;
Reading basic solution from `examples/test.txt&#39;...
<span class="dv">1235</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="write-basic-solution-into-a-text-file">Write basic solution into a text file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_sol lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_sol lp <span class="st">&quot;examples/test.txt&quot;</span>;
Writing basic solution to `examples/test.txt&#39;...
<span class="dv">1235</span> lines were written
<span class="dv">0</span></code></pre></div>
<h5 id="print-sensitivity-analysis-report">Print sensitivity analysis report</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::print_ranges lp indices filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>indices</dt>
<dd><p>list indices k of of rows and columns to be included in the report. If 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object. An empty lists means printing report for all rows and columns.</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<dl>
<dt>0</dt>
<dd><p>if the operation was successful</p>
</dd>
<dt>non-zero</dt>
<dd><p>if the operation failed</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::print_ranges lp [] <span class="st">&quot;sensitivity.rpt&quot;</span>;
Write sensitivity analysis report to `sensitivity.rpt&#39;...                                                                                                                                                           
<span class="dv">0</span></code></pre></div>
<h5 id="write-interior-point-solution-in-printable-format">Write interior-point solution in printable format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::print_ipt lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::print_ipt lp <span class="st">&quot;examples/test.txt&quot;</span>;
Writing interior-point solution to `examples/test.txt&#39;...
<span class="dv">0</span></code></pre></div>
<h5 id="read-interior-point-solution-from-a-text-file">Read interior-point solution from a text file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_ipt lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_ipt lp <span class="st">&quot;examples/test.txt&quot;</span>;
Reading interior-point solution from `examples/test.txt&#39;...
<span class="dv">1235</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="write-interior-point-solution-into-a-text-file">Write interior-point solution into a text file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_ipt lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_ipt lp <span class="st">&quot;examples/test.txt&quot;</span>;
Writing interior-point solution to `examples/test.txt&#39;...
<span class="dv">1235</span> lines were written
<span class="dv">0</span></code></pre></div>
<h5 id="write-mip-solution-in-printable-format">Write MIP solution in printable format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::print_mip lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::print_mip lp <span class="st">&quot;examples/test.txt&quot;</span>;
Writing MIP solution to `examples/test.txt&#39;...
<span class="dv">0</span></code></pre></div>
<h5 id="read-mip-solution-from-a-text-file">Read MIP solution from a text file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_mip lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_mip lp <span class="st">&quot;examples/test.txt&quot;</span>;
Reading MIP solution from `examples/test.txt&#39;...
<span class="dv">1235</span> lines were read
<span class="dv">0</span></code></pre></div>
<h5 id="write-mip-solution-into-a-text-file">Write MIP solution into a text file</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_mip lp filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if writing went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_mip lp <span class="st">&quot;examples/test.txt&quot;</span>;
Writing MIP solution to `examples/test.txt&#39;...
<span class="dv">1235</span> lines were written
<span class="dv">0</span></code></pre></div>
<h3 id="advanced-api-routines">Advanced API routines</h3>
<h4 id="lp-basis-routines">LP basis routines</h4>
<h5 id="check-whether-basis-factorization-exists">Check whether basis factorization exists</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::bf_exists lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<dl>
<dt>non-zero</dt>
<dd><p>the basis factorization exists and can be used for calculations</p>
</dd>
<dt>0</dt>
<dd><p>the basis factorization does not exist</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::bf:exists lp;
<span class="dv">1</span></code></pre></div>
<h5 id="compute-the-basis-factorization">Compute the basis factorization</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::factorize lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::ok: the basis factorization has been successfully computed :glp::ebadb: the basis matrix is invalid, because the number of basic (auxiliary and structural) variables is not the same as the number of rows in the problem object :glp::esing: the basis matrix is singular within the working precision :glp::exond: the basis matrix is ill-conditioned, i.e. its condition number is too large</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::factorize lp;
glp::ok</code></pre></div>
<h5 id="check-whether-basis-factorization-has-been-updated">Check whether basis factorization has been updated</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::bf_updated lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<dl>
<dt>0</dt>
<dd><p>if the basis factorization has been just computed from “scratch”</p>
</dd>
<dt>non-zero</dt>
<dd><p>if the factorization has been updated at least once</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::bf_updated lp;
<span class="dv">0</span></code></pre></div>
<h5 id="get-basis-factorization-parameters">Get basis factorization parameters</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_bfcp lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>complete list of options in a form of tuples (option_name, value):</p>
<p>:glp::fact_type: basis factorization type:</p>
<blockquote>
<p>:glp::bf_ft: LU + Forrest–Tomlin update :glp::bf_bg: LU + Schur complement + Bartels–Golub update :glp::bf_gr: LU + Schur complement + Givens rotation update</p>
</blockquote>
<dl>
<dt>:glp::lu_size: the initial size of the Sparse Vector Area, in non-zeros,</dt>
<dd><p>used on computing LU-factorization of the basis matrix for the first time - if this parameter is set to 0, the initial SVA size is determined automatically</p>
</dd>
<dt>:glp::piv_tol: threshold pivoting (Markowitz) tolerance, 0 &lt; piv_tol &lt; 1,</dt>
<dd><p>used on computing LU-factorization of the basis matrix</p>
</dd>
<dt>:glp::piv_lim: this parameter is used on computing</dt>
<dd><p>LU-factorization of the basis matrix and specifies how many pivot candidates needs to be considered on choosing a pivot element, piv_lim ≥ 1</p>
</dd>
<dt>:glp::suhl: this parameter is used on computing LU-factorization of</dt>
<dd><p>the basis matrix</p>
<p>:glp::on: enables applying the heuristic proposed by Uwe Suhl :glp::off: disables this heuristic</p>
</dd>
<dt>:glp::eps_tol: epsilon tolerance, eps_tol ≥ 0, used on computing</dt>
<dd><p>LU-factorization of the basis matrix</p>
</dd>
<dt>:glp::max_gro: maximal growth of elements of factor U, max_gro ≥ 1,</dt>
<dd><p>allowable on computing LU-factorization of the basis matrix</p>
</dd>
<dt>:glp::nfs_max: maximal number of additional row-like factors (entries of</dt>
<dd><p>the eta file), nfs_max ≥ 1, which can be added to LU-factorization of the basis matrix on updating it with the Forrest–Tomlin technique</p>
</dd>
<dt>:glp::upd_tol: update tolerance, 0 &lt; upd_tol &lt; 1, used on updating</dt>
<dd><p>LU-factorization of the basis matrix with the Forrest–Tomlin technique</p>
</dd>
<dt>:glp::nrs_max: maximal number of additional rows and columns, nrs_max ≥ 1,</dt>
<dd><p>which can be added to LU-factorization of the basis matrix on updating it with the Schur complement technique</p>
</dd>
<dt>:glp::rs_size: the initial size of the Sparse Vector Area, in non-zeros,</dt>
<dd><p>used to store non-zero elements of additional rows and columns introduced on updating LU-factorization of the basis matrix with the Schur complement technique - if this parameter is set to 0, the initial SVA size is determined automatically</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_bfcp lp;
[(glp::fact_type,glp::bf_ft),(glp::lu_size,<span class="dv">0</span>),(glp::piv_tol,<span class="dv">0.1</span>),
(glp::piv_lim,<span class="dv">4</span>),(glp::suhl,glp::on),(glp::eps_tol,<span class="dv">1e-15</span>),
(glp::max_gro,<span class="dv">10000000000.0</span>),(glp::nfs_max,<span class="dv">50</span>),(glp::upd_tol,<span class="dv">1e-06</span>),
(glp::nrs_max,<span class="dv">50</span>),(glp::rs_size,<span class="dv">0</span>)]</code></pre></div>
<h5 id="change-basis-factorization-parameters">Change basis factorization parameters</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_bfcp lp options</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>options</dt>
<dd><p>list of options in a form of tuples (option_name, value):</p>
</dd>
</dl>
<p>:glp::fact_type: (default: glp::bf_ft) - basis factorization type:</p>
<blockquote>
<p>:glp::bf_ft: LU + Forrest–Tomlin update :glp::bf_bg: LU + Schur complement + Bartels–Golub update :glp::bf_gr: LU + Schur complement + Givens rotation update</p>
</blockquote>
<dl>
<dt>:glp::lu_size: (default: 0) - the initial size of the Sparse Vector Area,</dt>
<dd><p>in non-zeros, used on computing LU-factorization of the basis matrix for the first time - if this parameter is set to 0, the initial SVA size is determined automatically</p>
</dd>
<dt>:glp::piv_tol: (default: 0.10) - threshold pivoting (Markowitz) tolerance,</dt>
<dd><p>0 &lt; piv_tol &lt; 1, used on computing LU-factorization of the basis matrix.</p>
</dd>
<dt>:glp::piv_lim: (default: 4) - this parameter is used on computing</dt>
<dd><p>LU-factorization of the basis matrix and specifies how many pivot candidates needs to be considered on choosing a pivot element, piv_lim ≥ 1</p>
</dd>
<dt>:glp::suhl: (default: glp::on) - this parameter is used on computing</dt>
<dd><p>LU-factorization of the basis matrix.</p>
<p>:glp::on: enables applying the heuristic proposed by Uwe Suhl :glp::off: disables this heuristic</p>
</dd>
<dt>:glp::eps_tol: (default: 1e-15) - epsilon tolerance, eps_tol ≥ 0, used on</dt>
<dd><p>computing LU -factorization of the basis matrix.</p>
</dd>
<dt>:glp::max_gro: (default: 1e+10) - maximal growth of elements of factor U,</dt>
<dd><p>max_gro ≥ 1, allowable on computing LU-factorization of the basis matrix.</p>
</dd>
<dt>:glp::nfs_max: (default: 50) - maximal number of additional row-like</dt>
<dd><p>factors (entries of the eta file), nfs_max ≥ 1, which can be added to LU-factorization of the basis matrix on updating it with the Forrest–Tomlin technique.</p>
</dd>
<dt>:glp::upd_tol: (default: 1e-6) - update tolerance, 0 &lt; upd_tol &lt; 1,</dt>
<dd><p>used on updating LU -factorization of the basis matrix with the Forrest–Tomlin technique.</p>
</dd>
<dt>:glp::nrs_max: (default: 50) - maximal number of additional rows and</dt>
<dd><p>columns, nrs_max ≥ 1, which can be added to LU-factorization of the basis matrix on updating it with the Schur complement technique.</p>
</dd>
<dt>:glp::rs_size: (default: 0) - the initial size of the Sparse Vector Area,</dt>
<dd><p>in non-zeros, used to store non-zero elements of additional rows and columns introduced on updating LU-factorization of the basis matrix with the Schur complement technique -if this parameter is set to 0, the initial SVA size is determined automatically</p>
</dd>
</dl>
<p><strong>Remarks</strong>:</p>
</blockquote>
<blockquote>
<p>Options not mentioned in the option list are left unchanged.</p>
<p>All options will be reset to their default values when an empty option list is supplied.</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code> if all options are OK, otherwise returns a list of bad options</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp_set_bfcp lp [(glp::fact_type, glp::bf_ft), (glp::piv_tol, <span class="dv">0.15</span>)];
()</code></pre></div>
<h5 id="retrieve-the-basis-header-information">Retrieve the basis header information</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_bhead lp k</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>k</dt>
<dd><p>variable index in the basis matrix</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>If basic variable (xB )k , 1 ≤ k ≤ m, is i-th auxiliary variable (1 ≤ i ≤ m), the routine returns i. Otherwise, if (xB )k is j-th structural variable (1 ≤ j ≤ n), the routine returns m+j. Here m is the number of rows and n is the number of columns in the problem object.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_bhead lp <span class="dv">3</span>;
<span class="dv">5</span></code></pre></div>
<h5 id="retrieve-row-index-in-the-basis-header">Retrieve row index in the basis header</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_row_bind lp rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤ m, which is i-th auxiliary variable (that is, the auxiliary variable corresponding to i-th row), 1 ≤ i ≤ m, in the current basis associated with the specified problem object, where m is the number of rows. However, if i-th auxiliary variable is non-basic, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_row_bind lp <span class="dv">3</span>;
<span class="dv">1</span></code></pre></div>
<h5 id="retrieve-column-index-in-the-basis-header">Retrieve column index in the basis header</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::get_col_bind lp colindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colindex</dt>
<dd><p>column index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤ m, which is j-th structural variable (that is, the structural variable corresponding to j-th column), 1 ≤ j ≤ n, in the current basis associated with the specified problem object, where m is the number of rows, n is the number of columns. However, if j-th structural variable is non-basic, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::get_col_bind lp <span class="dv">2</span>;
<span class="dv">3</span></code></pre></div>
<h5 id="perform-forward-transformation">Perform forward transformation</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ftran lp vector</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>vector</dt>
<dd><p>vector to be transformed - a dense vector in a form of a list of double numbers has to be supplied and the number of its members must exactly correspond to the number of LP problem constraints</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the transformed vector in the same format</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ftran lp [<span class="dv">1.5</span>, <span class="dv">3.2</span>, <span class="dv">4.8</span>];
[<span class="dv">1.8</span>,<span class="dv">0.466666666666667</span>,-<span class="dv">1.96666666666667</span>]</code></pre></div>
<h5 id="perform-backward-transformation">Perform backward transformation</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::btran lp vector</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>vector</dt>
<dd><p>vector to be transformed - a dense vector in a form of a list of double numbers has to be supplied and the number of its members must exactly correspond to the number of LP problem constraints</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the transformed vector in the same format</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::btran lp [<span class="dv">1.5</span>, <span class="dv">3.2</span>, <span class="dv">4.8</span>];
[-<span class="dv">8.86666666666667</span>,<span class="dv">0.266666666666667</span>,<span class="dv">1.5</span>]</code></pre></div>
<h5 id="warm-up-lp-basis">Warm up LP basis</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::warm_up lp</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::ok: the LP basis has been successfully “warmed up” :glp::ebadb: the LP basis is invalid, because the number of basic variables is not the same as the number of rows :glp::esing: the basis matrix is singular within the working precision :glp::econd: the basis matrix is ill-conditioned, i.e. its condition number is too large</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::warm_up lp;
glp::e_ok</code></pre></div>
<h4 id="simplex-tableau-routines">Simplex tableau routines</h4>
<h5 id="compute-row-of-the-tableau">Compute row of the tableau</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::eval_tab_row lp k</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>k</dt>
<dd><p>variable index such that it corresponds to some basic variable: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>simplex tableau row in a sparse form as a list of tuples (index, value), where index has the same meaning as k in parameters</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::eval_tab_row lp <span class="dv">3</span>;
[(<span class="dv">1</span>,<span class="dv">2.0</span>),(<span class="dv">6</span>,<span class="dv">4.0</span>)]</code></pre></div>
<h5 id="compute-column-of-the-tableau">Compute column of the tableau</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::eval_tab_col lp k</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>k</dt>
<dd><p>variable index such that it corresponds to some non-basic variable: if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>simplex tableau column in a sparse form as a list of tuples (index, value), where index has the same meaning as k in parameters</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::eval_tab_col lp <span class="dv">1</span>;
[(<span class="dv">3</span>,<span class="dv">2.0</span>),(<span class="dv">4</span>,-<span class="dv">0.666666666666667</span>),(<span class="dv">5</span>,<span class="dv">1.66666666666667</span>)]</code></pre></div>
<h5 id="transform-explicitly-specified-row">Transform explicitly specified row</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::transform_row lp rowvector</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowvector</dt>
<dd><p>row vector to be transformed in a sparse form as a list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the transformed row in a sparse form as a list of tuples (index, value), where index has the same meaning as k in parameters</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::transform_row lp [(<span class="dv">1</span>, <span class="dv">3.0</span>), (<span class="dv">2</span>, <span class="dv">3.5</span>)];
[(<span class="dv">1</span>,<span class="dv">3.83333333333333</span>),(<span class="dv">2</span>,-<span class="dv">0.0833333333333333</span>),(<span class="dv">6</span>,-<span class="dv">3.41666666666667</span>)]</code></pre></div>
<h5 id="transform-explicitly-specified-column">Transform explicitly specified column</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::transform_col lp colvector</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colvector</dt>
<dd><p>column vector to be transformed in a sparse form as a list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>the transformed column in a sparse form as a list of tuples (index, value), where index has the same meaning as k in parameters</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::transform_col lp [(<span class="dv">2</span>, <span class="dv">1.0</span>), (<span class="dv">3</span>, <span class="dv">2.3</span>)];
[(<span class="dv">3</span>,<span class="dv">2.3</span>),(<span class="dv">4</span>,-<span class="dv">0.166666666666667</span>),(<span class="dv">5</span>,<span class="dv">0.166666666666667</span>)]</code></pre></div>
<h5 id="perform-primal-ratio-test">Perform primal ratio test</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::prim_rtest lp colvector dir eps</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>colvector</dt>
<dd><p>simplex tableau column in a sparse form as a list of tuples (k, value): if 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist and the primal solution must be feasible)</p>
</dd>
<dt>dir</dt>
<dd><p>specifies in which direction the variable y changes on entering the basis: +1 means increasing, −1 means decreasing</p>
</dd>
<dt>eps</dt>
<dd><p>relative tolerance (small positive number) used to skip small values in the column</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the index, piv, in the colvector corresponding to the pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic solution is primal unbounded, and therefore the choice cannot be made, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::prim_rtest lp [(<span class="dv">3</span>, <span class="dv">2.5</span>), (<span class="dv">5</span>, <span class="dv">7.0</span>)] <span class="dv">1</span> <span class="dv">1.0e-5</span>;
<span class="dv">3</span></code></pre></div>
<h5 id="perform-dual-ratio-test">Perform dual ratio test</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::dual_rtest lp rowvector dir eps</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>rowvector</dt>
<dd><p>simplex tableau row in a sparse form as a list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist and the dual solution must be feasible)</p>
</dd>
<dt>dir</dt>
<dd><p>specifies in which direction the variable y changes on leaving the basis: +1 means increasing, −1 means decreasing</p>
</dd>
<dt>eps</dt>
<dd><p>relative tolerance (small positive number) used to skip small values in the row</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the index, piv, in the rowvector corresponding to the pivot element chosen, 1 ≤ piv ≤ len. If the adjacent basic solution is dual unbounded, and therefore the choice cannot be made, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::dual_rtest lp [(<span class="dv">1</span>, <span class="dv">1.5</span>), (<span class="dv">6</span>, <span class="dv">4.0</span>)] <span class="dv">1</span> <span class="dv">1.0e-5</span>;
<span class="dv">6</span></code></pre></div>
<h5 id="analyze-active-bound-of-non-basic-variable">Analyze active bound of non-basic variable</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::analyze_bound lp k</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>k</dt>
<dd><p>if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist and the solution must be optimal)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns a tuple (limit1, var1, limit2 var2) where:</p>
<dl>
<dt>value1</dt>
<dd><p>the minimal value of the active bound, at which the basis still remains primal feasible and thus optimal. -DBL_MAX means that the active bound has no lower limit.</p>
</dd>
<dt>var1</dt>
<dd><p>the ordinal number of an auxiliary (1 to m) or structural (m + 1 to m + n) basic variable, which reaches its bound first and thereby limits further decreasing the active bound being analyzed. If value1 = -DBL_MAX, var1 is set to 0.</p>
</dd>
<dt>value2</dt>
<dd><p>the maximal value of the active bound, at which the basis still remains primal feasible and thus optimal. +DBL_MAX means that the active bound has no upper limit.</p>
</dd>
<dt>var2</dt>
<dd><p>the ordinal number of an auxiliary (1 to m) or structural (m + 1 to m + n) basic variable, which reaches its bound first and thereby limits further increasing the active bound being analyzed. If value2 = +DBL_MAX, var2 is set to 0.</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; analyze_bound lp <span class="dv">2</span>;
<span class="dv">1995.06864446899</span>,<span class="dv">12</span>,<span class="dv">2014.03478832467</span>,<span class="dv">4</span></code></pre></div>
<h5 id="analyze-objective-coefficient-at-basic-variable">Analyze objective coefficient at basic variable</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::analyze_coef lp k</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>k</dt>
<dd><p>if 1 ≤ k ≤ m, the basic variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is (k − m)-th structural variable, where m is the number of rows and n is the number of columns in the specified problem object (the basis factorization must exist and the solution must be optimal)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns a tuple (coef1, var1, value1, coef2 var2, value2) where:</p>
<dl>
<dt>coef1</dt>
<dd><p>the minimal value of the objective coefficient, at which the basis still remains dual feasible and thus optimal. -DBL_MAX means that the objective coefficient has no lower limit.</p>
</dd>
<dt>var1</dt>
<dd><p>is the ordinal number of an auxiliary (1 to m) or structural (m + 1 to m + n) non-basic variable, whose reduced cost reaches its zero bound first and thereby limits further decreasing the objective coefficient being analyzed. If coef1 = -DBL_MAX, var1 is set to 0.</p>
</dd>
<dt>value1</dt>
<dd><p>value of the basic variable being analyzed in an adjacent basis, which is defined as follows. Let the objective coefficient reaches its minimal value (coef1) and continues decreasing. Then the reduced cost of the limiting non-basic variable (var1) becomes dual infeasible and the current basis becomes non-optimal that forces the limiting non-basic variable to enter the basis replacing there some basic variable that leaves the basis to keep primal feasibility. Should note that on determining the adjacent basis current bounds of the basic variable being analyzed are ignored as if it were free (unbounded) variable, so it cannot leave the basis. It may happen that no dual feasible adjacent basis exists, in which case value1 is set to -DBL_MAX or +DBL_MAX.</p>
</dd>
<dt>coef2</dt>
<dd><p>the maximal value of the objective coefficient, at which the basis still remains dual feasible and thus optimal. +DBL_MAX means that the objective coefficient has no upper limit.</p>
</dd>
<dt>var2</dt>
<dd><p>the ordinal number of an auxiliary (1 to m) or structural (m + 1 to m + n) non-basic variable, whose reduced cost reaches its zero bound first and thereby limits further increasing the objective coefficient being analyzed. If coef2 = +DBL_MAX, var2 is set to 0.</p>
</dd>
<dt>value2</dt>
<dd><p>value of the basic variable being analyzed in an adjacent basis, which is defined exactly in the same way as value1 above with exception that now the objective coefficient is increasing.</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; analyze_coef lp <span class="dv">1</span>;
-<span class="dv">1.0</span>,<span class="dv">3</span>,<span class="dv">306.771624713959</span>,<span class="dv">1.79769313486232e+308</span>,<span class="dv">0</span>,<span class="dv">296.216606498195</span></code></pre></div>
<h3 id="branch-and-cut-api-routines">Branch-and-cut API routines</h3>
<blockquote>
<p>All branch-and-cut API routines are supposed to be called from the callback routine. They cannot be called directly.</p>
</blockquote>
<h4 id="basic-routines">Basic routines</h4>
<h5 id="determine-reason-for-calling-the-callback-routine">Determine reason for calling the callback routine</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_reason tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>one of the following:</p>
<p>:glp::irowgen: request for row generation :glp::ibingo: better integer solution found :glp::iheur: request for heuristic solution :glp::icutgen: request for cut generation :glp::ibranch: request for branching :glp::iselect: request for subproblem selection :glp::iprepro: request for preprocessing</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios:reason tree;</code></pre></div>
<h5 id="access-the-problem-object">Access the problem object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_get_prob tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns a pointer to the problem object used by the MIP solver.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_get_prob tree;</code></pre></div>
<h5 id="determine-additional-row-attributes">Determine additional row attributes</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_row_attr tree rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>rowindex</dt>
<dd><p>row index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns a tuple consisting of three values (level, origin, klass):</p>
<dl>
<dt>level</dt>
<dd><p>subproblem level at which the row was created</p>
</dd>
<dt>origin</dt>
<dd><p>the row origin flag - one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::rf_reg: regular constraint :glp::rf_lazy: “lazy” constraint :glp::rf_cut: cutting plane constraint</p>
</blockquote>
<dl>
<dt>klass</dt>
<dd><p>the row class descriptor, which is a number passed to the routine glp_ios_add_row as its third parameter - if the row is a cutting plane constraint generated by the solver, its class may be the following:</p>
<p>:glp::rf_gmi: Gomory’s mixed integer cut :glp::rf_mir: mixed integer rounding cut :glp::rf_cov: mixed cover cut :glp::rf_clq: clique cut</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_row_attr tree <span class="dv">3</span>;</code></pre></div>
<h5 id="compute-relative-mip-gap">Compute relative MIP gap</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_mip_gap tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the relative MIP gap.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_mip_gap tree;</code></pre></div>
<h5 id="access-application-specific-data">Access application-specific data</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_node_data tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine glp_ios_node_data returns a pointer to the memory block for the specified subproblem. Note that if cb_size = 0 was specified in the call of the <em>intopt</em> function, the routine returns a null pointer.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_node_data tree <span class="dv">23</span>;</code></pre></div>
<h5 id="select-subproblem-to-continue-the-search">Select subproblem to continue the search</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_select_node tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>node</dt>
<dd><p>reference number of the subproblem from which the search will continue</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_select_node tree <span class="dv">23</span>;</code></pre></div>
<h5 id="provide-solution-found-by-heuristic">Provide solution found by heuristic</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_heur_sol tree colvector</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>colvector</dt>
<dd><p>solution found by a primal heuristic. Primal values of all variables (columns) found by the heuristic should be placed in the list, i. e. the list must contain n numbers where n is the number of columns in the original problem object. Note that the routine does not check primal feasibility of the solution provided.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>If the provided solution is accepted, the routine returns zero. Otherwise, if the provided solution is rejected, the routine returns non-zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_heur_sol tree [<span class="dv">15.7</span>, (-<span class="dv">3.1</span>), <span class="dv">2.2</span>];</code></pre></div>
<h5 id="check-whether-can-branch-upon-specified-variable">Check whether can branch upon specified variable</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_can_branch tree j</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>j</dt>
<dd><p>variable (column) index</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The function returns non-zero if j-th variable can be used for branching. Otherwise, it returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_can_branch tree <span class="dv">23</span>;</code></pre></div>
<h5 id="choose-variable-to-branch-upon">Choose variable to branch upon</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_branch_upon tree j selection</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>j</dt>
<dd><p>ordinal number of the selected branching variable</p>
</dd>
<dt>selection</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::dn_brnch: select down-branch :glp::up_brnch: select up-branch :glp::no_brnch: use general selection technique</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_branch_upon tree <span class="dv">23</span> glp::up_brnch;</code></pre></div>
<h5 id="terminate-the-solution-process">Terminate the solution process</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_terminate tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_terminate tree;</code></pre></div>
<h4 id="the-search-tree-exploring-routines">The search tree exploring routines</h4>
<h5 id="determine-the-search-tree-size">Determine the search tree size</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_tree_size tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns a tuple (a_cnt, n_cnt, t_cnt), where</p>
<dl>
<dt>a_cnt</dt>
<dd><p>the current number of active nodes</p>
</dd>
<dt>n_cnt</dt>
<dd><p>the current number of all (active and inactive) nodes</p>
</dd>
<dt>t_cnt</dt>
<dd><p>the total number of nodes including those which have been already removed from the tree. This count is increased whenever a new node appears in the tree and never decreased.</p>
</dd>
</dl>
<p><strong>Example</strong>:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_tree_size tree;</code></pre></div>
<h5 id="determine-current-active-subproblem">Determine current active subproblem</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_curr_node tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the reference number of the current active subproblem. If the current subproblem does not exist, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_curr_node tree;</code></pre></div>
<h5 id="determine-next-active-subproblem">Determine next active subproblem</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_next_node tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>node</dt>
<dd><p>reference number of an active subproblem or zero</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>If the parameter p is zero, the routine returns the reference number of the first active subproblem. If the tree is empty, zero is returned. If the parameter p is not zero, it must specify the reference number of some active subproblem, in which case the routine returns the reference number of the next active subproblem. If there is no next active subproblem in the list, zero is returned. All subproblems in the active list are ordered chronologically, i.e. subproblem A precedes subproblem B if A was created before B.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_next_node tree <span class="dv">23</span>;</code></pre></div>
<h5 id="determine-previous-active-subproblem">Determine previous active subproblem</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_prev_node tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>node</dt>
<dd><p>reference number of an active subproblem or zero</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>If the parameter p is zero, the routine returns the reference number of the last active subproblem. If the tree is empty, zero is returned. If the parameter p is not zero, it must specify the reference number of some active subproblem, in which case the routine returns the reference number of the previous active subproblem. If there is no previous active subproblem in the list, zero is returned. All subproblems in the active list are ordered chronologically, i.e. subproblem A precedes subproblem B if A was created before B.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_prev_node tree <span class="dv">23</span>;</code></pre></div>
<h5 id="determine-parent-active-subproblem">Determine parent active subproblem</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_up_node tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>node</dt>
<dd><p>reference number of an active or inactive subproblem</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the reference number of its parent subproblem. If the specified subproblem is the root of the tree, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_up_node tree <span class="dv">23</span>;</code></pre></div>
<h5 id="determine-subproblem-level">Determine subproblem level</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_node_level tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>node</dt>
<dd><p>reference number of an active or inactive subproblem</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the level of the given subproblem in the branch-and-bound tree. (The root subproblem has level 0.)</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_node_level tree <span class="dv">23</span>;</code></pre></div>
<h5 id="determine-subproblem-local-bound">Determine subproblem local bound</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_node_bound tree node</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>node</dt>
<dd><p>reference number of an active or inactive subproblem</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the local bound for the given subproblem.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_node_bound tree <span class="dv">23</span>;</code></pre></div>
<h5 id="find-active-subproblem-with-the-best-local-bound">Find active subproblem with the best local bound</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_best_node tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the reference number of the active subproblem, whose local bound is best (i.e. smallest in case of minimization or largest in case of maximization). If the tree is empty, the routine returns zero.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_best_node tree;</code></pre></div>
<h4 id="the-cut-pool-routines">The cut pool routines</h4>
<h5 id="determine-current-size-of-the-cut-pool">Determine current size of the cut pool</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_pool_size tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the current size of the cut pool, that is, the number of cutting plane constraints currently added to it.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_pool_size tree;</code></pre></div>
<h5 id="add-constraint-to-the-cut-pool">Add constraint to the cut pool</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_add_row tree (name, klass, flags, row, rowtype, rhs)</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>name</dt>
<dd><p>symbolic name of the constraint</p>
</dd>
<dt>klass</dt>
<dd><p>specifies the constraint class, which must be either zero or a number in the range from 101 to 200. The application may use this attribute to distinguish between cutting plane constraints of different classes.</p>
</dd>
<dt>flags</dt>
<dd><p>currently is not used and must be zero</p>
</dd>
<dt>row</dt>
<dd><p>list of pairs (colindex, coefficient)</p>
</dd>
<dt>rowtype</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::lo: ∑(aj.xj) ≥ RHS constraint :glp::up: ∑(aj.xj) ≤ RHS constraint</p>
</blockquote>
<dl>
<dt>rhs</dt>
<dd><p>right hand side of the constraint</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the ordinal number of the cutting plane constraint added, which is the new size of the cut pool.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_add_row tree (<span class="st">&quot;new_constraint&quot;</span>, <span class="dv">101</span>, <span class="dv">0</span>,
                         [(<span class="dv">3</span>, <span class="dv">15.0</span>), (<span class="dv">4</span>, <span class="dv">6.7</span>), (<span class="dv">8</span>, <span class="dv">1.25</span>)], glp::up, <span class="dv">152.7</span>);</code></pre></div>
<h5 id="remove-constraint-from-the-cut-pool">Remove constraint from the cut pool</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_del_row tree rowindex</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
<dt>rowindex</dt>
<dd><p>index of row to be deleted from the cut pool</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>Note that deleting a constraint from the cut pool leads to changing ordinal numbers of other constraints remaining in the pool. New ordinal numbers of the remaining constraints are assigned under assumption that the original order of constraints is not changed.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_del_row tree <span class="dv">5</span>;</code></pre></div>
<h5 id="remove-all-constraints-from-the-cut-pool">Remove all constraints from the cut pool</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::ios_clear_pool tree</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>tree</dt>
<dd><p>pointer to the branch-and-cut search tree</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::ios_clear_pool tree;</code></pre></div>
<h3 id="graph-and-network-api-routines">Graph and network API routines</h3>
<h4 id="basic-graph-routines">Basic graph routines</h4>
<h5 id="create-the-glpk-graph-object">Create the GLPK graph object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::create_graph v_size a_size</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>v_size</dt>
<dd><p>size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256</p>
</dd>
<dt>a_size</dt>
<dd><p>size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns a pointer to the graph created.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> g = glp::create_graph <span class="dv">32</span> <span class="dv">64</span>;
&gt; g;
#&lt;<span class="dt">pointer</span> <span class="dv">0x9de7168</span>&gt;</code></pre></div>
<h5 id="set-the-graph-name">Set the graph name</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::set_graph_name graph name</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>name</dt>
<dd><p>the graph name, an empty string erases the current name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::set_graph_name graph <span class="st">&quot;MyGraph&quot;</span>;
()</code></pre></div>
<h5 id="add-vertices-to-a-graph">Add vertices to a graph</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::add_vertices graph count</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>count</dt>
<dd><p>number of vertices to add</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the ordinal number of the first new vertex added to the graph.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::add_vertices graph <span class="dv">5</span>;
<span class="dv">18</span></code></pre></div>
<h5 id="add-arc-to-a-graph">Add arc to a graph</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::add_arc graph i j</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>i</dt>
<dd><p>index of the tail vertex</p>
</dd>
<dt>j</dt>
<dd><p>index of the head vertex</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::add_arc graph <span class="dv">7</span> <span class="dv">12</span>;
()</code></pre></div>
<h5 id="erase-content-of-the-glpk-graph-object">Erase content of the GLPK graph object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::erase_graph graph v_size a_size</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_size</dt>
<dd><p>size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256</p>
</dd>
<dt>a_size</dt>
<dd><p>size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>The routine reinitialises the graph object. Its efect is equivalent to calling delete_graph followed by a call to create_graph.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::erase_graph graph <span class="dv">16</span> <span class="dv">34</span>;
()</code></pre></div>
<h5 id="delete-the-glpk-graph-object">Delete the GLPK graph object</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::delete_graph graph</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Remark</strong>:</p>
<blockquote>
<p>The routine destroys the graph object and invalidates the pointer. This is done automatically when the graph is not needed anymore, the routine need not be usually called.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::delete_graph graph
()</code></pre></div>
<h5 id="read-graph-in-a-plain-text-format">Read graph in a plain text format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_graph graph filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_graph graph <span class="st">&quot;graph_data.txt&quot;</span>;
<span class="dv">0</span></code></pre></div>
<h5 id="write-graph-in-a-plain-text-format">Write graph in a plain text format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_graph graph filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>filename</dt>
<dd><p>file name</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_graph graph <span class="st">&quot;graph_data.txt&quot;</span>;
<span class="dv">0</span></code></pre></div>
<h4 id="graph-analysis-routines">Graph analysis routines</h4>
<h5 id="find-all-weakly-connected-components-of-a-graph">Find all weakly connected components of a graph</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::weak_comp graph v_num</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_num</dt>
<dd><p>offset of the field of type int in the vertex data block, to which the routine stores the number of a weakly connected component containing that vertex - if v_num &lt; 0, no component numbers are stored</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>The routine returns the total number of components found.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::weak_comp graph <span class="dv">16</span>;
<span class="dv">3</span></code></pre></div>
<h5 id="find-all-strongly-connected-components-of-a-graph">Find all strongly connected components of a graph</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::strong_comp graph v_num</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_num</dt>
<dd><p>offset of the field of type int in the vertex data block, to which the routine stores the number of a strongly connected component containing that vertex - if v_num &lt; 0, no component numbers are stored</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p>The routine returns the total number of components found.</p>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::strong_comp graph <span class="dv">16</span>;
<span class="dv">4</span></code></pre></div>
<h4 id="minimum-cost-flow-problem">Minimum cost flow problem</h4>
<h5 id="read-minimum-cost-flow-problem-data-in-dimacs-format">Read minimum cost flow problem data in DIMACS format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_mincost graph v_rhs a_low a_cap a_cost filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_rhs</dt>
<dd><p>offset of the field of type double in the vertex data block, to which the routine stores bi, the supply/demand value -if v_rhs &lt; 0, the value is not stored</p>
</dd>
<dt>a_low</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores lij, the lower bound to the arc flow - if a_low &lt; 0, the lower bound is not stored</p>
</dd>
<dt>a_cap</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores uij, the upper bound to the arc flow (the arc capacity) - if a_cap &lt; 0, the upper bound is not stored</p>
</dd>
<dt>a_cost</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores cij, the per-unit cost of the arc flow - if a_cost &lt; 0, the cost is not stored</p>
</dd>
<dt>fname</dt>
<dd><p>the name of a text file to be read in - if the file name name ends with the suffix ‘.gz’, the file is assumed to be compressed, in which case the routine decompresses it “on the fly”</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::read_mincost graph <span class="dv">0</span> <span class="dv">8</span> <span class="dv">16</span> <span class="dv">24</span> <span class="st">&quot;graphdata.txt&quot;</span>;
<span class="dv">0</span></code></pre></div>
<h5 id="write-minimum-cost-flow-problem-data-in-dimacs-format">Write minimum cost flow problem data in DIMACS format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_mincost graph v_rhs a_low a_cap a_cost fname</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_rhs</dt>
<dd><p>offset of the field of type double in the vertex data block, to which the routine stores bi, the supply/demand value -if v_rhs &lt; 0, the value is not stored</p>
</dd>
<dt>a_low</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores lij, the lower bound to the arc flow - if a_low &lt; 0, the lower bound is not stored</p>
</dd>
<dt>a_cap</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores uij, the upper bound to the arc flow (the arc capacity) - if a_cap &lt; 0, the upper bound is not stored</p>
</dd>
<dt>a_cost</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores cij, the per-unit cost of the arc flow - if a_cost &lt; 0, the cost is not stored</p>
</dd>
<dt>fname</dt>
<dd><p>the name of a text file to be written out - if the file name name ends with the suffix ‘.gz’, the file is assumed to be compressed, in which case the routine compresses it “on the fly”</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if reading went OK; non-zero in case of an error</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::write_mincost graph <span class="dv">0</span> <span class="dv">8</span> <span class="dv">16</span> <span class="dv">24</span> <span class="st">&quot;graphdata.txt&quot;</span>;
<span class="dv">0</span></code></pre></div>
<h5 id="convert-minimum-cost-flow-problem-to-lp">Convert minimum cost flow problem to LP</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>lp</dt>
<dd><p>pointer to the LP problem object</p>
</dd>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>names</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<dl>
<dt>:glp::on: assign symbolic names of the graph object components</dt>
<dd><p>to symbolic names of the LP problem object components</p>
</dd>
</dl>
<p>:glp::off: no symbolic names are assigned</p>
</blockquote>
<dl>
<dt>v_rhs</dt>
<dd><p>offset of the field of type double in the vertex data block, to which the routine stores bi, the supply/demand value -if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</dd>
<dt>a_low</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores lij, the lower bound to the arc flow - if a_low &lt; 0, it is assumed lij = 0 for all arcs</p>
</dd>
<dt>a_cap</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores uij, the upper bound to the arc flow (the arc capacity) - if a_cap &lt; 0,it is assumed uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</dd>
<dt>a_cost</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores cij, the per-unit cost of the arc flow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p>()</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mincost_lp lp graph glp::on <span class="dv">0</span> <span class="dv">8</span> <span class="dv">16</span> <span class="dv">24</span>;
()</code></pre></div>
<h5 id="solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm">Solve minimum cost flow problem with out-of-kilter algorithm</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_rhs</dt>
<dd><p>offset of the field of type double in the vertex data block, to which the routine stores bi, the supply/demand value -if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</dd>
<dt>a_low</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores lij, the lower bound to the arc flow - if a_low &lt; 0, it is assumed lij = 0 for all arcs</p>
</dd>
<dt>a_cap</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores uij, the upper bound to the arc flow (the arc capacity) - if a_cap &lt; 0,it is assumed uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</dd>
<dt>a_cost</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores cij, the per-unit cost of the arc flow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</dd>
<dt>a_x</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores xij, the arc flow found - if a_x &lt; 0, the arc flow value is not stored</p>
</dd>
<dt>v_pi</dt>
<dd><p>specifies an offset of the field of type double in the vertex data block, to which the routine stores pi, the node potential, which is the Lagrange multiplier for the corresponding flow conservation equality constraint</p>
</dd>
</dl>
<p><strong>Remark</strong>:</p>
</blockquote>
<blockquote>
<p>Note that all solution components (the objective value, arc flows, and node potentials) computed by the routine are always integer-valued.</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>The function returns a tuple in the form <strong>(code, obj)</strong>, where <strong>code</strong> is one of the following</p>
<p>:glp::ok: optimal solution found :glp::enopfs: no (primal) feasible solution exists :glp::edata: unable to start the search, because some problem data are either not integer-valued or out of range; this code is also returned if the total supply, which is the sum of bi over all source nodes (nodes with bi &gt; 0), exceeds INT_MAX :glp::erange: the search was prematurely terminated because of integer overflow :glp::efail: an error has been detected in the program logic - if this code is returned for your problem instance, please report to &lt;<a href="mailto:bug-glpk@gnu.org">bug-glpk@gnu.org</a>&gt;</p>
<p>and <strong>obj</strong> is value of the objective function.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mincost_okalg graph <span class="dv">0</span> <span class="dv">8</span> <span class="dv">16</span> <span class="dv">24</span> <span class="dv">32</span> <span class="dv">40</span>;
(glp::ok, <span class="dv">15</span>)</code></pre></div>
<h5 id="klingmans-network-problem-generator">Klingman’s network problem generator</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::netgen graph v_rhs a_cap a_cost parameters</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_rhs</dt>
<dd><p>offset of the field of type double in the vertex data block, to which the routine stores bi, the supply/demand value -if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</dd>
<dt>a_cap</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores uij, the upper bound to the arc flow (the arc capacity) - if a_cap &lt; 0,it is assumed uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</dd>
<dt>a_cost</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores cij, the per-unit cost of the arc flow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</dd>
<dt>parameters</dt>
<dd><p>tuple of exactly 15 integer numbers with the following meaning:</p>
</dd>
<dt>parm[1]</dt>
<dd><p>iseed 8-digit positive random number seed</p>
</dd>
<dt>parm[2]</dt>
<dd><p>nprob 8-digit problem id number</p>
</dd>
<dt>parm[3]</dt>
<dd><p>nodes total number of nodes</p>
</dd>
<dt>parm[4]</dt>
<dd><p>nsorc total number of source nodes (including transshipment nodes)</p>
</dd>
<dt>parm[5]</dt>
<dd><p>nsink total number of sink nodes (including transshipment nodes)</p>
</dd>
<dt>parm[6]</dt>
<dd><p>iarcs number of arc</p>
</dd>
<dt>parm[7]</dt>
<dd><p>mincst minimum cost for arcs</p>
</dd>
<dt>parm[8]</dt>
<dd><p>maxcst maximum cost for arcs</p>
</dd>
<dt>parm[9]</dt>
<dd><p>itsup total supply</p>
</dd>
<dt>parm[10]</dt>
<dd><p>ntsorc number of transshipment source nodes</p>
</dd>
<dt>parm[11]</dt>
<dd><p>ntsink number of transshipment sink nodes</p>
</dd>
<dt>parm[12]</dt>
<dd><p>iphic percentage of skeleton arcs to be given the maximum cost</p>
</dd>
<dt>parm[13]</dt>
<dd><p>ipcap percentage of arcs to be capacitated</p>
</dd>
<dt>parm[14]</dt>
<dd><p>mincap minimum upper bound for capacitated arcs</p>
</dd>
<dt>parm[15]</dt>
<dd><p>maxcap maximum upper bound for capacitated arcs</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><strong>0</strong> if the instance was successfully generated, nonzero otherwise</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::netgen graph <span class="dv">0</span> <span class="dv">8</span> <span class="dv">16</span> (<span class="dv">12345678</span>, <span class="dv">87654321</span>, <span class="dv">20</span>, <span class="dv">12</span>, <span class="dv">8</span>,
                            <span class="dv">25</span>, <span class="dv">5</span>, <span class="dv">20</span>, <span class="dv">300</span>, <span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">100</span>, <span class="dv">1</span>, <span class="dv">30</span>);
<span class="dv">0</span></code></pre></div>
<h5 id="grid-like-network-problem-generator">Grid-like network problem generator</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::gridgen graph v_rhs a_cap a_cost parameters</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
<dt>v_rhs</dt>
<dd><p>offset of the field of type double in the vertex data block, to which the routine stores bi, the supply/demand value -if v_rhs &lt; 0, it is assumed bi = 0 for all nodes</p>
</dd>
<dt>a_cap</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores uij, the upper bound to the arc flow (the arc capacity) - if a_cap &lt; 0,it is assumed uij = 1 for all arcs, value of DBL_MAX means an uncapacitated arc</p>
</dd>
<dt>a_cost</dt>
<dd><p>offset of the field of type double in the arc data block, to which the routine stores cij, the per-unit cost of the arc flow - if a_cost &lt; 0, it is assumed cij = 0 for all arcs</p>
</dd>
<dt>parameters</dt>
<dd><p>tuple of exactly 14 integer numbers with the following meaning:</p>
</dd>
<dt>parm[1]</dt>
<dd><p>two-ways arcs indicator:</p>
</dd>
</dl>
<blockquote>
<div style="white-space: pre-line;"><strong>1:</strong> if links in both direction should be generated
<strong>0:</strong> otherwise</div>
</blockquote>
<blockquote>
<dl>
<dt>parm[2]</dt>
<dd><p>random number seed (a positive integer)</p>
</dd>
<dt>parm[3]</dt>
<dd><p>number of nodes (the number of nodes generated might be slightly different to make the network a grid)</p>
</dd>
<dt>parm[4]</dt>
<dd><p>grid width</p>
</dd>
<dt>parm[5]</dt>
<dd><p>number of sources</p>
</dd>
<dt>parm[6]</dt>
<dd><p>number of sinks</p>
</dd>
<dt>parm[7]</dt>
<dd><p>average degree</p>
</dd>
<dt>parm[8]</dt>
<dd><p>total flow</p>
</dd>
<dt>parm[9]</dt>
<dd><p>distribution of arc costs:</p>
</dd>
</dl>
<blockquote>
<div style="white-space: pre-line;"><strong>1:</strong> uniform
<strong>2:</strong> exponential</div>
</blockquote>
<dl>
<dt>parm[10]</dt>
<dd><p>lower bound for arc cost (uniform), 100 lambda¸ (exponential)</p>
</dd>
<dt>parm[11]</dt>
<dd><p>upper bound for arc cost (uniform), not used (exponential)</p>
</dd>
<dt>parm[12]</dt>
<dd><p>distribution of arc capacities:</p>
</dd>
</dl>
<blockquote>
<div style="white-space: pre-line;"><strong>1:</strong> uniform
<strong>2:</strong> exponential</div>
</blockquote>
<dl>
<dt>parm[13]</dt>
<dd><p>lower bound for arc capacity (uniform), 100 lambda (exponential)</p>
</dd>
<dt>parm[14]</dt>
<dd><p>upper bound for arc capacity (uniform), not used (exponential)</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>0</strong> if the instance was successfully generated, nonzero otherwise</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::gridgen graph <span class="dv">0</span> <span class="dv">8</span> <span class="dv">16</span> (<span class="dv">1</span>, <span class="dv">123</span>, <span class="dv">20</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">300</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">30</span>);
<span class="dv">0</span></code></pre></div>
<h4 id="maximum-flow-problem">Maximum flow problem</h4>
<h5 id="read-maximum-cost-flow-problem-data-in-dimacs-format">Read maximum cost flow problem data in DIMACS format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::read_maxflow graph a_cap filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; </code></pre></div>
<h5 id="write-maximum-cost-flow-problem-data-in-dimacs-format">Write maximum cost flow problem data in DIMACS format</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::write_maxflow graph s t a_cap filename</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; </code></pre></div>
<h5 id="convert-maximum-flow-problem-to-lp">Convert maximum flow problem to LP</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::maxflow_lp lp graph names s t a_cap</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; </code></pre></div>
<h5 id="solve-maximum-flow-problem-with-ford-fulkerson-algorithm">Solve maximum flow problem with Ford-Fulkerson algorithm</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::maxflow_ffalg graph s t a_cap a_x v_cut</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; </code></pre></div>
<h5 id="goldfarbs-maximum-flow-problem-generator">Goldfarb’s maximum flow problem generator</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::rmfgen graph a_cap parameters</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>graph</dt>
<dd><p>pointer to the graph object</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; </code></pre></div>
<h3 id="miscellaneous-routines">Miscellaneous routines</h3>
<h4 id="library-environment-routines">Library environment routines</h4>
<h5 id="determine-library-version">Determine library version</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">`glp::version</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<p>none</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>GLPK library version</p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::version;
<span class="st">&quot;4.38&quot;</span></code></pre></div>
<h5 id="enabledisable-terminal-output">Enable/disable terminal output</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::term_out switch</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>switch</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::on: enable terminal output from GLPK routines :glp::off: disable terminal output from GLPK routines</p>
</blockquote>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::term_out glp:off;
()</code></pre></div>
<h5 id="enabledisable-the-terminal-hook-routine">Enable/disable the terminal hook routine</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::term_hook switch info</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>switch</dt>
<dd><p>one of the following:</p>
</dd>
</dl>
<blockquote>
<p>:glp::on: use the terminal callback function :glp::off: don’t use the terminal callback function</p>
</blockquote>
<dl>
<dt>info</dt>
<dd><p>pointer to a memory block which can be used for passing additional information to the terminal callback function</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::term_hook glp::on NULL;
()</code></pre></div>
<h5 id="get-memory-usage-information">Get memory usage information</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mem_usage</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<p>none</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p>tuple consisting of four numbers:</p>
<blockquote>
<ul>
<li><code>count</code> (int) - the number of currently allocated memory blocks</li>
<li><code>cpeak</code> (int) - the peak value of <code>count</code> reached since the initialization of the GLPK library environment</li>
<li><code>total</code> (bigint) - the total amount, in bytes, of currently allocated memory blocks</li>
<li><code>tpeak</code> (bigint) - the peak value of <code>total</code> reached since the initialization of the GLPK library envirionment</li>
</ul>
</blockquote>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mem_usage;
<span class="dv">7</span>,<span class="dv">84</span>,10172L,45304L</code></pre></div>
<h5 id="set-memory-usage-limit">Set memory usage limit</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::mem_limit limit</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<dl>
<dt>limit</dt>
<dd><p>memory limit in megabytes</p>
</dd>
</dl>
<p><strong>Returns</strong>:</p>
</blockquote>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp::mem_limit <span class="dv">200</span>;
()</code></pre></div>
<h5 id="free-glpk-library-environment">Free GLPK library environment</h5>
<p><strong>Synopsis</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">glp::free_env</code></pre></div>
<p><strong>Parameters</strong>:</p>
<blockquote>
<p>none</p>
</blockquote>
<p><strong>Returns</strong>:</p>
<blockquote>
<p><code>()</code></p>
</blockquote>
<p><strong>Example</strong>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; glp_free_env;
()</code></pre></div>
</body>
</html>
