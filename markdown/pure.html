<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="modern.css" type="text/css" />
</head>
<body>
<p><a name="doc-pure"></a></p>
<h1 id="the-pure-manual">The Pure Manual</h1>
<p>Version 0.66, March 06, 2017</p>
<p>Albert Gräf &lt;<a href="mailto:aggraef@gmail.com">aggraef@gmail.com</a>&gt;</p>
<p>Copyright (c) 2009-2017 by Albert Gräf. This document is available under the <a href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</a>. Also see the <a href="#copying">Copying</a> section for licensing information of the software.</p>
<p>This manual describes the Pure programming language and how to invoke the Pure interpreter program. To read the manual inside the interpreter, just type <code>help</code> at the command prompt. See the <a href="#online-help">Online Help</a> section for details.</p>
<p>There is a companion to this manual, the <a href="purelib.html">Pure Library Manual</a> which contains the description of the standard library operations. More information about Pure and the latest sources can be found under the following URLs:</p>
<ul>
<li>Pure website: <a href="http://purelang.bitbucket.org" class="uri">http://purelang.bitbucket.org</a></li>
<li>Pure mailing list: <a href="http://groups.google.com/group/pure-lang" class="uri">http://groups.google.com/group/pure-lang</a></li>
</ul>
<p><a name="installation"></a></p>
<p>Information about how to install Pure can be found in the document <a href="install.html">Installing Pure (and LLVM)</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>Pure is a functional programming language based on term rewriting. This means that all your programs are essentially just collections of symbolic equations which the interpreter uses to reduce expressions to their simplest (“normal”) form. This makes for a rather powerful and flexible programming model featuring dynamic typing and general polymorphism. In addition, Pure programs are compiled to efficient native code on the fly, using the <a href="#llvm">LLVM</a> compiler framework, so programs are executed reasonably fast and interfacing to C is very easy. If you have the necessary 3rd party compilers installed then you can even inline functions written in C and a number of other languages and call them just like any other Pure function. The ease with which you can interface to 3rd party software makes Pure useful for a wide range of applications from symbolic algebra and scientific programming to database, web and multimedia applications.</p>
<p>The Pure language is implemented by the <strong>Pure interpreter</strong> program. Just like other programming language interpreters, the Pure interpreter provides an interactive environment in which you can type definitions and expressions, which are executed as you type them at the interpreter’s command prompt. However, despite its name the Pure interpreter never really “interprets” any Pure code. Rather, it acts as a frontend to the <strong>Pure compiler</strong>, which takes care of incrementally compiling Pure code to native (machine) code. This has the benefit that the compiled code runs much faster than the usual kinds of “bytecode” that you find in traditional programming language interpreters.</p>
<p>You can use the interpreter interactively as a sophisticated kind of “desktop calculator” program. Simply run the program from the shell as follows:</p>
<pre class="sourceCode console"><code>$ pure

 __ \  |   |  __| _ \    Pure 0.66 (x86_64-unknown-linux-gnu)
 |   | |   | |    __/    Copyright (c) 2008-2017 by Albert Graef
 .__/ \__,_|_|  \___|    (Type &#39;help&#39; for help, &#39;help copying&#39;
_|                       for license information.)

Loaded prelude from /usr/lib/pure/prelude.pure.

&gt;</code></pre>
<p>The interpreter prints its sign-on message and leaves you at its “&gt;” command prompt, where you can start typing definitions and expressions to be evaluated:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">17</span>/<span class="dv">12</span>+<span class="dv">23</span>;
<span class="dv">24.4166666666667</span>
&gt; fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>Typing the <code>quit</code> command or the end-of-file character (<code>Ctrl-d</code> on Unix systems) at the beginning of the command line exits the interpreter and takes you back to the shell.</p>
<p>The interpreter can actually be invoked in a number of different ways. Instead of typing definitions and evaluating expressions in an interactive fashion as shown above, you can also put the same code in an (ASCII or UTF-8) text file called a <strong>Pure program</strong> or <strong>script</strong> which can then be executed by the interpreter in “batch mode”, or compiled to a standalone executable which can be run directly from the command line. As an aid for writing script files, a bunch of syntax highlighting files and programming modes for various popular text editors are included in the Pure sources.</p>
<p>More information about invoking the Pure interpreter can be found in the <a href="#invoking-pure">Invoking Pure</a> section below. This is followed by a description of the Pure language in <a href="#pure-overview">Pure Overview</a> and subsequent sections, including an extensive <a href="#examples">Examples</a> section which can serve as a mini-tutorial on Pure. The interactive facilities of the Pure interpreter are discussed in the <a href="#interactive-usage">Interactive Usage</a> section, while the <a href="#batch-compilation">Batch Compilation</a> section explains how to translate Pure programs to native executables and a number of other object file formats. The <a href="#caveats-and-notes">Caveats and Notes</a> section discusses useful tips and tricks, as well as various pitfalls and how to avoid them. The manual concludes with some authorship and licensing information and pointers to related software.</p>
<h3 id="further-reading">Further Reading</h3>
<p>This manual is not intended as a general introduction to functional programming, so at least some familiarity with this programming style is assumed. If Pure is your first functional language then you might want to look at the <a href="http://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> wikipedia article to see what it is all about and find pointers to current literature on the subject. In any case we hope that you’ll find Pure helpful in exploring functional programming, as it is fairly easy to learn but a very powerful language.</p>
<p>As already mentioned, Pure uses term rewriting as its underlying computational model, which goes well beyond functional programming in some ways. Term rewriting has long been used in computer algebra systems, and <a href="#michael-odonnell">Michael O’Donnell</a> pioneered its use as a programming language already in the 1980s. But until recently implementations have not really been efficient enough to be useful as general-purpose programming languages; Pure strives to change that. A good introduction to the theory of the term rewriting calculus and its applications is the book by <a href="#baader-and-nipkow">Baader and Nipkow</a>.</p>
<h3 id="typographical-conventions">Typographical Conventions</h3>
<p>Program examples are always set in typewriter font. Here’s how a typical code sample may look like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact(n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;</code></pre></div>
<p>These can either be saved to a file and then loaded into the interpreter, or you can also just type them directly in the interpreter. If some lines start with the interpreter prompt “&gt;”, this indicates an example interaction with the interpreter. Everything following the prompt (excluding the “&gt;” itself) is meant to be typed exactly as written. Lines lacking the “&gt;” prefix show results printed by the interpreter. Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact(n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>Similarly, lines starting with the “$” prompt indicate shell interactions. For instance,</p>
<pre class="sourceCode console"><code>$ pure</code></pre>
<p>indicates that you should type the command <code>pure</code> on your system’s command line.</p>
<p>The grammar notation in this manual uses an extended form of BNF (Backus-Naur form), which looks as follows:</p>
<pre class="sourceCode bnf"><code>expression : &quot;{&quot; expr_list (&quot;;&quot; expr_list)* [&quot;;&quot;] &quot;}&quot;
expr_list : expression (&#39;,&#39; expression)*</code></pre>
<p>Parentheses are used to group syntactical elements, while brackets denote optional elements. We also use the regular expression operators <code>*</code> and <code>+</code> to denote repetitions (as usual, <code>*</code> denotes zero or more, <code>+</code> one or more repetitions of the preceding element). Terminals (literal elements such as keywords and delimiters) are enclosed in double or single quotes.</p>
<p>These EBNF rules are used for both lexical and syntactical elements, but note that the former are concerned with entities formed from single characters and thus tokens are meant to be typed exactly as written, whereas the latter deal with larger syntactical structures where whitespace between tokens is generally insignificant.</p>
<h2 id="invoking-pure">Invoking Pure</h2>
<p>The Pure interpreter can be invoked from the shell in one of two different ways:</p>
<pre class="sourceCode console"><code>pure [options ...] [-x] script [args ...]
pure [options ...] [-b|-c|-i] [script ...] [-- args ...]</code></pre>
<p>Use <code>pure -h</code> to get help about the command line options. Just the <code>pure</code> command without any command line parameters invokes the interpreter in <strong>interactive mode</strong>, see <a href="#running-interactively">Running Interactively</a> below for details.</p>
<p>The first form above is used if the interpreter is invoked on exactly one script file, which is loaded and executed, after which the interpreter exits. Any arguments following the script name are <em>not</em> processed by the interpreter, but are passed to the executing script by means of the <code>argv</code> variable. This is also known as <strong>script mode</strong>, and is commonly used if a script is to be run as a standalone program. Script mode can also be indicated explicitly with the <code>-x</code> option, but this is optional unless you want to combine it with one of the <code>-b</code>, <code>-c</code> and <code>-i</code> options discussed below. If the <code>-x</code> option is present, it <em>must</em> be followed by the name of a script to be executed. Also note that in script mode, <em>all</em> interpreter options need to be specified before the script name; all remaining arguments (including options) are simply passed to the executing script.</p>
<p>The second form is used if there may be any number of scripts which are to be executed in <strong>batch mode</strong> (<code>-b</code>, <code>-c</code>) or <strong>interactive mode</strong> (<code>-i</code>), respectively. In this case <em>all</em> options on the command line will be processed by the interpreter, up to the <code>--</code> option (if any), which stops option processing and indicates that the remaining arguments should be passed in the <code>argv</code> variable. Any non-option arguments (before the <code>--</code> option, if any) are interpreted as scripts which should be loaded by the interpreter. If no scripts are specified, or if the <code>-i</code> option is present, the interpreter starts in interactive mode (after loading the given scripts, if any). Otherwise, if one of the <code>-b</code> and <code>-c</code> options is specified, the given scripts are run in batch mode, after which the interpreter exits. (In the case of <code>-c</code>, the interpreter then also dumps the program as a native executable, performing <strong>batch compilation</strong>, see <a href="#compiling-scripts">Compiling Scripts</a> below.)</p>
<p>Batch mode is also entered if the interpreter is invoked with one of the <code>--ctags</code> and <code>--etags</code> options. However, in this case the given scripts are not executed at all, but only parsed in order to produce a vi or emacs tags file, see <a href="#tagging-scripts">Tagging Scripts</a> below.</p>
<p>Here are some common ways to invoke the interpreter:</p>
<dl>
<dt><code>pure</code></dt>
<dd><p>Runs the interpreter interactively, without any script. Only the prelude gets loaded.</p>
</dd>
<dt><code>pure -g</code></dt>
<dd><p>Runs the interpreter interactively, with debugging support.</p>
</dd>
<dt><code>pure -b script ...</code></dt>
<dd><p>Runs the given scripts in batch mode.</p>
</dd>
<dt><code>pure -i script ...</code></dt>
<dd><p>Runs the given scripts in batch mode as above, but then enters the interactive command loop. (Add <code>-g</code> to also get debugging support, and <code>-q</code> to suppress the sign-on message.)</p>
</dd>
<dt><code>pure script [arg ...]</code></dt>
<dd><p>Runs the given script with the given parameters. The script name and command line arguments are available in the global <code>argv</code> variable.</p>
</dd>
<dt><code>pure -c script [-o prog]</code></dt>
<dd><p>Batch compilation: Runs the given script, compiling it to a native executable <code>prog</code> (a.out by default).</p>
</dd>
<dt><code>pure --etags script ... [-T TAGS]</code></dt>
<dd><p>Parses the given scripts and produces an emacs tags file. (Use <code>--ctags</code> to create a vi tags file instead. In either case, the actual name of the tags file can be set with the <code>-T</code> option.)</p>
</dd>
</dl>
<p>The following commands provide helpful information about the interpreter, after which the interpreter exits immediately:</p>
<dl>
<dt><code>pure --help</code></dt>
<dd><p>Print a short help message describing the command line syntax and available options. This can also be abbreviated as <code>pure -h</code>.</p>
</dd>
<dt><code>pure --version</code></dt>
<dd><p>Print version information.</p>
</dd>
</dl>
<p>Depending on your local setup, there may be additional ways to run the Pure interpreter. In particular, if you have Emacs Pure mode installed, then you can just open a script in Emacs and run it with the <code>C-c C-k</code> keyboard command. For Emacs aficionados, this is probably the most convenient way to execute a Pure script interactively in the interpreter. Pure mode actually turns Emacs into a full IDE (integrated development environment) for Pure, which offers a lot of convenient features such as syntax highlighting, automatic indentation, online help and different ways to interact with the Pure interpreter.</p>
<h3 id="options">Options</h3>
<p>The interpreter accepts various options which are described in more detail below.</p>
<dl>
<dt><a name="cmdoption-pure-b"></a><code>-b</code></dt>
<dd>Batch mode (execute the given scripts and exit).
</dd>
<dt><a name="cmdoption-pure-c"></a><code>-c</code></dt>
<dd>Batch compilation (compile the given scripts to a native binary).
</dd>
<dt><a name="cmdoption-pure--ctags"></a><code>--ctags</code>, <a name="cmdoption-pure--etags"></a><code>--etags</code></dt>
<dd>Create a tags file in ctags (vi) or etags (emacs) format.
</dd>
<dt><a name="cmdoption-pure--disable"></a><code>--disable optname</code></dt>
<dd>Disable source option (conditional compilation).
</dd>
<dt><a name="cmdoption-pure--eager-jit"></a><code>--eager-jit</code></dt>
<dd>Enable eager JIT compilation. This requires LLVM 2.7 or later, otherwise this flag will be ignored.
</dd>
<dt><a name="cmdoption-pure--enable"></a><code>--enable optname</code></dt>
<dd>Enable source option (conditional compilation).
</dd>
<dt><a name="cmdoption-pure--escape"></a><code>--escape char</code></dt>
<dd>Interactive commands are prefixed with the specified character. Permitted prefixes are: <code>!$%&amp;*,:&lt;&gt;@\|</code>.
</dd>
<dt><a name="cmdoption-pure-fPIC"></a><code>-fPIC</code>, <a name="cmdoption-pure-fpic"></a><code>-fpic</code></dt>
<dd>Create position-independent code (batch compilation).
</dd>
<dt><a name="cmdoption-pure-g"></a><code>-g</code></dt>
<dd>Enable symbolic debugging.
</dd>
<dt><a name="cmdoption-pure-h"></a><code>-h</code>, <a name="cmdoption-pure--help"></a><code>--help</code></dt>
<dd>Print help message and exit.
</dd>
<dt><a name="cmdoption-pure-i"></a><code>-i</code></dt>
<dd>Interactive mode (read commands from stdin after sourcing the given scripts, if any).
</dd>
<dt><a name="cmdoption-pure-I"></a><code>-I directory</code></dt>
<dd>Add a directory to be searched for included source scripts.
</dd>
<dt><a name="cmdoption-pure-L"></a><code>-L directory</code></dt>
<dd>Add a directory to be searched for dynamic libraries.
</dd>
<dt><a name="cmdoption-pure-l"></a><code>-l libname</code></dt>
<dd>Library to be linked in batch compilation.
</dd>
<dt><a name="cmdoption-pure-mopt"></a><code>-mopt=val</code></dt>
<dd>Add llc machine options in batch compilation.
</dd>
<dt><a name="cmdoption-pure--main"></a><code>--main name</code></dt>
<dd>Name of main entry point in batch compilation.
</dd>
<dt><a name="cmdoption-pure--noediting"></a><code>--noediting</code></dt>
<dd>Disable command-line editing.
</dd>
<dt><a name="cmdoption-pure-n"></a><code>-n</code>, <a name="cmdoption-pure--noprelude"></a><code>--noprelude</code></dt>
<dd>Do not load the prelude.
</dd>
<dt><a name="cmdoption-pure--norc"></a><code>--norc</code></dt>
<dd>Do not run the interactive startup files.
</dd>
<dt><a name="cmdoption-pure-o"></a><code>-o filename</code></dt>
<dd>Output filename for batch compilation.
</dd>
<dt><a name="cmdoption-pure-q"></a><code>-q</code></dt>
<dd>Quiet startup (suppresses sign-on message in interactive mode).
</dd>
<dt><a name="cmdoption-pure-T"></a><code>-T filename</code></dt>
<dd>Tags file to be written by <a href="#cmdoption-pure--ctags"><code>--ctags</code></a> or <a href="#cmdoption-pure--etags"><code>--etags</code></a>.
</dd>
<dt><a name="cmdoption-pure--texmacs"></a><code>--texmacs</code></dt>
<dd>Run Pure inside <a href="#texmacs">TeXmacs</a>.
</dd>
<dt><a name="cmdoption-pure-u"></a><code>-u</code></dt>
<dd>Do not strip unused functions in batch compilation.
</dd>
<dt><a name="cmdoption-pure-v"></a><code>-v[level]</code></dt>
<dd>Set verbosity level.
</dd>
<dt><a name="cmdoption-pure--version"></a><code>--version</code></dt>
<dd>Print version information and exit.
</dd>
<dt><a name="cmdoption-pure-w"></a><code>-w</code></dt>
<dd>Enable compiler warnings.
</dd>
<dt><a name="cmdoption-pure-x"></a><code>-x</code></dt>
<dd>Script mode (execute a script with the given command line arguments).
</dd>
<dt><a name="cmdoption-pure--"></a><code>--</code></dt>
<dd>Stop option processing and pass the remaining command line arguments in the <code>argv</code> variable.
</dd>
</dl>
<!-- -->
<p>Besides these, the interpreter also understands a number of other command line switches for setting various compilation options; please see <a href="#compilation-options">Compilation Options</a> below for details.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> Option parsing follows the usual (Unix) conventions, but is somewhat more rigid than the GNU getopt conventions. In particular, it is <em>not</em> possible to combine short options, and there are no abbreviations for “long” options. Mixing options and other command line parameters is generally possible, but note that all option processing stops right after <code>-x</code> and <code>--</code> (or the first non-option parameter in script mode), passing the remaining parameters to the executing script in the Pure <code>argv</code> variable.</p>
<p>As usual, if an option takes a required argument, the argument may be written either as a separate command line parameter immediately following the option (as in <code>-I</code> <em>directory</em> or <code>--enable</code> <em>optname</em>), or directly after the option (<code>-I</code><em>directory</em> or <code>--enable=</code><em>optname</em>; note the equals sign in the case of a long option). Options with optional arguments work in the same fashion, but in this case the argument, if present, <em>must</em> be written directly behind the option.</p>
</blockquote>
<hr />
<h3 id="overview-of-operation">Overview of Operation</h3>
<p>If any source scripts are specified on the command line, they are loaded and executed, after which the interpreter exits. Otherwise the interpreter enters the interactive read-eval-print loop, see <a href="#running-interactively">Running Interactively</a> below. You can also use the <a href="#cmdoption-pure-i"><code>-i</code></a> option to enter the interactive loop (continue reading from stdin) even after processing some source scripts.</p>
<p>Options and source files are processed in the order in which they are given on the command line. Processing of options and source files ends when either the <a href="#cmdoption-pure--"><code>--</code></a> or the <a href="#cmdoption-pure-x"><code>-x</code></a> option is encountered, or after the first script (non-option) argument in <strong>script mode</strong> (i.e., if none of the options <a href="#cmdoption-pure-b"><code>-b</code></a>, <a href="#cmdoption-pure-i"><code>-i</code></a>, <a href="#cmdoption-pure--ctags"><code>--ctags</code></a> and <a href="#cmdoption-pure--etags"><code>--etags</code></a> is present). In either case, any remaining parameters are passed to the executing script by means of the global <a href="#argc"><code>argc</code></a> and <a href="#argv"><code>argv</code></a> variables, denoting the number of arguments and the list of the actual parameter strings, respectively. In script mode this also includes the script name as <code>argv!0</code>.</p>
<p>Script mode is useful, in particular, to turn Pure scripts into executable programs by including a “shebang” like the following as the first line in your main script. (This trick only works with Unix shells, though.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#!/usr/local/bin/pure</code></pre></div>
<p>The following variables are always predefined by the interpreter:</p>
<dl>
<dt><a name="argc"></a><em>variable</em> <code>argc</code>, <a name="argv"></a><code>argv</code></dt>
<dd>The number of extra command line arguments and the arguments themselves as a list of strings; see above. These are useful if a script is usually run non-interactively and takes its input from the command line.
</dd>
<dt><a name="compiling"></a><em>variable</em> <code>compiling</code></dt>
<dd>A flag indicating whether the program is executed in a batch compilation (<a href="#cmdoption-pure-c"><code>-c</code></a> option), see <a href="#compiling-scripts">Compiling Scripts</a> below.
</dd>
<dt><a name="version"></a><em>variable</em> <code>version</code>, <a name="sysinfo"></a><code>sysinfo</code></dt>
<dd>The version string of the Pure interpreter and a string identifying the host system. These are useful if parts of your script depend on the particular version of the interpreter and the system it runs on. (An alternative way to deal with version and system dependencies is to use conditional compilation; see <a href="#conditional-compilation">Conditional Compilation</a>.)
</dd>
</dl>
<!-- -->
<p>If available, the prelude script prelude.pure is loaded by the interpreter prior to any other definitions, unless the <a href="#cmdoption-pure-n"><code>-n</code></a> or <a href="#cmdoption-pure--noprelude"><code>--noprelude</code></a> option is specified. The prelude is searched for in the directory specified with the <a href="#envvar-PURELIB"><code>PURELIB</code></a> environment variable. If the <a href="#envvar-PURELIB"><code>PURELIB</code></a> variable is not set, a system-specific default is used. Relative pathnames of other source scripts specified on the command line are interpreted relative to the current working directory. In addition, the executed program may load other scripts and libraries via a <a href="#using"><code>using</code></a> declaration in the source, which are searched for in a number of locations, including the directories named with the <a href="#cmdoption-pure-I"><code>-I</code></a> and <a href="#cmdoption-pure-L"><code>-L</code></a> options; see the <a href="#declarations">Declarations</a> and <a href="#c-interface">C Interface</a> sections for details.</p>
<h3 id="compiling-scripts">Compiling Scripts</h3>
<p>The interpreter compiles scripts, as well as definitions that you enter interactively, automatically. This is done in an incremental fashion, as the code is needed, and is therefore known as JIT (<strong>just in time</strong>) compilation. Thus the interpreter never really “interprets” the source program or some intermediate representation, it just acts as a frontend to the compiler, taking care of compiling source code to native machine code before it gets executed.</p>
<p>Pure’s LLVM backend does “lazy JIT compilation” by default, meaning that each function (global or local) is compiled no sooner than it is run for the first time. With the <a href="#cmdoption-pure--eager-jit"><code>--eager-jit</code></a> option, however, it will also compile all other (global or local) functions that may be called by the compiled function. (The <a href="#envvar-PURE_EAGER_JIT"><code>PURE_EAGER_JIT</code></a> environment variable, when set to any value, has the same effect, so that you do not have to specify the <a href="#cmdoption-pure--eager-jit"><code>--eager-jit</code></a> option each time you run the interpreter.) Eager JIT compilation may be more efficient in some cases (since bigger chunks of compilation work can be done in one go) and less efficient in others (e.g., eager JITing may compile large chunks of code which aren’t actually called later, except in rare circumstances).</p>
<p>Note that the eager JIT mode is only available with LLVM 2.7 or later; otherwise this option will be ignored.</p>
<p>It is also possible to compile your scripts to native code beforehand, using the <a href="#cmdoption-pure-c"><code>-c</code></a> batch compilation option. This option forces the interpreter to batch mode (unless <a href="#cmdoption-pure-i"><code>-i</code></a> is specified as well, which overrides <a href="#cmdoption-pure-c"><code>-c</code></a>). Any scripts specified on the command line are then executed as usual, but after execution the interpreter takes a snapshot of the program and compiles it to one of several supported output formats, LLVM assembler (.ll) or bitcode (.bc), native assembler (.s) or object (.o), or a native executable, depending on the output filename specified with <a href="#cmdoption-pure-o"><code>-o</code></a>. If the output filename ends in the .ll extension, an LLVM assembler file is created which can then be processed with the LLVM toolchain. If the output filename is just ‘-’, the assembler file is written to standard output, which is useful if you want to pass the generated code to the LLVM tools in a pipeline. If the output filename ends in the .bc extension, an LLVM bitcode file is created instead.</p>
<p>The .ll and .bc formats are supported natively by the Pure interpreter, no external tools are required to generate these. If the target is an .s, .o or executable file, the Pure interpreter creates a temporary bitcode file on which it invokes the LLVM tools <strong>opt</strong> and <strong>llc</strong> to create a native assembler or object file, and then uses the C/C++ compiler to link the resulting program (if requested). You can also specify additional libraries to be linked into the executable with the <a href="#cmdoption-pure-l"><code>-l</code></a> option. If the output filename is omitted, it defaults to a.out (a.exe on Windows).</p>
<p>The C/C++ compiler invoked by the batch compiler is normally <strong>gcc</strong> by default, but you can change this with the <a href="#envvar-CC"><code>CC</code></a> and <a href="#envvar-CXX"><code>CXX</code></a> environment variables. The LLVM tools <strong>opt</strong> and <strong>llc</strong> are usually located on the <a href="#envvar-PATH"><code>PATH</code></a> or in a system-specific directory determined at installation time. It is also possible to use custom versions of these programs with the batch compiler, by placing them into the Pure library directory, as specified at installation time or by the <a href="#envvar-PURELIB"><code>PURELIB</code></a> environment variable. (Note that this lets you use the batch compiler on systems which don’t have the LLVM toolchain installed. In fact, you could even deploy a stand-alone version of the interpreter together with the requisite LLVM tools on systems which don’t have LLVM installed at all, by linking both the Pure runtime and the <strong>opt</strong> and <strong>llc</strong> programs statically against LLVM.)</p>
<p>The <a href="#cmdoption-pure-c"><code>-c</code></a> option provides a convenient way to quickly turn a Pure script into a standalone executable which can be invoked directly from the shell. One advantage of compiling your script is that this eliminates the JIT compilation time and thus considerably reduces the startup time of the program. Another reason to prefer a standalone executable is that it lets you deploy the program on systems without a full Pure installation (usually only the runtime library is required on the target system). On the other hand, compiled scripts also have some limitations, mostly concerning the use of the built-in <a href="purelib.html#eval"><code>eval</code></a> function. Please see the <a href="#batch-compilation">Batch Compilation</a> section for details.</p>
<p>The <code>-v64</code> (or <code>-v0100</code>) verbosity option can be used to have the interpreter print the commands it executes during compilation, see <a href="#verbosity-and-debugging-options">Verbosity and Debugging Options</a> below. When creating an object file, this also prints the suggested linker command (including all the dynamic modules loaded by the script, which also have to be linked in to create a working executable), to which you only have to add the options describing the desired output file.</p>
<h3 id="tagging-scripts">Tagging Scripts</h3>
<p>Pure programs often have declarations and definitions of global symbols scattered out over many different source files. The <a href="#cmdoption-pure--ctags"><code>--ctags</code></a> and <a href="#cmdoption-pure--etags"><code>--etags</code></a> options let you create a <a href="http://en.wikipedia.org/wiki/Ctags">tags</a> file which allows you to quickly locate these items in text editors such as <strong>vi</strong> and <strong>emacs</strong> which support this feature.</p>
<p>If <a href="#cmdoption-pure--ctags"><code>--ctags</code></a> or <a href="#cmdoption-pure--etags"><code>--etags</code></a> is specified, the interpreter enters a special variation of batch mode in which it only parses source files without executing them and collects information about the locations of global symbol declarations and definitions. The collected information is then written to a tags file in the ctags or etags format used by <strong>vi</strong> and <strong>emacs</strong>, respectively. The desired name of the tags file can be specified with the <a href="#cmdoption-pure-T"><code>-T</code></a> option; it defaults to tags for <a href="#cmdoption-pure--ctags"><code>--ctags</code></a> and TAGS for <a href="#cmdoption-pure--etags"><code>--etags</code></a> (which matches the default tags file names used by <strong>vi</strong> and <strong>emacs</strong>, respectively).</p>
<p>The tags file contains information about the global constant, variable, macro, function and operator symbols of all scripts specified on the command line, as well as the prelude and other scripts included via a <a href="#using"><code>using</code></a> clause. Tagged scripts which are located in the same directory as the tags file (or, recursively, in one of its subdirectories) are specified using relative pathnames, while scripts outside this hierarchy (such as included scripts from the standard library) are denoted with absolute pathnames. This scheme makes it possible to move an entire directory together with its tags file and have the tags information still work in the new location.</p>
<h3 id="running-interactively">Running Interactively</h3>
<p>If the interpreter runs in interactive mode, it repeatedly prompts you for input (which may be any legal Pure code or some special interpreter commands provided for interactive usage), and prints computed results. This is also known as the <strong>read-eval-print</strong> loop and is described in much more detail in the <a href="#interactive-usage">Interactive Usage</a> section. To exit the interpreter, just type the <code>quit</code> command or the end-of-file character (<code>Ctrl-d</code> on Unix) at the beginning of the command line.</p>
<p>The interpreter may also source a few additional interactive startup files immediately before entering the interactive loop, unless the <a href="#cmdoption-pure--norc"><code>--norc</code></a> option is specified. First .purerc in the user’s home directory is read, then .purerc in the current working directory. These are ordinary Pure scripts which can be used to provide additional definitions for interactive usage. Finally, a .pure file in the current directory (usually containing a dump from a previous interactive session) is loaded if it is present.</p>
<p>When the interpreter is in interactive mode and reads from a tty, unless the <a href="#cmdoption-pure--noediting"><code>--noediting</code></a> option is specified, commands are usually read using <strong>readline</strong> or some compatible replacement, providing completion for all commands listed under <a href="#interactive-usage">Interactive Usage</a>, as well as for symbols defined in the running program. When exiting the interpreter, the command history is stored in ~/.pure_history, from where it is restored the next time you run the interpreter.</p>
<p>The interpreter also provides a simple source level debugger when run in interactive mode, see <a href="#debugging">Debugging</a> for details. To enable the debugger, you need to specify the <a href="#cmdoption-pure-g"><code>-g</code></a> option when invoking the interpreter. This option causes your script to run <em>much</em> slower, so you should only use this option if you want to run the debugger.</p>
<h3 id="verbosity-and-debugging-options">Verbosity and Debugging Options</h3>
<p>The <a href="#cmdoption-pure-v"><code>-v</code></a> option is useful for debugging the interpreter, or if you are interested in the code your program gets compiled to. The level argument is optional; it defaults to 1. Seven different levels are implemented at this time. Only the first two levels will be useful for the average Pure programmer; the remaining levels are mostly intended for maintenance purposes.</p>
<dl>
<dt>1 (0x1, 001)</dt>
<dd><p>denotes echoing of parsed definitions and expressions.</p>
</dd>
<dt>2 (0x2, 002)</dt>
<dd><p>adds special annotations concerning local bindings (de Bruijn indices, subterm paths; this can be helpful to debug tricky variable binding issues).</p>
</dd>
<dt>4 (0x4, 004)</dt>
<dd><p>adds descriptions of the matching automata for the left-hand sides of equations (you probably want to see this only when working on the guts of the interpreter).</p>
</dd>
<dt>8 (0x8, 010)</dt>
<dd><p>dumps the “real” output code (LLVM assembler, which is as close to the native machine code for your program as it gets; you definitely don’t want to see this unless you have to inspect the generated code for bugs or performance issues).</p>
</dd>
<dt>16 (0x10, 020)</dt>
<dd><p>adds debugging messages from the bison(1) parser; useful for debugging the parser.</p>
</dd>
<dt>32 (0x20, 040)</dt>
<dd><p>adds debugging messages from the flex(1) lexer; useful for debugging the lexer.</p>
</dd>
<dt>64 (0x40, 0100)</dt>
<dd><p>turns on verbose batch compilation; this is useful if you want to see exactly which commands get executed during batch compilation (<a href="#cmdoption-pure-c"><code>-c</code></a>).</p>
</dd>
</dl>
<p>These values can be or’ed together, and, for convenience, can be specified in either decimal, hexadecimal or octal. Thus 0xff or 0777 always gives you full debugging output (which isn’t likely to be used by anyone but the Pure developers). Some useful flag combinations for experts are (in octal) 007 (echo definitions along with de Bruijn indices and matching automata), 011 (definitions and assembler code), 021 (parser debugging output along with parsed definitions) and 0100 (verbose batch compilation).</p>
<p>Note that the <a href="#cmdoption-pure-v"><code>-v</code></a> option is only applied after the prelude has been loaded. If you want to debug the prelude, use the <a href="#cmdoption-pure-n"><code>-n</code></a> option and specify the prelude.pure file explicitly on the command line. Verbose output is also suppressed for modules imported through a <a href="#using"><code>using</code></a> clause. As a remedy, you can use the interactive <code>show</code> command (see the <a href="#interactive-usage">Interactive Usage</a> section) to list definitions along with additional debugging information.</p>
<h3 id="compilation-options">Compilation Options</h3>
<p>Besides the options listed above, the interpreter also understands some additional command line switches and corresponding environment variables to control various compilation options.</p>
<h4 id="code-generation-options">Code Generation Options</h4>
<p>These options take the form <code>--opt</code> and <code>--noopt</code>, respectively, where <code>opt</code> denotes the option name (see below for a list of supported options). By default, these options are all enabled; <code>--noopt</code> disables the option, <code>--opt</code> reenables it. In addition, for each option <code>opt</code> there is also a corresponding environment variable <code>PURE_NOOPT</code> (with the option name in uppercase) which, when set, disables the option by default. (Setting this variable to any value will do, the interpreter only checks whether the variable exists in the environment.)</p>
<p>For instance, the <code>checks</code> option controls stack and signal checks. Thus <code>--nochecks</code> on the command line disables the option, and setting the <code>PURE_NOCHECKS</code> environment variable makes this the default, in which case you can use <code>--checks</code> on the command line to reenable the option.</p>
<p>Each code generation option can also be used as a <strong>pragma</strong> (compiler directive) in source code so that you can control it on a per-rule basis. The pragma must be on a line by itself, starting in column 1, and takes the following form (using <code>--nochecks</code> as an example):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --nochecks <span class="co">// line-oriented comment may go here</span></code></pre></div>
<p>Currently, the following code generation options are recognized:</p>
<dl>
<dt><a name="cmdoption-pure--checks"></a><code>--checks</code>, <a name="cmdoption-pure--nochecks"></a><code>--nochecks</code></dt>
<dd>Enable or disable various extra stack and signal checks. By default, the interpreter checks for stack overflows and pending signals on entry to every function, see <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> and <a href="#handling-of-asynchronous-signals">Handling of Asynchronous Signals</a> for details. This is needed to catch these conditions in a reliable way, so we recommend to leave this enabled. However, these checks also make programs run a little slower (typically some 5%, YMMV). If performance is critical then you can disable the checks with the <a href="#cmdoption-pure--nochecks"><code>--nochecks</code></a> option. (Even then, a minimal amount of checking will be done, usually on entry to every global function.)
</dd>
<dt><a name="cmdoption-pure--const"></a><code>--const</code>, <a name="cmdoption-pure--noconst"></a><code>--noconst</code></dt>
<dd>Enable or disable the precomputing of constant values in batch compilation (cf. <a href="#compiling-scripts">Compiling Scripts</a>). If enabled (which is the default), the values of constants in <a href="#const"><code>const</code></a> definitions are precomputed at compile time (if possible) and then stored in the generated executable. This usually yields faster startup times but bigger executables. You can disable this option with <a href="#cmdoption-pure--noconst"><code>--noconst</code></a> to get smaller executables at the expense of slower startup times. Please see the <a href="#batch-compilation">Batch Compilation</a> section for an example.
</dd>
<dt><a name="cmdoption-pure--fold"></a><code>--fold</code>, <a name="cmdoption-pure--nofold"></a><code>--nofold</code></dt>
<dd><p>Enable or disable constant folding in the compiler frontend. This means that constant expressions involving int and double values and the usual arithmetic and logical operations on these are precomputed at compile time. (This is mostly for cosmetic purposes; the LLVM backend will perform this optimization anyway when generating machine code.) For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = <span class="dv">2</span>*<span class="dv">3</span>*x;
&gt; show foo
foo x = <span class="dv">6</span>*x;</code></pre></div>
<p>Disabling constant folding in the frontend causes constant expressions to be shown as you entered them:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --nofold
&gt; bar x = <span class="dv">2</span>*<span class="dv">3</span>*x;
&gt; show bar
bar x = <span class="dv">2</span>*<span class="dv">3</span>*x;</code></pre></div>
<p>The same option also determines the handling of type aliases at compile time, see <a href="#type-rules">Type Rules</a>.</p>
</dd>
<dt><a name="cmdoption-pure--symbolic"></a><code>--symbolic</code>, <a name="cmdoption-pure--nosymbolic"></a><code>--nosymbolic</code></dt>
<dd><p>Enable or disable <strong>symbolic mode</strong>. Pure’s default behaviour is to evaluate function applications in a symbolic fashion using the equations (rewriting rules) supplied by the programmer, cf. <a href="#definitions-and-expression-evaluation">Definitions and Expression Evaluation</a>. This means that it is <em>not</em> normally an error if there is no equation which applies to the given function application to be evaluated; rather, the unevaluated function becomes a “constructor symbol” which is applied to the provided arguments to form a literal (“normal form”) term which stands for itself. E.g., here’s what you get if you try to add an (undefined) symbol and a number:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; a+<span class="dv">1</span>;
a+<span class="dv">1</span></code></pre></div>
<p>The <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> option changes this behaviour so that if a global function has <em>any</em> defining equations, then an attempt to invoke the function on a combination of arguments for which there is no applicable equation, raises an exception. So if the interpreter is invoked with <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> then you’ll see this instead:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; a+<span class="dv">1</span>;
&lt;stdin&gt;, line <span class="dv">1</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;a+<span class="dv">1</span>&#39;</code></pre></div>
<p>This behaviour is more in line with traditional languages where it is an error if a “defined function” cannot be evaluated in case of argument mismatch. It makes it easier to spot argument mismatch errors which might well go unnoticed if a program is executed in Pure’s default symbolic mode. However, it also makes it impossible to perform symbolic expression evaluations which is one of the key features of term rewriting as a programming language.</p>
<p>Much of Pure’s library and many programming examples assume Pure’s default mode of symbolic evaluation, so that it is generally not advisable to run the interpreter with a global <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> option, except maybe for debugging purposes. More commonly <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> is used as a pragma in source code where it only applies to a specific collection of function definitions. In addition, there’s a <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragma which enables you to mark individual functions as “defined functions”, see below.</p>
</dd>
<dt><a name="cmdoption-pure--tc"></a><code>--tc</code>, <a name="cmdoption-pure--notc"></a><code>--notc</code></dt>
<dd>Enable or disable tail call optimization (TCO). TCO is needed to make tail-recursive functions execute in constant stack space, so we recommend to leave this enabled. However, at the time of this writing LLVM’s TCO support is still bug-ridden on some platforms, so the <a href="#cmdoption-pure--notc"><code>--notc</code></a> option allows you to disable it. (Note that TCO can also be disabled when compiling the Pure interpreter, in which case these options have no effect; see the <a href="install.html">installation instructions</a> for details.)
</dd>
</dl>
<!-- -->
<hr />
<blockquote>
<p><strong>Note:</strong> All of the options above also have a corresponding “option symbol” so that they can be queried and set using the facilities described under <a href="#conditional-compilation">Conditional Compilation</a> below. (The symbol is just the name of the option, e.g., <code>checks</code> for the <a href="#cmdoption-pure--checks"><code>--checks</code></a>, <a href="#cmdoption-pure--nochecks"><code>--nochecks</code></a> option and pragma.)</p>
</blockquote>
<hr />
<p>Besides these, there are the following special pragmas affecting the evaluation of some global function or macro, which is specified in the pragma. These pragmas can only be used in source code, they cannot be controlled using command line options or environment variables. Note that the given symbol <code>fun</code> may in fact be an arbitrary symbol (not just an identifier), so that these pragmas can also be applied to special operator symbols (cf. <a href="#lexical-matters">Lexical Matters</a>). Also note that each of these pragmas also implicitly declares the symbol, so if a symbol needs any special attributes then it must be declared before any pragmas involving it (cf. <a href="#symbol-declarations">Symbol Declarations</a>).</p>
<dl>
<dt><a name="cmdoption-pure-pragma--eager"></a><code>--eager fun</code></dt>
<dd>Instruct the interpreter to JIT-compile the given function eagerly. This means that native code will be created for the function, as well as all other (global or local) functions that may be called by the compiled function, as soon as the function gets recompiled. This avoids the hiccups you get when a function is compiled on the fly if it is run for the first time, which is particularly useful for functions which are to be run in realtime (typically in multimedia applications). Please note that, in difference to the <a href="#cmdoption-pure-pragma--eager-jit"><code>--eager-jit</code></a> option, this feature is available for all LLVM versions (it doesn’t require LLVM 2.7 or later).
</dd>
<dt><a name="cmdoption-pure-pragma--required"></a><code>--required fun</code></dt>
<dd>Inform the batch compiler (cf. <a href="#compiling-scripts">Compiling Scripts</a>) that the given function symbol <code>fun</code> should never be stripped from the program. This is useful, e.g., if a function is never called explicitly but only through <a href="purelib.html#eval"><code>eval</code></a>. Adding a <a href="#cmdoption-pure-pragma--required"><code>--required</code></a> pragma for the function then makes sure that the function is always linked into the program. Please see the <a href="#batch-compilation">Batch Compilation</a> section for an example.
</dd>
<dt><a name="cmdoption-pure-pragma--defined"></a><code>--defined fun</code>, <a name="cmdoption-pure-pragma--nodefined"></a><code>--nodefined fun</code></dt>
<dd><p>These pragmas change the behaviour of global functions defined in a Pure program. The <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragma marks the given function or operator symbol as a “defined function” so that an exception is raised if the function is applied to a combination of arguments for which there is no applicable equation. This works similarly to the <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> pragma (see above), but allows you to mark individual functions as “defined”. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --defined +
&gt; a+<span class="dv">1</span>;
&lt;stdin&gt;, line <span class="dv">2</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;a+<span class="dv">1</span>&#39;</code></pre></div>
<p>The <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> status of a function can be changed at any time (causing the function to be recompiled on the fly if necessary), and the <a href="#cmdoption-pure-pragma--nodefined"><code>--nodefined</code></a> pragma restores the default behaviour of returning a normal form upon failure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --nodefined +
&gt; a+<span class="dv">1</span>;
a+<span class="dv">1</span></code></pre></div>
<p>More information and examples for common uses of the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> and <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> pragmas can be found under <a href="#defined-functions">Defined Functions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section.</p>
</dd>
<dt><a name="cmdoption-pure-pragma--quoteargs"></a><code>--quoteargs fun</code></dt>
<dd>This pragma tells the macro evaluator (cf. <a href="#macros">Macros</a>) that the given macro should receive its arguments unevaluated, i.e., in quoted form. This is described in more detail in the <a href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a> section.
</dd>
</dl>
<!-- -->
<h4 id="conditional-compilation">Conditional Compilation</h4>
<p>As of version 0.49, Pure also provides a rudimentary facility for denoting optional and alternative code paths. This is supposed to cover the most common cases where conditional compilation is needed. (For more elaborate needs you can always use real Pure code which enables you to configure your program at runtime using, e.g., the <a href="purelib.html#eval"><code>eval</code></a> function.)</p>
<p>Pure’s conditional compilation pragmas are based on the notion of user-defined symbols (which can be really any text that does not contain whitespace or any of the shell wildcard characters <code>*?[]</code>) called compilation <strong>options</strong>. By default, all options are <em>undefined</em> and <em>enabled</em>. An option becomes <em>defined</em> as soon as it is set explicitly, either with an environment variable or one of the <a href="#cmdoption-pure-pragma--enable"><code>--enable</code></a> and <a href="#cmdoption-pure-pragma--disable"><code>--disable</code></a> pragmas, see below.</p>
<p>You can define the value of an option by setting a corresponding environment variable <code>PURE_OPTION_OPT</code>, where <code>OPT</code> is the option symbol in uppercase. The value of the environment variable should either be <code>0</code> (disabled) or <code>1</code> (enabled).</p>
<p>Options can be enabled and disabled in Pure scripts with the following pragmas, which are also available as command line options when invoking the Pure interpreter:</p>
<dl>
<dt><a name="cmdoption-pure-pragma--enable"></a><code>--enable option</code>, <a name="cmdoption-pure-pragma--disable"></a><code>--disable option</code></dt>
<dd>Enable or disable the given option, respectively. Note that an option specified in the environment is overridden by a value specified with these options on the command line, which in turn is overridden by a corresponding pragma in source code.
</dd>
</dl>
<!-- -->
<p>The actual conditional compilation pragmas work in pretty much the same fashion as the C preprocessor directives <code>#if</code>, <code>#ifdef</code> etc. (except that, as already mentioned, an option is always <em>enabled</em> if it is undefined).</p>
<dl>
<dt><a name="cmdoption-pure-pragma--ifdef"></a><code>--ifdef option</code>, <a name="cmdoption-pure-pragma--ifndef"></a><code>--ifndef option</code></dt>
<dd>Begins a code section which should be included in the program if the given option is defined or undefined, respectively.
</dd>
<dt><a name="cmdoption-pure-pragma--if"></a><code>--if option</code>, <a name="cmdoption-pure-pragma--ifnot"></a><code>--ifnot option</code></dt>
<dd>Begins a code section which should be included in the program if the given option is enabled or disabled, respectively.
</dd>
<dt><a name="cmdoption-pure-pragma--else"></a><code>--else</code></dt>
<dd>Begins an alternative code section which is included in the program if the corresponding <a href="#cmdoption-pure-pragma--ifdef"><code>--ifdef</code></a>, <a href="#cmdoption-pure-pragma--ifndef"><code>--ifndef</code></a>, <a href="#cmdoption-pure-pragma--if"><code>--if</code></a> or <a href="#cmdoption-pure-pragma--ifnot"><code>--ifnot</code></a> section was excluded, and vice versa.
</dd>
<dt><a name="cmdoption-pure-pragma--endif"></a><code>--endif</code></dt>
<dd>Ends a conditional code section.
</dd>
</dl>
<!-- -->
<p>Conditional code sections may be nested to an arbitrary depth. Each <a href="#cmdoption-pure-pragma--ifdef"><code>--ifdef</code></a>, <a href="#cmdoption-pure-pragma--ifndef"><code>--ifndef</code></a>, <a href="#cmdoption-pure-pragma--if"><code>--if</code></a> or <a href="#cmdoption-pure-pragma--ifnot"><code>--ifnot</code></a> pragma must be followed by a matching <a href="#cmdoption-pure-pragma--endif"><code>--endif</code></a>. The <a href="#cmdoption-pure-pragma--else"><code>--else</code></a> section is optional; if present, it applies to the most recent <a href="#cmdoption-pure-pragma--ifdef"><code>--ifdef</code></a>, <a href="#cmdoption-pure-pragma--ifndef"><code>--ifndef</code></a>, <a href="#cmdoption-pure-pragma--if"><code>--if</code></a> or <a href="#cmdoption-pure-pragma--ifnot"><code>--ifnot</code></a> section not terminated by a matching <a href="#cmdoption-pure-pragma--endif"><code>--endif</code></a>. Unmatched conditional pragmas warrant an error message by the compiler.</p>
<p>Conditional code is handled at the level of the lexical analyzer. Excluded code sections are treated like comments, i.e., the parser never gets to see them.</p>
<p>The <a href="#cmdoption-pure-pragma--ifdef"><code>--ifdef</code></a> and <a href="#cmdoption-pure-pragma--ifndef"><code>--ifndef</code></a> pragmas are typically used to change the default of an option without clobbering defaults set by the user through an environment variable or a command line option. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --ifndef opt
#! --disable opt
#! --endif</code></pre></div>
<p>Here’s a (rather contrived) example which shows all these pragmas in action. You may want to type this in the interpreter to verify that the code sections are indeed included and excluded from the Pure program as indicated:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="co">// disable the &#39;bar&#39; option</span>
#! --disable bar

#! --ifdef foo
<span class="dv">1</span>/<span class="dv">2</span>; <span class="co">// excluded</span>
#! --endif
#! --ifndef bar
<span class="dv">1</span>/<span class="dv">3</span>; <span class="co">// excluded</span>
#! --endif

#! --<span class="kw">if</span> foo
foo x = x+<span class="dv">1</span>; <span class="co">// included</span>
#! --<span class="kw">if</span> bar
bar x = x-<span class="dv">1</span>; <span class="co">// excluded</span>
#! --<span class="kw">else</span>
bar x = x/<span class="dv">2</span>; <span class="co">// included</span>
#! --endif <span class="co">// bar</span>
#! --endif <span class="co">// foo</span>

<span class="co">// reenable the &#39;bar&#39; option</span>
#! --enable bar

#! --<span class="kw">if</span> bar
bar <span class="dv">99</span>; <span class="co">// included</span>
#! --endif <span class="co">// bar</span>

#! --ifnot foo
baz x = <span class="dv">2</span>*x; <span class="co">// excluded</span>
#! --endif <span class="co">// not foo</span></code></pre></div>
<p>A few options are always predefined as “builtins” by the interpreter. This includes all of the options described under <a href="#code-generation-options">Code Generation Options</a> and <a href="#warning-options">Warning Options</a>, so that these can also be queried with <a href="#cmdoption-pure-pragma--if"><code>--if</code></a>, <a href="#cmdoption-pure-pragma--ifnot"><code>--ifnot</code></a> and set with <a href="#cmdoption-pure-pragma--enable"><code>--enable</code></a>, <a href="#cmdoption-pure-pragma--disable"><code>--disable</code></a>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --ifnot checks
puts <span class="st">&quot;This program uses deep recursion, so we enable stack checks here!&quot;</span>;
#! --enable checks
#! --endif <span class="co">// not checks</span>

#! --<span class="kw">if</span> warn
puts <span class="st">&quot;Beware of bugs in the above code.&quot;</span>;
puts <span class="st">&quot;I have only proved it correct, not tried it.&quot;</span>;
#! --endif <span class="co">// warn</span></code></pre></div>
<p>Moreover, the following options are provided as additional builtins which are useful for handling special compilation requirements as well as system and version dependencies.</p>
<ul>
<li>The <code>compiled</code> option is enabled if a program is batch-compiled. This lets you pick alternative code paths depending on whether a script is compiled to a native executable or not. Please see the example at the end of the <a href="#batch-compilation">Batch Compilation</a> section for details.</li>
<li><p>The <code>interactive</code> and <code>debugging</code> options are enabled if a program runs in interactive (<a href="#cmdoption-pure-i"><code>-i</code></a>) and/or debugging (<a href="#cmdoption-pure-g"><code>-g</code></a>) mode, respectively. These options are read-only; they cannot be changed with <a href="#cmdoption-pure-pragma--enable"><code>--enable</code></a>, <a href="#cmdoption-pure-pragma--disable"><code>--disable</code></a>. Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --<span class="kw">if</span> interactive
puts <span class="st">&quot;Usage: run &#39;main filename&#39;&quot;</span>;
#! --<span class="kw">else</span>
main (argv!<span class="dv">1</span>);
#! --endif</code></pre></div></li>
<li><p>The <code>version-x.y</code> option indicates a check against the version of the host Pure interpreter. <code>x.y</code> indicates the required (major/minor) version. You can also use <code>x.y+</code> to indicate version <code>x.y</code> or later, or <code>x.y-</code> for version <code>x.y</code> or earlier. By combining these, you can pick code depending on a particular range of Pure versions, or you can reverse the test to check for anything later or earlier than a given version:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --<span class="kw">if</span> version-<span class="dv">0.36</span>+
#! --<span class="kw">if</span> version-<span class="dv">0.48</span>-
<span class="co">// code to be executed for Pure versions 0.36..0.48 (inclusive)</span>
#! --endif
#! --endif

#! --ifnot version-<span class="dv">0.48</span>-
<span class="co">// code to be executed for Pure versions &gt; 0.48</span>
#! --endif</code></pre></div></li>
<li><p>Last but not least, the interpreter always defines the target triplet of the host system as an option symbol. This is the same as what <a href="#sysinfo"><code>sysinfo</code></a> returns, so you can check for a specific system like this:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --<span class="kw">if</span> x86_64-unknown-linux-gnu
<span class="co">// 64 bit Linux-specific code goes here</span>
#! --endif</code></pre></div>
<p>It goes without saying that this method isn’t very practical if you want to check for a wide range of systems. As a remedy, the <a href="#cmdoption-pure-pragma--if"><code>--if</code></a> and <a href="#cmdoption-pure-pragma--ifnot"><code>--ifnot</code></a> pragmas treat shell glob patterns in tests for option symbols in a special way, by matching the pattern against the host triplet to see whether the condition holds. This allows you to write a generic test, e.g., for Windows systems like this:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --<span class="kw">if</span> *-mingw32
<span class="co">// Windows-specific code goes here</span>
#! --endif</code></pre></div></li>
</ul>
<h4 id="warning-options">Warning Options</h4>
<p>The <a href="#cmdoption-pure-w"><code>-w</code></a> option enables some additional warnings which are useful to check your scripts for possible errors. In particular, it will report implicit declarations of function and type symbols, which might indicate undefined or mistyped symbols that need to be fixed, see <a href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a> for details.</p>
<p>This option can also be controlled on a per-rule basis by adding the following pragmas to your script:</p>
<dl>
<dt><a name="cmdoption-pure-pragma--warn"></a><code>--warn</code>, <a name="cmdoption-pure-pragma--nowarn"></a><code>--nowarn</code></dt>
<dd>Enable or disable compiler warnings. The <a href="#cmdoption-pure-w"><code>-w</code></a> flag sets the default for these pragmas.
</dd>
<dt><a name="cmdoption-pure-pragma--rewarn"></a><code>--rewarn</code></dt>
<dd>Reset compiler warnings to the default, as set with the <a href="#cmdoption-pure-w"><code>-w</code></a> flag (or not).
</dd>
</dl>
<!-- -->
<p>The latter pragma is useful to enable or disable warnings in a section of code and reset it to the default afterwards:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --warn
<span class="co">// Code with warnings goes here.</span>
#! --rewarn</code></pre></div>
<p>(The same could also be achieved with conditional compilation, but only much more clumsily. However, note that <a href="#cmdoption-pure-pragma--rewarn"><code>--rewarn</code></a> only provides a single level of “backup”, so nesting such sections is not supported.)</p>
<h3 id="startup-files">Startup Files</h3>
<p>The interpreter may source various files during its startup. These are:</p>
<dl>
<dt><code>~/.pure_history</code></dt>
<dd>Interactive command history.
</dd>
<dt><code>~/.purerc, .purerc, .pure</code></dt>
<dd>Interactive startup files. The latter is usually a dump from a previous interactive session.
</dd>
<dt><code>prelude.pure</code></dt>
<dd>Standard prelude. If available, this script is loaded before any other definitions, unless <a href="#cmdoption-pure-n"><code>-n</code></a> was specified.
</dd>
</dl>
<!-- -->
<h3 id="environment">Environment</h3>
<p>Various aspects of the interpreter can be configured through the following shell environment variables:</p>
<dl>
<dt><a name="envvar-CC"></a><code>CC</code>, <a name="envvar-CXX"></a><code>CXX</code></dt>
<dd>C and C++ compiler used by the Pure batch compiler (<code>pure -c</code>) to compile and link native executables. Defaults to <strong>gcc</strong> and <strong>g++</strong>, respectively.
</dd>
<dt><a name="envvar-BROWSER"></a><code>BROWSER</code></dt>
<dd>If the <a href="#envvar-PURE_HELP"><code>PURE_HELP</code></a> variable is not set (see below), this specifies a colon-separated list of browsers to try for reading the online documentation. See <a href="http://catb.org/~esr/BROWSER/" class="uri">http://catb.org/~esr/BROWSER/</a>.
</dd>
<dt><a name="envvar-PURELIB"></a><code>PURELIB</code></dt>
<dd>Directory to search for library scripts, including the prelude. If <a href="#envvar-PURELIB"><code>PURELIB</code></a> is not set, it defaults to some location specified at installation time.
</dd>
<dt><a name="envvar-PURE_EAGER_JIT"></a><code>PURE_EAGER_JIT</code></dt>
<dd>Enable eager JIT compilation (same as <a href="#cmdoption-pure--eager-jit"><code>--eager-jit</code></a>), see <a href="#compiling-scripts">Compiling Scripts</a> for details.
</dd>
<dt><a name="envvar-PURE_ESCAPE"></a><code>PURE_ESCAPE</code></dt>
<dd>If set, interactive commands are prefixed with the first character in the value of this variable (same as <a href="#cmdoption-pure--escape"><code>--escape</code></a>), see <a href="#interactive-usage">Interactive Usage</a> for details.
</dd>
<dt><a name="envvar-PURE_HELP"></a><code>PURE_HELP</code></dt>
<dd>Command used to browse the Pure manual. This must be a browser capable of displaying html files. Default is <strong>w3m</strong>.
</dd>
<dt><a name="envvar-PURE_INCLUDE"></a><code>PURE_INCLUDE</code></dt>
<dd>Additional directories (in colon-separated format) to be searched for included scripts.
</dd>
<dt><a name="envvar-PURE_LIBRARY"></a><code>PURE_LIBRARY</code></dt>
<dd>Additional directories (in colon-separated format) to be searched for dynamic libraries.
</dd>
<dt><a name="envvar-PURE_MORE"></a><code>PURE_MORE</code></dt>
<dd>Shell command to be used for paging through output of the <code>show</code> command, when the interpreter runs in interactive mode. <a href="#envvar-PURE_LESS"><code>PURE_LESS</code></a> does the same for evaluation results printed by the interpreter.
</dd>
<dt><a name="envvar-PURE_PS"></a><code>PURE_PS</code></dt>
<dd>Command prompt used in the interactive command loop (“&gt;” by default).
</dd>
<dt><a name="envvar-PURE_STACK"></a><code>PURE_STACK</code></dt>
<dd>Maximum stack size in kilobytes (0 = unlimited). A reasonable default is provided (currently this is always 8192K - 128K for interpreter and runtime, which should work on most modern PCs). If you’re still getting segfaults due to stack overflow then you’ll either have to reduce this value or increase the actual stack space available to programs.
</dd>
</dl>
<!-- -->
<p>Besides these, the interpreter also understands a number of other environment variables for setting various compilation options (see <a href="#compilation-options">Compilation Options</a> above) and commands to invoke different LLVM compilers on inline code (see <a href="#inline-code">Inline Code</a>).</p>
<h2 id="pure-overview">Pure Overview</h2>
<p>Pure is a fairly simple yet powerful language. Programs are basically collections of term rewriting rules, which are used to reduce expressions to <strong>normal form</strong> in a symbolic fashion. For convenience, Pure also offers some extensions to the basic term rewriting calculus, like global variables and constants, nested scopes of local function and variable definitions, anonymous functions (lambdas), exception handling and a built-in macro facility. These are all described below and in the following sections.</p>
<p>Most basic operations are defined in the standard <a href="purelib.html#prelude">prelude</a>. This includes the usual arithmetic and logical operations, as well as the basic string, list and matrix functions. The prelude is always loaded by the interpreter, so that you can start using the interpreter as a sophisticated kind of desktop calculator right away. Other useful operations are provided through separate library modules. Some of these, like the system interface and the container data structures, are distributed with the interpreter, others are available as separate add-on packages from the Pure website. A (very) brief overview of some of the modules distributed with the Pure interpreter can be found in the <a href="#standard-library">Standard Library</a> section.</p>
<p>In this section we first give a brief overview of the most important elements of the Pure language. After starting out with a discussion of the lexical syntax, we proceed by explaining definitions and expressions, which are the major ingredients of Pure programs. After studying this section you should be able to write simple Pure programs. Subsequent sections then describe the concepts and notions introduced here in much greater detail and also cover the more advanced language elements which we only gloss over here.</p>
<h3 id="lexical-matters">Lexical Matters</h3>
<p>Pure is a <strong>free-format</strong> language, i.e., whitespace is insignificant (unless it is used to delimit other symbols). Thus, in contrast to “layout-based” languages like Haskell, you <em>must</em> use the proper delimiters (<code>;</code>) and keywords (<a href="#end"><code>end</code></a>) to terminate definitions and block structures. In particular, definitions and expressions at the toplevel have to be terminated with a semicolon, even if you’re typing them interactively in the interpreter.</p>
<p>Comments use the same syntax as in C++: <code>//</code> for line-oriented, and <code>/* ... */</code> for multiline comments. The latter must not be nested. Lines beginning with <code>#!</code> are treated as comments, too; as already discussed above, on Unix-like systems this allows you to add a “shebang” to your main script in order to turn it into an executable program.</p>
<p>A few ASCII symbols are reserved for special uses, namely the semicolon, the “at” symbol <code>@</code>, the equals sign <code>=</code>, the backslash <code>\</code>, the Unix pipe symbol <code>|</code>, parentheses <code>()</code>, brackets <code>[]</code> and curly braces <code>{}</code>. (Among these, only the semicolon is a “hard delimiter” which is always a lexeme by itself; the other symbols can be used inside operator symbols.) Moreover, there are some keywords which cannot be used as identifiers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">case</span>   <span class="kw">const</span>      <span class="kw">def</span>     <span class="kw">else</span>       <span class="kw">end</span>     <span class="kw">extern</span>     <span class="kw">if</span>
<span class="kw">infix</span>  <span class="kw">infixl</span>     <span class="kw">infixr</span>  <span class="kw">interface</span>  <span class="kw">let</span>     <span class="kw">namespace</span>  <span class="kw">nonfix</span>
<span class="kw">of</span>     <span class="kw">otherwise</span>  <span class="kw">outfix</span>  <span class="kw">postfix</span>    <span class="kw">prefix</span>  <span class="kw">private</span>    <span class="kw">public</span>
<span class="kw">then</span>   <span class="kw">type</span>       <span class="kw">using</span>   <span class="kw">when</span>       <span class="kw">with</span></code></pre></div>
<p>Pure fully supports the <strong>Unicode</strong> character set or, more precisely, UTF-8. This is an ASCII extension capable of representing all Unicode characters, which provides you with thousands of characters from most of the languages of the world, as well as an abundance of special symbols for almost any purpose. If your text editor supports the UTF-8 encoding (most editors do nowadays), you can use all Unicode characters in your Pure programs, not only inside strings, but also for denoting identifiers and special operator symbols.</p>
<p>The customary notations for identifiers, numbers and strings are all provided. In addition, Pure also allows you to define your own operator symbols. Identifiers and other symbols are described by the following grammar rules in EBNF format:</p>
<pre class="sourceCode bnf"><code>symbol : identifier | special
identifier : letter (letter | digit)*
special : punct+
letter : &quot;A&quot;|...|&quot;Z&quot;|&quot;a&quot;|...|&quot;z&quot;|&quot;_&quot;|...
digit : &quot;0&quot;|...|&quot;9&quot;
punct : &quot;!&quot;|&quot;#&quot;|&quot;$&quot;|&quot;%&quot;|&quot;&amp;&quot;|...</code></pre>
<p>Pure uses the following rules to distinguish “punctuation” (which may only occur in declared operator symbols) and “letters” (identifier constituents). In addition to the punctuation symbols in the 7 bit ASCII range, the following code points in the Unicode repertoire are considered as punctuation: U+00A1 through U+00BF, U+00D7, U+00F7, and U+20D0 through U+2BFF. This comprises the special symbols in the Latin-1 repertoire, as well as the Combining Diacritical Marks for Symbols, Letterlike Symbols, Number Forms, Arrows, Mathematical Symbols, Miscellaneous Technical Symbols, Control Pictures, OCR, Enclosed Alphanumerics, Box Drawing, Blocks, Geometric Shapes, Miscellaneous Symbols, Dingbats, Miscellaneous Mathematical Symbols A, Supplemental Arrows A, Supplemental Arrows B, Miscellaneous Mathematical Symbols B, Supplemental Mathematical Operators, and Miscellaneous Symbols and Arrows. This should cover almost everything you’d ever want to use in an operator symbol. All other extended Unicode characters are effectively treated as “letters” which can be used as identifier constituents. (Charts of all Unicode symbols can be found at the <a href="http://www.unicode.org/charts/">Code Charts</a> page of the <a href="http://www.unicode.org/">Unicode Consortium</a>.)</p>
<p>The following are examples of valid identifiers: <code>foo</code>, <code>foo_bar</code>, <code>FooBar</code>, <code>BAR</code>, <code>bar99</code>. Case is significant in identifiers, so <code>Bar</code> and <code>bar</code> are distinct identifiers, but otherwise the case of letters carries no meaning. Special symbols consist entirely of punctuation, such as <code>::=</code>. These may be used as operator symbols, but have to be declared before they can be used (see <a href="#symbol-declarations">Symbol Declarations</a>).</p>
<p>Pure also has a notation for qualified symbols which carry a namespace prefix. These take the following format (note that no whitespace is permitted between the namespace prefix and the symbol):</p>
<pre class="sourceCode bnf"><code>qualified_symbol : [qualifier] symbol
qualified_identifier : [qualifier] identifier
qualifier : [identifier] &quot;::&quot; (identifier &quot;::&quot;)*</code></pre>
<p>Example: <code>foo::bar</code>.</p>
<p>Number literals come in three flavours: integers, bigints (denoted with an <code>L</code> suffix) and floating point numbers (indicated by the presence of the decimal point and/or a base 10 scaling factor). Integers and bigints may be written in different bases (decimal, binary, octal and hexadecimal), while floating point numbers are always denoted in decimal.</p>
<pre class="sourceCode bnf"><code>number : integer | integer &quot;L&quot; | float
integer : digit+
    | &quot;0&quot; (&quot;X&quot;|&quot;x&quot;) hex_digit+
    | &quot;0&quot; (&quot;B&quot;|&quot;b&quot;) bin_digit+
    | &quot;0&quot; oct_digit+
oct_digit : &quot;0&quot;|...|&quot;7&quot;
hex_digit : &quot;0&quot;|...|&quot;9&quot;|&quot;A&quot;|...|&quot;F&quot;|&quot;a&quot;|...|&quot;f&quot;
bin_digit : &quot;0&quot;|&quot;1&quot;
float : digit+ [&quot;.&quot; digit+] exponent
    | digit* &quot;.&quot; digit+ [exponent]
exponent : (&quot;E&quot;|&quot;e&quot;) [&quot;+&quot;|&quot;-&quot;] digit+</code></pre>
<p>Examples: <code>4711</code>, <code>4711L</code>, <code>1.2e-3</code>. Numbers in different bases: <code>1000</code> (decimal), <code>0x3e8</code> (hexadecimal), <code>01750</code> (octal), <code>0b1111101000</code> (binary).</p>
<p>String literals are arbitrary sequences of characters enclosed in double quotes, such as <code>&quot;Hello, world!&quot;</code>.</p>
<pre class="sourceCode bnf"><code>string : &#39;&quot;&#39; char* &#39;&quot;&#39;</code></pre>
<p>Special escape sequences may be used to denote double quotes and backslashes (<code>\&quot;</code>, <code>\\</code>), control characters (<code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, these have the same meaning as in C), and arbitrary Unicode characters given by their number or <a href="http://www.w3.org/TR/xml-entity-names/">XML entity name</a> (e.g., <code>\169</code>, <code>\0xa9</code> and <code>\&amp;copy;</code> all denote the Unicode copyright character, code point U+00A9). As indicated, numeric escapes can be specified in any of the supported bases for integer literals. For disambiguating purposes, these can also be enclosed in parentheses. E.g., <code>&quot;\(123)4&quot;</code> is a string consisting of the character <code>\123</code> followed by the digit <code>4</code>. Strings can also be continued across line ends by escaping the line end with a backslash. The escaped line end is ignored (use <code>\n</code> if you need to embed a newline in a string). For instance, :</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="st">&quot;Hello, \</span>
<span class="st">world.</span><span class="ch">\n</span><span class="st">&quot;</span></code></pre></div>
<p>denotes the same string literal as</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="st">&quot;Hello, world.</span><span class="ch">\n</span><span class="st">&quot;</span></code></pre></div>
<h3 id="definitions-and-expression-evaluation">Definitions and Expression Evaluation</h3>
<p>The real meat of a Pure program is in its definitions. In Pure these generally take the form of equations which tell the interpreter how expressions are to be evaluated. For instance, the following two equations together define a function <code>fact</code> which computes, for each given integer <code>n</code>, the factorial of <code>n</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact <span class="dv">0</span> = <span class="dv">1</span>;
fact n::<span class="dt">int</span> = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;</code></pre></div>
<p>The first equation covers the case that <code>n</code> is zero, in which case the result is <code>1</code>. The second equation handles the case of a positive integer. Note the <code>n::int</code> construct on the left-hand side, which means that the equation is restricted to (machine) integers <code>n</code>. This construct is also called a “type tag” in Pure parlance. In addition, the <code>n&gt;0</code> in the condition part of the second equation ensures that <code>n</code> is positive. If these conditions are met, the equation becomes applicable and we recursively compute <code>fact (n-1)</code> and multiply by <code>n</code> to obtain the result. The <code>fact</code> function thus computes the product of all positive integers up to <code>n</code>, which is indeed just how the factorial is defined in mathematics.</p>
<p>To give this definition a try, you can just enter it at the command prompt of the interpreter as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">0</span> = <span class="dv">1</span>;
&gt; fact n::<span class="dt">int</span> = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
&gt; fact <span class="dv">10</span>;
<span class="dv">3628800</span></code></pre></div>
<p>On the surface, Pure is quite similar to other modern functional languages like <a href="#haskell">Haskell</a> and <a href="#ml">ML</a>. But under the hood it is a much more dynamic language, more akin to Lisp. In particular, Pure is dynamically typed, so functions can process arguments of as many different types as you like. In fact, you can add to the definition of an existing function at any time. For instance, we can extend our example above to make the <code>fact</code> function work with floating point numbers, too:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">0.0</span> = <span class="dv">1.0</span>;
&gt; fact n::<span class="dt">double</span> = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
&gt; fact <span class="dv">10.0</span>;
<span class="dv">3628800.0</span></code></pre></div>
<p>Here we employed the constant <code>0.0</code> and the <code>double</code> type tag to define the factorial for the case of floating point numbers. Both <code>int</code> and <code>double</code> are built-in types of the Pure language. Our earlier definition for the <code>int</code> case still works as well:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">10</span>;
<span class="dv">3628800</span></code></pre></div>
<p>In FP parlance, we say that a function like <code>fact</code> is <strong>polymorphic</strong>, because it applies to different argument types. More precisely, the kind of polymorphism at work here is <strong>ad-hoc polymorphism</strong>, because we have two distinct definitions of the same function which behave differently for different argument types.</p>
<p>Note that in this specific case, the two definitions are in fact very similar, to the point that the right-hand sides of the definitions are almost the same. Observing these similarities, we may also define <code>fact</code> in a completely generic way:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear fact
&gt; fact n = <span class="dv">1</span> <span class="kw">if</span> n==<span class="dv">0</span>;
&gt; fact n = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;</code></pre></div>
<p>(Note that before we can enter the new definition, we first need to scratch our previous definition of <code>fact</code>, that’s what the <code>clear fact</code> command does. This is necessary because, as we already saw, the interpreter would otherwise just keep adding equations to the definition of <code>fact</code> that we already have.)</p>
<p>Our new definition doesn’t have any type tags on the left-hand side and will thus work with any type of numbers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">10</span>; <span class="co">// int</span>
<span class="dv">3628800</span>
&gt; fact <span class="dv">30.0</span>; <span class="co">// floating point</span>
<span class="dv">2.65252859812191e+32</span>
&gt; fact 50L; <span class="co">// bigint</span>
30414093201713378043612608166064768844377641568960512000000000000L</code></pre></div>
<p>Let’s now take a look at how the equations are actually applied in the evaluation process. Conceptually, Pure employs term rewriting as its underlying model of computation, so the equations are applied as rewriting rules, reading them from left to right. An equation is applicable if its left-hand side matches the target term to be evaluated, in which case we can bind the variables in the left-hand side to the corresponding subterms in the target term. Equations are tried in the order in which they are written; as soon as the left-hand side of an equation matches (and the condition part of the equation, if any, is satisfied), it can be applied to reduce the target term to the corresponding right-hand side.</p>
<p>For instance, let’s take a look at the target term <code>fact 3</code>. This matches both equations of our generic definition of <code>fact</code> from above, with <code>n</code> bound to <code>3</code>. But the condition <code>3==0</code> of the first equation fails, so we come to consider the second equation, whose condition <code>3&gt;0</code> holds. Thus we can perform the reduction <code>fact 3 ==&gt; 3*fact (3-1)</code> and then evaluate the new target term <code>3*fact (3-1)</code> recursively.</p>
<p>At this point, we have to decide which of the several subterms we should reduce first. This is also called the <strong>reduction strategy</strong> and there are different ways to go about it. For instance, we might follow the customary “call-by-value” strategy where the arguments of a function application are evaluated recursively before the function gets applied to it, and this is also what Pure normally does. More precisely, expressions are evaluated using the “leftmost-innermost” reduction strategy where the arguments are considered from left to right.</p>
<p>So this means that on the right-hand side of the second equation, first <code>n-1</code> (being the argument of <code>fact</code>) is evaluated, then <code>fact (n-1)</code> (which is an argument to the <code>*</code> operator), and finally <code>fact (n-1)</code> is multiplied by <code>n</code> to give the value of <code>fact n</code>. Thus the evaluation of <code>fact 3</code> actually proceeds as follows (abbreviating reductions for the built-in arithmetic operations):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact <span class="dv">3</span> =&gt; <span class="dv">3</span>*fact <span class="dv">2</span> =&gt; <span class="dv">3</span>*<span class="dv">2</span>*fact <span class="dv">1</span> =&gt; <span class="dv">3</span>*<span class="dv">2</span>*<span class="dv">1</span>*fact <span class="dv">0</span> =&gt; <span class="dv">3</span>*<span class="dv">2</span>*<span class="dv">1</span>*<span class="dv">1</span> =&gt; <span class="dv">6</span>.</code></pre></div>
<p>We mention in passing here that Pure also has a few built-in “special forms” which take some or all of their arguments unevaluated, using “call by name” argument passing. This is needed to handle some constructs such as logical operations and conditionals in an efficient manner, and it also provides a way to implement “lazy” data structures. We’ll learn about these later.</p>
<p>One of the convenient aspects of the rewriting model of computation is that it enables you to define a function by pattern matching on structured argument types. For instance, we might compute the sum of the elements of a list as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sum [] = <span class="dv">0</span>;
&gt; sum (x:xs) = x+sum xs;</code></pre></div>
<p>This discriminates over the different cases for the argument value which might either be the empty list <code>[]</code> or a non-empty list of the from <code>x:xs</code> where the variables <code>x</code> and <code>xs</code> refer to the head element and the rest of the list, respectively. (The ‘<code>:</code>’ infix operator is Pure’s way of writing Lisp’s “cons”; this works the same as in other modern FPLs and is discussed in much more detail later.)</p>
<p>Let’s give it a try:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sum (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">55</span></code></pre></div>
<p>Note that <code>1..10</code> denotes the list of all positive integers up to 10 here, so we get the sum of the numbers 1 thru 10 as the result, which is indeed 55. (The ‘<a href="purelib.html#.."><code>..</code></a>’ operation is provided in Pure’s prelude, i.e., it is part of the standard library.)</p>
<p>Due to its term rewriting semantics, Pure actually goes beyond most other functional languages in that it can do symbolic evaluations just as well as “normal” computations:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; square x = x*x;
&gt; square <span class="dv">4</span>;
<span class="dv">16</span>
&gt; square (a+b);
(a+b)*(a+b)</code></pre></div>
<p>In fact, leaving aside the built-in support for some common data structures such as numbers and strings, all the Pure interpreter really does is evaluate expressions in a symbolic fashion, rewriting expressions using the equations supplied by the programmer, until no more equations are applicable. The result of this process is called a <strong>normal form</strong> which represents the “value” of the original expression. Moreover, there’s no distinction between “defined” and “constructor” function symbols in Pure, so <em>any</em> function symbol or operator can be used <em>anywhere</em> on the left-hand side of an equation, and may act as a constructor symbol if it happens to occur in a normal form term. This enables you to work with algebraic rules like associativity and distributivity in a direct fashion:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (x+y)*z = x*z+y*z; x*(y+z) = x*y+x*z;
&gt; x*(y*z) = (x*y)*z; x+(y+z) = (x+y)+z;
&gt; square (a+b);
a*a+a*b+b*a+b*b</code></pre></div>
<p>The above isn’t possible in languages like Haskell and ML which always enforce that only “pure” constructor symbols (without any defining equations) may occur as a subterm on the left-hand side of a definition; this is also known as the <strong>constructor discipline</strong>. Thus equational definitions like the above are forbidden in these languages. Pure doesn’t enforce the constructor discipline, so it doesn’t keep you from writing such symbolic rules if you need them.</p>
<p>Another way of looking at this is that Pure allows you to have <strong>constructor equations</strong>. For instance, the following equation makes lists automatically stay sorted:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x:y:xs = y:x:xs <span class="kw">if</span> x&gt;y;
&gt; [<span class="dv">13</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">7</span>,<span class="dv">1</span>]+[<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">7</span>,<span class="dv">5</span>];
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">13</span>]</code></pre></div>
<p>This isn’t possible in Haskell and ML either because it violates the constructor discipline; since ‘<code>:</code>’ is a constructor it can’t simultaneously be a defined function in these languages. Pure gives you much more freedom there.</p>
<p>This symbolic mode of evaluation is rather unusual outside of the realm of symbolic algebra systems, but it provides the programmer with a very flexible model of computation and is one of Pure’s most distinguishing features. In some cases, however, the unevaluated normal forms may also become a nuisance since they may obscure possible programming errors. Therefore Pure provides special <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> and <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragmas (cf. <a href="#code-generation-options">Code Generation Options</a>) which force functions to be treated as defined functions, so that they become more like functions in traditional untyped languages such as Lisp and Python which raise an exception under such conditions. This is described in more detail under <a href="#defined-functions">Defined Functions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section.</p>
<h4 id="variables-in-equations">Variables in Equations</h4>
<p>Taking another look at the examples above, you might wonder how the Pure interpreter figures out what the parameters (a.k.a. “variables”) in an equation are. This is quite obvious in rules involving just variables and special operator symbols, such as <code>(x+y)*z = x*z+y*z</code>. However, what about an equation like <code>foo (foo bar) = bar</code>? Since most of the time we don’t declare any symbols in Pure, how does the interpreter know that <code>foo</code> is a literal function symbol here, while <code>bar</code> is a variable?</p>
<p>The answer is that the interpreter considers the different positions in the left-hand side expression of an equation. Basically, a Pure expression is just a tree formed by applying expressions to other expressions, with the atomic subexpressions like numbers and symbols at the leaves of the tree. (This is true even for infix expressions like <code>x+y</code>, since in Pure these are always equivalent to a function application of the form <code>(+) x y</code> which has the atomic subterms <code>(+)</code>, <code>x</code> and <code>y</code> at its leaves.)</p>
<p>Now the interpreter divides the leaves of the expression tree into “head” (or “function”) and “parameter” (or “variable”) positions based on which leaves are leftmost in a function application or not. Thus, in an expression like <code>f x y z</code>, <code>f</code> is in the head or function position, while <code>x</code>, <code>y</code> and <code>z</code> are in parameter or variable positions. (Note that in an infix expression like <code>x+y</code>, <code>(+)</code> is the head symbol, not <code>x</code>, as the expression is really parsed as <code>(+) x y</code>, see above.)</p>
<p>Identifiers in head positions are taken as literal function symbols by the interpreter, while identifiers in variable positions denote, well, variables. We also refer to this convention as the <strong>head = function rule</strong>. It is quite intuitive and lets us get away without declaring the variables in equations. (There are some corner cases not covered here, however. In particular, Pure allows you to declare special “nonfix” symbols, if you need a symbol to be recognized as a literal even if it occurs in a variable position. This is done by means of a <a href="#nonfix"><code>nonfix</code></a> declaration, see <a href="#symbol-declarations">Symbol Declarations</a> for details.)</p>
<h3 id="expression-syntax">Expression Syntax</h3>
<p>Like in other functional languages, expressions are the central ingredient of all Pure programs. All computation performed by a Pure program consists in the evaluation of expressions, and expressions also form the building blocks of the equational rules which are used to define the constants, variables, functions and macros of a Pure program.</p>
<p>Typical examples of the different expression types are summarized in the following table. Note that lambdas bind most weakly, followed by the special <a href="#case"><code>case</code></a>, <a href="#when"><code>when</code></a> and <a href="#with"><code>with</code></a> constructs, followed by conditional expressions (<a href="#if"><code>if</code></a>-<a href="#then"><code>then</code></a>-<a href="#else"><code>else</code></a>), followed by the simple expressions. Operators are a part of the simple expression syntax, and are parsed according to their declared precedences and associativities (cf. <a href="#symbol-declarations">Symbol Declarations</a>). Function application binds stronger than all operators. Parentheses can be used to group expressions and override default precedences as usual.</p>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Example</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Block</td>
<td align="left"><code>\x y-&gt;2*x-y</code></td>
<td align="left">anonymous function (lambda)</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>case f u of x,y = x+y end</code></td>
<td align="left">case expression</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>x+y when x,y = f u end</code></td>
<td align="left">local variable definition</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>f u with f (x,y) = x+y end</code></td>
<td align="left">local function definition</td>
</tr>
<tr class="odd">
<td align="left">Conditional</td>
<td align="left"><code>if x&gt;0 then x else -x</code></td>
<td align="left">conditional expression</td>
</tr>
<tr class="even">
<td align="left">Simple</td>
<td align="left"><code>x+y</code>, <code>-x</code>, <code>x mod y</code></td>
<td align="left">operator application</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>sin x</code>, <code>max a b</code></td>
<td align="left">function application</td>
</tr>
<tr class="even">
<td align="left">Primary</td>
<td align="left"><code>4711</code>, <code>4711L</code>, <code>1.2e-3</code></td>
<td align="left">number</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>&quot;Hello, world!\n&quot;</code></td>
<td align="left">string</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>foo</code>, <code>x</code>, <code>(+)</code></td>
<td align="left">function or variable symbol</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>[1,2,3]</code>, <code>(1,2,3)</code></td>
<td align="left">list and tuple</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>{1,2;3,4}</code></td>
<td align="left">matrix</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><code>[x,-y | x=1..n; y=1..m; x&lt;y]</code></td>
<td align="left">list comprehension</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><code>{i==j | i=1..n; j=1..m}</code></td>
<td align="left">matrix comprehension</td>
</tr>
</tbody>
</table>
<p>The formal syntax of expressions is as follows. (Note that the <a href="#rule"><code>rule</code></a> and <a href="#simple_rule"><code>simple_rule</code></a> elements are part of the definition syntax, which is explained in the <a href="#rule-syntax">Rule Syntax</a> section.)</p>
<pre class="sourceCode bnf"><code>expr : &quot;\&quot; prim_expr+ &quot;-&gt;&quot; expr
    | &quot;case&quot; expr &quot;of&quot; rules &quot;end&quot;
    | expr &quot;when&quot; simple_rules &quot;end&quot;
    | expr &quot;with&quot; rules &quot;end&quot;
    | &quot;if&quot; expr &quot;then&quot; expr &quot;else&quot; expr
    | simple_expr
simple_expr : simple_expr op simple_expr
    | op simple_expr
    | simple_expr op
    | application
application : application prim_expr
    | prim_expr
prim_expr : qualified_symbol
    | number
    | string
    | &quot;(&quot; op &quot;)&quot;
    | &quot;(&quot; left_op right_op &quot;)&quot;
    | &quot;(&quot; simple_expr op &quot;)&quot;
    | &quot;(&quot; op simple_expr &quot;)&quot;
    | &quot;(&quot; expr &quot;)&quot;
    | left_op expr right_op
    | &quot;[&quot; exprs &quot;]&quot;
    | &quot;{&quot; exprs (&quot;;&quot; exprs)* [&quot;;&quot;] &quot;}&quot;
    | &quot;[&quot; expr &quot;|&quot; simple_rules &quot;]&quot;
    | &quot;{&quot; expr &quot;|&quot; simple_rules &quot;}&quot;
exprs : expr (&quot;,&quot; expr)*
op : qualified_symbol
left_op : qualified_symbol
right_op : qualified_symbol
rules : rule (&quot;;&quot; rule)* [&quot;;&quot;]
simple_rules : simple_rule (&quot;;&quot; simple_rule)* [&quot;;&quot;]</code></pre>
<p><a name="primary-expressions"></a></p>
<h4 id="primary-expressions">Primary Expressions</h4>
<p>The Pure language provides built-in support for machine integers (32 bit), bigints (implemented using <a href="#gmp">GMP</a>), floating point values (double precision IEEE 754) and character strings (UTF-8 encoded). These can all be denoted using the corresponding literals described in <a href="#lexical-matters">Lexical Matters</a>. Truth values are encoded as machine integers; as you might expect, zero denotes <em>false</em> and any non-zero value <em>true</em>, and the prelude also provides symbolic constants <a href="purelib.html#false"><code>false</code></a> and <a href="purelib.html#true"><code>true</code></a> to denote these. Pure also supports generic C pointers, but these don’t have a syntactic representation in Pure, except that the predefined constant <a href="purelib.html#NULL"><code>NULL</code></a> may be used to denote a generic null pointer; other pointer values need to be created with external C functions.</p>
<p>Together, these atomic types of expressions make up most of Pure’s <strong>primary expression</strong> syntax. Pure also provides built-in support for some types of “compound primaries” (lists, tuples and matrices). We also list these here since they are typically denoted in some kind of bracketed form, even though some related non-primary expression types such as <code>x:y</code> or <code>x,y</code> really belong to the <a href="#simple-expressions">simple expressions</a>.</p>
<dl>
<dt>Numbers: <code>4711, 4711L, 1.2e-3</code></dt>
<dd>The usual C notations for integers (decimal: <code>1000</code>, hexadecimal: <code>0x3e8</code>, octal: <code>01750</code>) and floating point values are all provided. Integers can also be denoted in base 2 by using the <code>0b</code> or <code>0B</code> prefix: <code>0b1111101000</code>. Integer constants that are too large to fit into machine integers are promoted to bigints automatically. Moreover, integer literals immediately followed by the uppercase letter <code>L</code> are always interpreted as bigint constants, even if they fit into machine integers. This notation is also used when printing bigint constants, to distinguish them from machine integers.
</dd>
<dt>Strings: <code>&quot;Hello, world!\n&quot;</code></dt>
<dd>String constants are double-quoted and terminated with a null character, like in C. In contrast to C, strings are always encoded in UTF-8, and character escapes in Pure strings have a more flexible syntax (borrowed from the author’s Q language) which provides notations to specify any Unicode character. Please refer to <a href="#lexical-matters">Lexical Matters</a> for details.
</dd>
<dt>Function and variable symbols: <code>foo, foo_bar, BAR, foo::bar</code></dt>
<dd>These consist of the usual sequence of letters (including the underscore) and digits, starting with a letter. Case is significant, thus <code>foo</code>, <code>Foo</code> and <code>FOO</code> are distinct identifiers. The ‘<code>_</code>’ symbol, when occurring on the left-hand side of an equation, is special; it denotes the <strong>anonymous variable</strong> which matches any value without actually binding a variable. Identifiers can also be prefixed with a namespace identifier, like in <code>foo::bar</code>. (This requires that the given namespace has already been created, as explained under <a href="#namespaces">Namespaces</a> in the <a href="#declarations">Declarations</a> section.)
</dd>
<dt>Operator symbols: <code>+, ==, not</code></dt>
<dd><p>For convenience, Pure also provides you with a limited means to extend the syntax of the language with special operator symbols by means of a corresponding <strong>fixity</strong> declaration, as discussed in section <a href="#symbol-declarations">Symbol Declarations</a>. Besides the usual infix, prefix and postfix operators, Pure also provides outfix (bracket) and nonfix (nullary operator) symbols. (Nonfix symbols actually work more or less like ordinary identifiers, but the <a href="#nonfix"><code>nonfix</code></a> attribute tells the compiler that when such a symbol occurs on the left-hand side of an equation, it is always to be interpreted as a literal, cf. <a href="#the-head-function-rule">The “Head = Function” Rule</a>.)</p>
<p>Operator (and nonfix) symbols may take the form of an identifier or a sequence of punctuation characters, which may optionally be qualified with a namespace prefix. These symbols must always be declared before use. Once declared, they are always special, and can’t be used as ordinary identifiers any more. However, like in Haskell, by enclosing an operator in parentheses, such as <code>(+)</code> or <code>(not)</code>, you can turn it into an ordinary function symbol.</p>
</dd>
<dt>Lists: <code>[x,y,z], x:xs</code></dt>
<dd><p>Pure’s basic list syntax is the same as in Haskell, thus <code>[]</code> is the empty list and <code>x:xs</code> denotes a list with head element <code>x</code> and tail list <code>xs</code>. The infix constructor symbol ‘<a href="purelib.html#:"><code>:</code></a>’ is declared in the prelude. It associates to the right, so that <code>x:y:z</code> is the same as <code>x:(y:z)</code>. The usual syntactic sugar for list values in brackets is also provided, thus <code>[x,y,z]</code> is exactly the same as <code>x:y:z:[]</code>. (This kind of list value is also called a “proper” list. Pure also permits “improper” list values such as <code>1:2:3</code> with a non-list value in the tail. These aren’t of much use as ordinary list values, but are frequently used in patterns or symbolic expressions such as <code>x:y</code> where the tail usually is a variable.)</p>
<p>Lists can be nested to an arbitrary depth. Also note that, in contrast to Haskell, lists are not required to be homogeneous, so in general they may contain an arbitary mix of element types. E.g., <code>[1,2.0,[x,y]]</code> is a three-element list consisting of an integer, a floating point number and a nested list containing two symbols.</p>
<p>Pure also provides a notation for arithmetic sequences such as <code>1..5</code>, which denotes the list <code>[1,2,3,4,5]</code>. Note the missing brackets; Pure doesn’t use any special syntax for arithmetic sequences, the ‘<a href="purelib.html#.."><code>..</code></a>’ symbol is just an ordinary infix operator declared and defined in the prelude. Sequences with arbitrary stepsizes can be written by denoting the first two sequence elements using the ‘<a href="purelib.html#:"><code>:</code></a>’ operator, as in <code>1.0:1.2..3.0</code>. To prevent unwanted artifacts due to rounding errors, the upper bound in a floating point sequence is always rounded to the nearest grid point. Thus, e.g., <code>0.0:0.1..0.29</code> actually yields <code>[0.0,0.1,0.2,0.3]</code>, as does <code>0.0:0.1..0.31</code>.</p>
</dd>
<dt>Tuples: <code>(x,y,z)</code></dt>
<dd><p>Pure’s tuples are a flat variant of lists which are often used as aggregate function arguments and results when no elaborate hierarchical structure is needed. They are constructed using the infix “pairing” operator ‘<a href="purelib.html#,"><code>,</code></a>’, for which the empty tuple <a href="purelib.html#()"><code>()</code></a> acts as a neutral element (i.e., <code>(),x</code> is just <code>x</code>, as is <code>x,()</code>). Pairs always associate to the right, meaning that <code>x,y,z = x,(y,z) = (x,y),z</code>, where <code>x,(y,z)</code> is the normalized representation. These rules imply that tuples can’t be nested and that there are no “true” 1-tuples distinct from their single members; if you need this then you should use lists instead (cf. <a href="#splicing-tuples-and-matrices">Splicing Tuples and Matrices</a>).</p>
<p>Note that the parentheses are not really part of the tuple syntax in Pure, they’re just used to group expressions. So <code>(x,y,z)</code> denotes just <code>x,y,z</code>. But since the ‘<a href="purelib.html#,"><code>,</code></a>’ operator has a low precedence, the parentheses are often needed to include tuples in other contexts. In particular, the parentheses are required to set off tuple elements in lists and matrices. E.g., <code>[(1,2),3,(4,5)]</code> denotes a three element list consisting of two tuples and an integer.</p>
<p>Mathematically, Pure’s notion of tuples corresponds to a <strong>monoid</strong> with an associative binary operation ‘<a href="purelib.html#,"><code>,</code></a>’ and neutral element <a href="purelib.html#()"><code>()</code></a>. This is different from the usual definition of tuples in mathematical logic, which are nestable and correspond to Pure’s notion of lists. So in Pure you can take your pick and use either flat tuples or nestable lists, whatever is most convenient for the problem at hand.</p>
</dd>
<dt>Matrices: <code>{1.0,2.0,3.0}, {1,2;3,4}, {cos t,-sin t;sin t,cos t}</code></dt>
<dd><p>Pure also offers matrices, a kind of two-dimensional arrays, as a built-in data structure which provides efficient storage and element access. These work more or less like their Octave/MATLAB equivalents, but using curly braces instead of brackets. Component values may either be individual elements (“scalars”) or submatrices which are combined to form a larger matrix, provided that all dimensions match up. Here, a scalar is any expression which doesn’t yield a matrix; these are considered to be 1x1 submatrices for the purpose of matrix construction. (Note that this “splicing” behaviour pertains to matrix construction only; nested matrix <a href="#patterns">patterns</a> are always matched literally.)</p>
<p>The comma arranges submatrices and scalars in columns, while the semicolon arranges them in rows. So, if both <code>x</code> and <code>y</code> are <code>n</code> x <code>m</code> matrices, then <code>{x,y}</code> becomes an <code>n</code> x <code>2*m</code> matrix consisting of all the columns of <code>x</code> followed by all the columns of <code>y</code>. Likewise, <code>{x;y}</code> becomes a <code>2*n</code> x <code>m</code> matrix (all the rows of <code>x</code> above of all rows of <code>y</code>). For instance, <code>{{1;3},{2;4}}</code> is another way to write the 2x2 matrix <code>{1,2;3,4}</code>. Row vectors are denoted as 1 x <code>n</code> matrices (<code>{1,2,3}</code>), column vectors as <code>n</code> x 1 matrices (<code>{1;2;3}</code>). More examples can be found in the <a href="#matrices-and-vectors">Matrices and Vectors</a> section.</p>
<p>Pure supports both numeric and symbolic matrices. The former are homogeneous arrays of double, complex double or (machine) int matrices, while the latter can contain any mixture of Pure expressions. Pure will pick the appropriate type for the data at hand. If a matrix contains values of different types, or Pure values which cannot be stored in a numeric matrix, then a symbolic matrix is created instead (this also includes the case of bigints, which are considered as symbolic values as far as matrix construction is concerned). Numeric matrices use an internal data layout that is fully compatible with the GNU Scientific Library (<a href="">GSL</a>), and can readily be passed to GSL routines via the C interface. (The Pure interpreter does not require GSL, however, so numeric matrices will work even if GSL is not installed.)</p>
</dd>
<dt>Comprehensions: <code>[x,y | x=1..n; y=1..m; x&lt;y], {f x | x=1..n}</code></dt>
<dd><p>Pure provides both list and matrix comprehensions as a convenient means to construct list and matrix values from a “template” expression and one or more “generator” and “filter” clauses. The former bind a pattern to values drawn from a list or matrix, the latter are just predicates determining which generated elements should actually be added to the result. Comprehensions are in fact just syntactic sugar for a combination of lambdas, conditional expressions and certain list and matrix operations, but they are often much easier to write.</p>
<p>Thus, for instance, <code>[f x | x=1..n]</code> is pretty much the same as <code>map f (1..n)</code>, while <code>[x | x=xs; x&gt;0]</code> corresponds to <code>filter (&gt;0) xs</code>. However, comprehensions are considerably more general in that they allow you to draw values from different kinds of aggregates including lists, matrices and strings. Also, matrix comprehensions alternate between row and column generation so that most common mathematical abbreviations carry over quite easily. Patterns can be used on the left-hand side of generator clauses as usual, and will be matched against the actual list or matrix elements; any unmatched elements are filtered out automatically, like in Haskell.</p>
<p>More details and examples can be found in the <a href="#examples">Examples</a> section; in particular, see <a href="#list-comprehensions">List Comprehensions</a> and <a href="#matrices-and-vectors">Matrices and Vectors</a>.</p>
</dd>
</dl>
<!-- -->
<h4 id="simple-expressions">Simple Expressions</h4>
<p>The rest of Pure’s expression syntax mostly revolves around the notion of function applications. For convenience, Pure also allows you to declare pre-, post-, out- and infix operator symbols, but these are in fact just syntactic sugar for function applications; see <a href="#symbol-declarations">Symbol Declarations</a> for details. Function and operator applications are used to combine primary expressions to compound terms, also referred to as <strong>simple expressions</strong>; these are the data elements which are manipulated by Pure programs.</p>
<p>As in other modern FPLs, function applications are written simply as juxtaposition (i.e., in “curried” form) and associate to the left. This means that in fact all functions only take a single argument. Multi-argument functions are represented as chains of single-argument functions. For instance, in <code>f x y = (f x) y</code> first the function <code>f</code> is applied to the first argument <code>x</code>, yielding the function <code>f x</code> which in turn gets applied to the second argument <code>y</code>. This makes it possible to derive new functions from existing ones using <strong>partial applications</strong> which only specify some but not all arguments of a function. For instance, taking the <code>max</code> function from the prelude as an example, <code>max 0</code> is the function which, for a given <code>x</code>, returns <code>x</code> itself if it is nonnegative and zero otherwise. This works because <code>(max 0) x = max 0 x</code> is the maximum of <code>0</code> and <code>x</code>.</p>
<p>One major advantage of having curried function applications is that, without any further ado, functions become first-class objects. That is, they can be passed around freely both as parameters and as function return values. Much of the power of functional programming languages stems from this feature.</p>
<p>Operator applications are written using prefix, postfix, outfix or infix notation, as the declaration of the operator demands, but are just ordinary function applications in disguise. As already mentioned, enclosing an operator in parentheses turns it into an ordinary function symbol, thus <code>x+y</code> is exactly the same as <code>(+) x y</code>. For convenience, partial applications of infix operators can also be written using so-called <strong>operator sections</strong>. A <em>left section</em> takes the form <code>(x+)</code> which is equivalent to the partial application <code>(+) x</code>. A <em>right section</em> takes the form <code>(+x)</code> and is equivalent to the term <code>flip (+) x</code>. (This uses the <a href="purelib.html#flip"><code>flip</code></a> combinator from the prelude which is defined as <code>flip f x y = f y x</code>.) Thus <code>(x+) y</code> is equivalent to <code>x+y</code>, while <code>(+x) y</code> reduces to <code>y+x</code>. For instance, <code>(1/)</code> denotes the reciprocal and <code>(+1)</code> the successor function. (Note that, in contrast, <code>(-x)</code> always denotes an application of unary minus; the section <code>(+-x)</code> can be used to indicate a function which subtracts <code>x</code> from its argument.)</p>
<p>The common operator symbols like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> etc. are all declared at the beginning of the prelude, see the <a href="purelib.html">Pure Library Manual</a> for a list of these. Arithmetic and relational operators mostly follow C conventions. However, since <code>!</code>, <code>&amp;</code> and <code>|</code> are used for other purposes in Pure, the logical and bitwise operations, as well as the negated equality predicates are named a bit differently: <code>~</code>, <code>&amp;&amp;</code> and <code>||</code> denote logical negation, conjunction and disjunction, while the corresponding bitwise operations are named <code>not</code>, <code>and</code> and <code>or</code>. Moreover, following these conventions, inequality is denoted <code>~=</code>. Also note that <code>&amp;&amp;</code> and <code>||</code> are special forms which are evaluated in short-circuit mode (see <a href="#special-forms">Special Forms</a> below), whereas the bitwise connectives receive their arguments using call-by-value, just like the other arithmetic operations.</p>
<p><a name="if"></a></p>
<p><a name="then"></a></p>
<p><a name="else"></a></p>
<p><a name="case"></a></p>
<p><a name="when"></a></p>
<p><a name="with"></a></p>
<p><a name="end"></a></p>
<h4 id="special-expressions">Special Expressions</h4>
<p>Some special notations are provided for conditional expressions as well as anonymous functions (lambdas) and local function and variable definitions. The latter are also called <strong>block expressions</strong> since they introduce local bindings of variable and function symbols which may override other global or local bindings of these symbols. This gives rise to a kind of <strong>block structure</strong> similar to Algol-like programming languages. Please check <a href="#scoping-rules">Scoping Rules</a> below for more information about this.</p>
<p>The constructs described here are called “special” because, in contrast to the other forms of expressions, they cannot occur in normal form terms as first-class values (at least not literally; there is an alternative quoted representation of special expressions, however, which <em>can</em> be manipulated with macros and functions for meta programming purposes, cf. <a href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a>).</p>
<dl>
<dt>Conditional expressions: <code>if x then y else z</code></dt>
<dd>Evaluates to <code>y</code> or <code>z</code> depending on whether <code>x</code> is “true” (i.e., a nonzero integer). A <a href="purelib.html#failed_cond"><code>failed_cond</code></a> exception is raised if the condition is not an integer.
</dd>
<dt>Lambdas: <code>\x -&gt; y</code></dt>
<dd>These denote anonymous functions and work pretty much like in Haskell. A lambda matches its argument against the left-hand side pattern <code>x</code> and then evaluates the right-hand side body <code>y</code> with the variables in <code>x</code> bound to their corresponding values. Pure supports multiple-argument lambdas (e.g, <code>\x y -&gt; x*y</code>), as well as pattern-matching lambda abstractions such as <code>\(x,y) -&gt; x*y</code>. A <a href="purelib.html#failed_match"><code>failed_match</code></a> exception is raised if the actual arguments do not match the given patterns.
</dd>
<dt>Case expressions: <code>case x of u = v; ... end</code></dt>
<dd>Matches an expression, discriminating over a number of different cases, similar to the Haskell <code>case</code> construct. The expression <code>x</code> is matched in turn against each left-hand side pattern <code>u</code> in the rule list, and the first pattern which matches <code>x</code> gives the value of the entire expression, by evaluating the corresponding right-hand side <code>v</code> with the variables in the pattern bound to their corresponding values. A <a href="purelib.html#failed_match"><code>failed_match</code></a> exception is raised if the target expression doesn’t match any of the patterns.
</dd>
<dt>When expressions: <code>x when u = v; ... end</code></dt>
<dd>An alternative way to bind local variables by matching a collection of subject terms against corresponding patterns, similar to <a href="">Aardappel</a>’s <code>when</code> construct. A single binding <code>x when u = v end</code> is equivalent to the lambda expression <code>(\u -&gt; x) v</code> or the <code>case</code> expression <code>case v of u = x end</code>, so it matches <code>v</code> against the pattern <code>u</code> and evaluates <code>x</code> with the variables in <code>u</code> bound to their corresponding values (or raises a <a href="purelib.html#failed_match"><code>failed_match</code></a> exception if <code>v</code> doesn’t match <code>u</code>). However, a <code>when</code> clause may contain multiple definitions, which are processed from left to right, so that later definitions may refer to the variables in earlier ones. (This is exactly the same as several nested single definitions, with the first binding being the “outermost” one.)
</dd>
<dt>With expressions: <code>x with u = v; ... end</code></dt>
<dd>Defines local functions. Like Haskell’s <code>where</code> construct, but it can be used anywhere inside an expression (just like Aardappel’s <code>where</code>, but Pure uses the keyword <code>with</code> which better lines up with <code>case</code> and <code>when</code>). Several functions can be defined in a single <code>with</code> clause, and the definitions can be mutually recursive and consist of as many equations as you want. Local functions are applied in the same way as global ones, i.e., the argument patterns of each rule are matched against the actual function arguments and the first rule which matches has its right-hand side evaluated with the variables in the argument patterns bound to their corresponding values. If none of the rules match then the function application remains unevaluated (it becomes a normal form), so no exception is raised in this case. (This is in contrast to a lambda which otherwise is pretty much like a nameless local function defined by a single rule.)
</dd>
</dl>
<!-- -->
<p>The block constructs are similar to those available in most modern functional languages. In Pure these constructs are all implemented in terms of the basic term rewriting machinery, using <a href="http://en.wikipedia.org/wiki/Lambda_lifting">lambda lifting</a> to eliminate local functions, and the following equivalences which reduce lambdas as well as <a href="#case"><code>case</code></a> and <a href="#when"><code>when</code></a> expressions to special kinds of local functions or local function applications:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">\x1 ... xn -&gt; y
== f <span class="kw">with</span> f x1 ... xn = y; f _ ... _ = <span class="fu">throw</span> failed_match <span class="kw">end</span>

<span class="kw">case</span> x <span class="kw">of</span> y1 = z1; ...; yn = zn <span class="kw">end</span>
== f x <span class="kw">with</span> f y1 = z1; ...; f yn = zn; f _ = <span class="fu">throw</span> failed_match <span class="kw">end</span>

x <span class="kw">when</span> y = z <span class="kw">end</span>
== f z <span class="kw">with</span> f y = x; f _ = <span class="fu">throw</span> failed_match <span class="kw">end</span>

x <span class="kw">when</span> y1 = z1; ...; yn = zn <span class="kw">end</span>
== x <span class="kw">when</span> yn = zn <span class="kw">end</span> ... <span class="kw">when</span> y1 = z1 <span class="kw">end</span></code></pre></div>
<p>Note that by convention these constructs report a <a href="purelib.html#failed_match"><code>failed_match</code></a> exception in case of argument mismatch. So they’re treated like <a href="#defined-functions">defined functions</a>, which is somewhat at odds with the term rewriting semantics. This is done for convenience, however, so that the programmer doesn’t have to deal with unevaluated applications of nameless block constructs in normal form terms. The case of named local functions is considered different because it effectively represents a local rewriting system which should be treated accordingly, in order to allow for symbolic evaluation.</p>
<p><a name="special-forms"></a></p>
<h3 id="special-forms">Special Forms</h3>
<p>As already mentioned, some operations are actually implemented as special forms which process some or all of their arguments using call-by-name.</p>
<dl>
<dt><code>if x then y else z</code></dt>
<dd>The conditional expression is a special form with call-by-name arguments <code>y</code> and <code>z</code>; only one of the branches is actually evaluated, depending on the value of <code>x</code>.
</dd>
<dt><a name="&&/special"></a><code>x &amp;&amp; y</code>, <a name="||/special"></a><code>x || y</code></dt>
<dd><p>The logical connectives evaluate their operands in <strong>short-circuit mode</strong>. Thus the second operand is passed by name and will only be evaluated if the first operand fails to determine the value of the expression. For instance, <code>x&amp;&amp;y</code> immediately becomes false if <code>x</code> evaluates to false; otherwise <code>y</code> is evaluated to give the value of the expression. The built-in definitions of these operations work as if they were defined by the following equations (but note that the second operand is indeed passed by name):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">x::<span class="dt">int</span> &amp;&amp; y = <span class="kw">if</span> x <span class="kw">then</span> y <span class="kw">else</span> x;
x::<span class="dt">int</span> || y = <span class="kw">if</span> x <span class="kw">then</span> x <span class="kw">else</span> y;</code></pre></div>
<p>Note that this isn’t quite the same as in C, as the results of these operations are <em>not</em> normalized, i.e., they may return nonzero values other than 1 to denote “true”. (This has the advantage that these operations can be implemented tail-recursively, see <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>.) Thus, if you need a normalized truth value then you’ll have to make sure that either both operands are already normalized, or you’ll have to normalize the result yourself. (A quick way to turn a machine int <code>x</code> into a normalized truth value is to compute <code>~~x</code> or <code>x~=0</code>.)</p>
<p>Moreover, if the built-in definition fails because the first operand is not a machine int, then the second operand will be evaluated anyway and the resulting application becomes a normal form, which gives you the opportunity to extend these operations with your own definitions just like the other built-in operations. Note, however, that in this case the operands are effectively passed by value.</p>
</dd>
<dt><a name="$$"></a><code>x $$ y</code></dt>
<dd><p>The sequencing operator <a href="#$$"><code>$$</code></a> evaluates its left operand, immediately throws the result away and then goes on to evaluate the right operand which gives the result of the entire expression. This operator is useful to write imperative-style code such as the following prompt-input interaction:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; puts <span class="st">&quot;Enter a number:&quot;</span> $$ scanf <span class="st">&quot;%g&quot;</span>;
Enter a number:
<span class="dv">21</span>
<span class="dv">21.0</span></code></pre></div>
<p>We mention in passing here that the same effect can be achieved with a <a href="#when"><code>when</code></a> clause, which also allows you to execute a function solely for its side-effects and just ignore the return value:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; scanf <span class="st">&quot;%g&quot;</span> <span class="kw">when</span> puts <span class="st">&quot;Enter a number:&quot;</span> <span class="kw">end</span>;
Enter a number:
<span class="dv">21</span>
<span class="dv">21.0</span></code></pre></div>
</dd>
<dt><a name="&"></a><code>x &amp;</code></dt>
<dd><p>The <a href="#&amp;"><code>&amp;</code></a> operator does lazy evaluation. This is the only postfix operator defined in the standard prelude. It turns its operand into a kind of parameterless anonymous closure, deferring its evaluation. These kinds of objects are also commonly known as <strong>thunks</strong> or <strong>futures</strong>. When the value of a future is actually needed (during pattern-matching, or when the value becomes an argument of a C call), it is evaluated automatically and gets memoized, i.e., the computed result replaces the thunk so that it only has to be computed once.</p>
<p>Futures are useful to implement all kinds of lazy data structures in Pure, in particular: lazy lists a.k.a. streams. A <strong>stream</strong> is simply a list with a thunked tail, which allows it to be infinite. The Pure prelude defines many functions for creating and manipulating these kinds of objects; for further details and examples please <a href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a> in the <a href="#examples">Examples</a> section.</p>
</dd>
<dt><a name="quote"></a><code>quote x</code>, <a name="'"></a><code>' x</code></dt>
<dd><p>This special form quotes an expression, i.e., <code>quote x</code> (or, equivalently, <code>'x</code>) returns just <code>x</code> itself without evaluating it. The prelude also provides a function <a href="purelib.html#eval"><code>eval</code></a> which can be used to evaluate a quoted expression at a later time. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = &#39;(<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span>); x;
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span>
&gt; eval x;
<span class="dv">4180.0</span></code></pre></div>
<p>This enables some powerful metaprogramming techniques, which should be well familiar to Lisp programmers. However, there are some notable differences to Lisp’s quote, please see <a href="#the-quote">The Quote</a> in the <a href="#examples">Examples</a> section for details and more examples.</p>
</dd>
</dl>
<!-- -->
<p><a name="def"></a></p>
<p><a name="let"></a></p>
<p><a name="const"></a></p>
<p><a name="otherwise"></a></p>
<h3 id="toplevel">Toplevel</h3>
<p>At the toplevel, a Pure program basically consists of rewriting rules (which are used to define functions, macros and types), constant and variable definitions, and expressions to be evaluated:</p>
<pre class="sourceCode bnf"><code>script : item*
item : &quot;let&quot; simple_rule &quot;;&quot;
    | &quot;const&quot; simple_rule &quot;;&quot;
    | &quot;def&quot; macro_rule &quot;;&quot;
    | &quot;type&quot; type_rule &quot;;&quot;
    | rule &quot;;&quot;
    | expr &quot;;&quot;</code></pre>
<p>These elements are discussed in more detail in the <a href="#rule-syntax">Rule Syntax</a> section. Also, a few additional toplevel elements are part of the declaration syntax, see <a href="#declarations">Declarations</a>.</p>
<dl>
<dt><code>lhs = rhs;</code></dt>
<dd>Rewriting rules always combine a left-hand side pattern (which must be a simple expression) and a right-hand side (which can be any kind of Pure expression described above). The same format is also used in <a href="#with"><code>with</code></a>, <a href="#when"><code>when</code></a> and <a href="#case"><code>case</code></a> expressions. In toplevel rules, <a href="#with"><code>with</code></a> and <a href="#case"><code>case</code></a> expressions, this basic form can also be augmented with a condition <code>if guard</code> tacked on to the end of the rule, where <code>guard</code> is an integer expression which determines whether the rule is applicable. Moreover, the keyword <a href="#otherwise"><code>otherwise</code></a> may be used to denote an empty guard which is always true (this is syntactic sugar to point out the “default” case of a definition; the interpreter just treats this as a comment). Pure also provides some abbreviations for factoring out common left-hand or right-hand sides in collections of rules; see the <a href="#rule-syntax">Rule Syntax</a> section for details.
</dd>
<dt><code>type lhs = rhs;</code></dt>
<dd>A rule starting with the keyword <a href="#type"><code>type</code></a> defines a type predicate. This works pretty much like an ordinary rewriting rule, except that only a single right-hand side is permitted (which may also be omitted in some cases) and the left-hand side may involve at most one argument expression; see the <a href="#type-rules">Type Rules</a> section for details. There’s also an alternative syntax which lets you define types in a more abstract way and have the compiler generate the type rules for you; this is described in the <a href="#interface-types">Interface Types</a> section.
</dd>
<dt><code>def lhs = rhs;</code></dt>
<dd>A rule starting with the keyword <a href="#def"><code>def</code></a> defines a macro function. No guards or multiple right-hand sides are permitted here. Macro rules are used to preprocess expressions on the right-hand side of other definitions at compile time, and are typically employed to implement user-defined special forms and simple kinds of optimization rules. See the <a href="#macros">Macros</a> section below for details and examples.
</dd>
<dt><code>let lhs = rhs;</code></dt>
<dd>Binds every variable in the left-hand side pattern to the corresponding subterm of the right-hand side (after evaluating it). This works like a <a href="#when"><code>when</code></a> clause, but serves to bind global variables occurring free on the right-hand side of other function and variable definitions.
</dd>
<dt><code>const lhs = rhs;</code></dt>
<dd>An alternative form of <a href="#let"><code>let</code></a> which defines constants rather than variables. (These are not to be confused with nonfix symbols which simply stand for themselves!) Like <a href="#let"><code>let</code></a>, this construct binds the variable symbols on the left-hand side to the corresponding values on the right-hand side (after evaluation). The difference is that <a href="#const"><code>const</code></a> symbols can only be defined once, and thus their values do not change during program execution. This also allows the compiler to apply some special optimizations such as constant folding.
</dd>
<dt><code>expr;</code></dt>
<dd>A singleton expression at the toplevel, terminated with a semicolon, simply causes the given value to be evaluated (and the result to be printed, when running in interactive mode).
</dd>
</dl>
<!-- -->
<h3 id="scoping-rules">Scoping Rules</h3>
<p>A few remarks about the scope of identifiers and other symbols are in order here. <a href="#special-expressions">Special expressions</a> introduce <strong>local scopes</strong> of functions and variables. Specifically, lambda expressions, as well as the left-hand sides of rules in <code>case</code>, <code>when</code> and <code>with</code> expressions, bind the variables in the patterns to their corresponding values. In addition, a <code>with</code> expression also binds function names to the corresponding functions defined by the rules given in the expression. In either case, these bindings are limited to the scope of the corresponding construct. Inside that scope they override other (global or local) definitions of the same symbols which may be present in the surrounding program code. This gives rise to a hierarchical <strong>block structure</strong> where each occurrence of a symbol refers to the innermost definition of that symbol visible at that point of the program.</p>
<p>The precise scoping rules for the different constructs are as follows:</p>
<ul>
<li><code>\x -&gt; y</code>: The scope of the variables bound by the pattern <code>x</code> is the lambda body <code>y</code>.</li>
<li><code>case x of u = v; ... end</code>: The scope of the variables bound by the pattern <code>u</code> in each rule is the corresponding right-hand side <code>v</code>.</li>
<li><code>x when u = v; ... end</code>: The scope of the variables bound by the pattern <code>u</code> in each rule extends over the right-hand sides of all subsequent rules and the target expression <code>x</code>.</li>
<li><code>x with u = v; ... end</code>: The scope of the variables bound by the pattern <code>u</code> in each rule is the corresponding right-hand side <code>v</code>. In addition, the scope of the <em>function</em> names defined by the <code>with</code> clause (i.e., the head symbols of the rules) extends over the right-hand sides of all rules and the target expression <code>x</code>. Note that this allows local function definitions to be mutually recursive, since the right-hand side of each rule in the <code>with</code> clause may refer to any other function defined by the <code>with</code> clause.</li>
</ul>
<p>Like most modern functional languages, Pure uses <strong>lexical</strong> or <strong>static</strong> binding for local functions and variables. What this means is that the binding of a local name is completely determined at compile time by the surrounding program text, and does not change as the program is being executed. In particular, if a function returns another (anonymous or local) function, the returned function captures the environment it was created in, i.e., it becomes a (lexical) <strong>closure</strong>. For instance, the following function, when invoked with a single argument <code>x</code>, returns another function which adds <code>x</code> to its argument:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = bar <span class="kw">with</span> bar y = x+y <span class="kw">end</span>;
&gt; <span class="kw">let</span> f = foo <span class="dv">99</span>; f;
bar
&gt; f <span class="dv">10</span>, f <span class="dv">20</span>;
<span class="dv">109</span>,<span class="dv">119</span></code></pre></div>
<p>This works the same no matter what other bindings of <code>x</code> may be in effect when the closure is invoked:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = <span class="dv">77</span>; f <span class="dv">10</span>, (f <span class="dv">20</span> <span class="kw">when</span> x = <span class="dv">88</span> <span class="kw">end</span>);
<span class="dv">109</span>,<span class="dv">119</span></code></pre></div>
<p>In contrast to local bindings, Pure’s toplevel environment binds global symbols <strong>dynamically</strong>, so that the bindings can be changed easily at any time during an interactive session. This is mainly a convenience for interactive usage, but works the same no matter whether the source code is entered interactively or being read from a script, in order to ensure consistent behaviour between interactive and batch mode operation.</p>
<p>In particular, you can easily bind a global variable to a new value by just entering a corresponding <a href="#let"><code>let</code></a> command. For instance, contrast the following with the local <code>bar</code> function from above which had the <code>x</code> value bound in the surrounding context:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear x
&gt; bar y = x+y;
&gt; bar <span class="dv">10</span>, bar <span class="dv">20</span>;
x+<span class="dv">10</span>,x+<span class="dv">20</span>
&gt; <span class="kw">let</span> x = <span class="dv">99</span>;
&gt; bar <span class="dv">10</span>, bar <span class="dv">20</span>;
<span class="dv">109</span>,<span class="dv">119</span>
&gt; <span class="kw">let</span> x = <span class="dv">77</span>;
&gt; bar <span class="dv">10</span>, bar <span class="dv">20</span>;
<span class="dv">87</span>,<span class="dv">97</span></code></pre></div>
<p>Observe how changing the value of the global <code>x</code> variable immediately affects the value computed by the global <code>bar</code> function. This works pretty much like global variables in imperative languages, but note that in Pure the value of a global variable can only be changed with a <a href="#let"><code>let</code></a> command at the toplevel. Thus referential transparency is unimpaired; while the value of a global variable may change between different toplevel expressions, it will always take the same value in a single evaluation.</p>
<p>Similarly, you can also add new equations to an existing function at any time. The Pure interpreter will then automatically recompile the function as needed. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">0</span> = <span class="dv">1</span>;
&gt; fact n::<span class="dt">int</span> = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
&gt; fact <span class="dv">10</span>;
<span class="dv">3628800</span>
&gt; fact <span class="dv">10.0</span>;
fact <span class="dv">10.0</span>
&gt; fact <span class="dv">1.0</span> = <span class="dv">1.0</span>;
&gt; fact n::<span class="dt">double</span> = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">1</span>;
&gt; fact <span class="dv">10.0</span>;
<span class="dv">3628800.0</span>
&gt; fact <span class="dv">10</span>;
<span class="dv">3628800</span></code></pre></div>
<p>In interactive mode, it is even possible to completely erase a function definition and redo it from scratch, see section <a href="#interactive-usage">Interactive Usage</a> for details.</p>
<p>So, while the meaning of a local symbol never changes once its definition has been processed, toplevel definitions may well evolve while the program is being processed, and the interpreter will always use the latest definitions at a given point in the source when an expression is evaluated.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> As already mentioned, this behaviour makes Pure much more convenient to use in an interactive setting. We should point out, however, that dynamic environments are often frowned upon by functional programming purists (for good reasons), and Pure’s dynamic toplevel certainly has its pitfalls just like any other. Specifically, even in a script file you’ll have to take care that all symbols needed in an evaluation are completely defined before entering the expression to be evaluated. Nevertheless, it is expected that most Pure programmers will use Pure interactively most of the time, and so tailoring the design to interactive usage seems justifiable in this case.</p>
</blockquote>
<hr />
<h2 id="rule-syntax">Rule Syntax</h2>
<p>Basically, the same rule syntax is used in all kinds of global and local definitions. However, some constructs (specifically, <a href="#when"><code>when</code></a>, <a href="#let"><code>let</code></a>, <a href="#const"><code>const</code></a>, <a href="#type"><code>type</code></a> and <a href="#def"><code>def</code></a>) use a variation of the basic rule syntax which does away with guards and/or multiple left-hand or right-hand sides. The syntax of these elements is captured by the following grammar rules:</p>
<pre class="sourceCode bnf"><code>rule : pattern (&quot;|&quot; pattern)* &quot;=&quot; expr [guard]
       (&quot;;&quot; &quot;=&quot; expr [guard])*
type_rule : pattern (&quot;|&quot; pattern)* [ &quot;=&quot; expr [guard] ]
macro_rule : pattern (&quot;|&quot; pattern)* &quot;=&quot; expr
simple_rule : pattern &quot;=&quot; expr | expr
pattern : simple_expr
guard : &quot;if&quot; simple_expr
    | &quot;otherwise&quot;
    | guard &quot;when&quot; simple_rules &quot;end&quot;
    | guard &quot;with&quot; rules &quot;end&quot;</code></pre>
<p>When matching against a function or macro call, or the subject term in a <a href="#case"><code>case</code></a> expression, the rules are always considered in the order in which they are written, and the first matching rule (whose guard evaluates to a nonzero value, if applicable) is picked. (Again, the <a href="#when"><code>when</code></a> construct is treated differently, because each rule is actually a separate definition.)</p>
<h3 id="patterns">Patterns</h3>
<p>The left-hand side of a rule is a special kind of simple expression, called a <strong>pattern</strong>. The variables in a pattern serve as placeholders which are bound to corresponding values when the rule is applied to a target expression. To these ends, the pattern is <strong>matched</strong> against the target expression, i.e., the literal parts of the pattern are compared against the target expression and, if everything matches up, the variables in the pattern are <strong>bound</strong> to (set to the value of) the corresponding subterms of the target expression.</p>
<p>Patterns are pervasive in Pure; they are used on the left-hand side of function and macro definitions, just as well as in global and local variable definitions. For instance, the following variable definition matches the result of evaluating the right-hand side list expression against the pattern <code>x:y:xs</code> and binds the variables <code>x</code> and <code>y</code> to the first two elements of the resulting list and <code>xs</code> to the list of remaining elements, respectively. We can then place <code>x</code> and <code>y</code> at the end of the list, thereby performing a kind of “rotation” of the first two list members:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x:y:xs = <span class="dv">1</span>..<span class="dv">10</span>;
&gt; xs+[x,y];
[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">1</span>,<span class="dv">2</span>]</code></pre></div>
<p>The same works with a local variable definition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; xs+[x,y] <span class="kw">when</span> x:y:xs = <span class="dv">1</span>..<span class="dv">10</span> <span class="kw">end</span>;
[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">1</span>,<span class="dv">2</span>]</code></pre></div>
<p>Or with a <a href="#case"><code>case</code></a> expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">case</span> <span class="dv">1</span>..<span class="dv">10</span> <span class="kw">of</span> x:y:xs = xs+[x,y] <span class="kw">end</span>;
[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">1</span>,<span class="dv">2</span>]</code></pre></div>
<p>The arguments of functions (and macros) are handled in the same fashion, too:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rot2 (x:y:xs) = xs+[x,y];
&gt; rot2 (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">1</span>,<span class="dv">2</span>]</code></pre></div>
<p>However, there is a big difference here. For global and local variable definitions, it is an error if the pattern does not match the target expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x:y:xs = [<span class="dv">1</span>];
&lt;stdin&gt;, line <span class="dv">7</span>: failed match while evaluating &#39;let x:y:xs = [<span class="dv">1</span>]&#39;</code></pre></div>
<p>The same holds if the target expression doesn’t match any of the left-hand side patterns in a <a href="#case"><code>case</code></a> expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">case</span> [<span class="dv">1</span>] <span class="kw">of</span> x:y:xs = xs+[x,y] <span class="kw">end</span>;
&lt;stdin&gt;, line <span class="dv">8</span>: unhandled exception &#39;failed_match&#39; while evaluating
&#39;case [<span class="dv">1</span>] <span class="kw">of</span> x:y:xs = xs+[x,y] end&#39;</code></pre></div>
<p>(The error message is slightly different in this case, but the reported kind of exception is actually the same as with the <a href="#let"><code>let</code></a> expression above.)</p>
<p>This doesn’t normally happen with functions and macros. Instead, a match failure just means that the corresponding rule will be bypassed and other rules will be tried instead. If there are no more rules, the target expression becomes a normal form which is simply returned as is:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rot2 [<span class="dv">1</span>];
rot2 [<span class="dv">1</span>]</code></pre></div>
<p>This may come as a surprise (other functional languages will give you an error in such cases), but is a crucial feature of term rewriting languages, as it opens the door to symbolic evaluation techniques, see <a href="#definitions-and-expression-evaluation">Definitions and Expression Evaluation</a>.</p>
<p>There are two different ways to force a function definition to bail out with an error if you prefer that behaviour. First, you can provide an explicit rule which raises an exception (cf. <a href="#exception-handling">Exception Handling</a>). But this can make it difficult or even impossible to add more rules to the function later, as discussed below. Instead, you may want to use the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragma as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --defined rot2
&gt; rot2 [<span class="dv">1</span>];
&lt;stdin&gt;, line <span class="dv">13</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;rot2 [<span class="dv">1</span>]&#39;</code></pre></div>
<hr />
<blockquote>
<p><strong>Note:</strong> This pragma tells the compiler that <code>rot2</code> is supposed to be a “defined” function, which means that it should be an error if no rule applies to it; please see <a href="#defined-functions">Defined Functions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for details. Also note that exceptions will always interfere with symbolic evaluation and thus the use of this facility isn’t really recommended. However, there are situations in which it can make your life a lot easier.</p>
</blockquote>
<hr />
<p>One of Pure’s key features is that you can usually just keep on adding new rules to existing function definitions in order to handle different kinds of arguments. As already mentioned, the rules will then be considered in the order in which they are written, and the first rule which matches the given arguments will be used to reduce the function application. For instance, adding the following rule we can make the <code>rot2</code> function also work with tuples:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rot2 (x,y,xs) = xs,x,y;
&gt; rot2 (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>);
<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span></code></pre></div>
<p>This is also known as <strong>ad-hoc polymorphism</strong>. By these means, you can make a function apply to as many different kinds of arguments as you want, and the pattern matching handles the necessary “dispatching” so that the right rule gets invoked for the provided arguments.</p>
<p>Pattern matching is not limited to the predefined aggregates such as lists, tuples and matrices. In principle, any legal Pure expression can occur as a pattern on the left-hand side of a rule or definition, so you can also write something like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rot2 (point x y z) = point z x y;
&gt; rot2 (point <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>);
point <span class="dv">3</span> <span class="dv">1</span> <span class="dv">2</span></code></pre></div>
<p>Or even:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo (foo x) = foo x;
&gt; bar (foo x) = foo (bar x);
&gt; foo (bar (foo <span class="dv">99</span>));
foo (bar <span class="dv">99</span>)</code></pre></div>
<p>Note that symbolic rules like in the latter example (which in this case express the idempotence of <code>foo</code> and a kind of commutativity with respect to <code>bar</code>) often involve symbols which play the role of both a function <em>and</em> a constructor symbol.</p>
<p>Syntactically, patterns are <a href="#simple-expressions">simple expressions</a>, thus <a href="#special-expressions">special expressions</a> need to be parenthesized if you want to include them in a pattern. (In fact, special expressions are given special treatment if they occur in patterns, see the <a href="#macros">Macros</a> section for details.) A few other special elements in patterns are discussed below.</p>
<h4 id="the-head-function-rule">The “Head = Function” Rule</h4>
<p>A central ingredient of all patterns are of course the variables which get bound in the pattern matching process. Pure is a rather terse language and thus it has no explicit way to declare which identifiers are the variables. Instead, the compiler figures them out on its own, using a rather intuitive rule already explained in <a href="#variables-in-equations">Variables in Equations</a>.</p>
<p>Recall that the variables in a pattern are the identifiers in “variable positions”. The <strong>head = function</strong> rule tells us that a variable position is any leaf (atomic subexpression) of the expression tree which is <em>not</em> the head symbol of a function application. Thus a pattern like <code>f (g x) y</code> contains the variables <code>x</code> and <code>y</code>, whereas <code>f</code> and <code>g</code> are interpreted as literal function symbols. This rule also applies to the case of infix, prefix or postfix operator symbols, if we write the corresponding application in its unsugared form. E.g., <code>x+y*z</code> is equivalent to <code>(+) x ((*) y z)</code> which contains the variables <code>x</code>, <code>y</code> and <code>z</code> and the literal function symbols <code>(+)</code> and <code>(*)</code>.</p>
<p>There are some exceptions to the “head = function” rule. Specifically, it is possible to declare an identifier as a <a href="#nonfix"><code>nonfix</code></a> symbol so that it will be interpreted as a literal function symbol even if it occurs in a variable position, see <a href="#symbol-declarations">Symbol Declarations</a> for details. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;
foo nil = <span class="dv">0</span>;</code></pre></div>
<p>Note that since <code>nil</code> is declared as a <a href="#nonfix"><code>nonfix</code></a> symbol here, the symbol is interpreted as a literal rather than a variable in the left-hand side <code>foo nil</code>, and thus <code>foo</code> will return <code>0</code> for a literal <code>nil</code> value only.</p>
<p>Another case which needs special consideration are patterns consisting of a single identifier, such as <code>x</code>. Here the meaning depends on the kind of construct. All variable-binding constructs (<a href="#let"><code>let</code></a>, <a href="#const"><code>const</code></a>, <a href="#when"><code>when</code></a> and <a href="#case"><code>case</code></a>) treat a singleton identifier as a variable (unless it is declared <a href="#nonfix"><code>nonfix</code></a>). Thus all of the following constructs will have the expected result of binding the variable <code>x</code> to the given list value <code>[1,2,3]</code>. In either case the result is <code>[0,1,2,3]</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> x = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]; <span class="dv">0</span>:x;
<span class="dv">0</span>:x <span class="kw">when</span> x = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="kw">end</span>;
<span class="kw">case</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="kw">of</span> x = <span class="dv">0</span>:x <span class="kw">end</span>;</code></pre></div>
<p>In contrast, a single identifier is always interpreted as a literal if it occurs on the left-hand side of a function or macro definition, so that the following rule defines a parameterless function <code>y</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">y = [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]; <span class="dv">0</span>:y;</code></pre></div>
<p>(While they yield the same values here, there are some notable differences between the parameterless function <code>y</code> and the global variable <code>x</code> defined above; see <a href="#defining-functions">Defining Functions</a> for details.)</p>
<p>Please also check <a href="#head-function-pitfalls">“Head = Function” Pitfalls</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section which has some some further interesting details and workarounds concerning the “head = function” rule.</p>
<h4 id="constant-patterns">Constant Patterns</h4>
<p>Constants in patterns must be matched literally. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo <span class="dv">0</span> = <span class="dv">1</span>;</code></pre></div>
<p>This will only match an application of <code>foo</code> to the machine integer <code>0</code>, not <code>0.0</code> or <code>0L</code> (even though these compare equal to <code>0</code> using the ‘<a href="purelib.html#=="><code>==</code></a>’ operator).</p>
<h4 id="the-anonymous-variable">The Anonymous Variable</h4>
<p>The ‘<code>_</code>’ symbol is special in patterns; it denotes the <strong>anonymous variable</strong> which matches an arbitrary value (independently for all occurrences) without actually binding a variable. This is useful if you don’t care about an argument or one of its components, in which case you can just use the anonymous variable as a placeholder for the value and don’t have to invent a variable name for it. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo _ _ = <span class="dv">0</span>;</code></pre></div>
<p>This will match the application of <code>foo</code> to any combination of two arguments (and just ignore the values of these arguments).</p>
<p><a name="syntactic-equality"></a></p>
<h4 id="non-linear-patterns-and-syntactic-equality">Non-Linear Patterns and Syntactic Equality</h4>
<p>In contrast to Haskell, patterns may contain repeated variables (other than the anonymous variable), i.e., they may be <strong>non-linear</strong>. Thus rules like the following are legal in Pure, and will only be matched if all occurrences of the same variable in the left-hand side pattern are matched to the same value:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x x = x;
&gt; foo <span class="dv">1</span> <span class="dv">1</span>;
<span class="dv">1</span>
&gt; foo <span class="dv">1</span> <span class="dv">2</span>;
foo <span class="dv">1</span> <span class="dv">2</span></code></pre></div>
<p>Non-linear patterns are particularly useful for computer algebra where you will frequently encounter rules such as the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x*y+x*z = x*(y+z);
&gt; a*(<span class="dv">3</span>*<span class="dv">4</span>)+a*<span class="dv">5</span>;
a*<span class="dv">17</span></code></pre></div>
<p>The notion of “sameness” employed here is that of syntactical identity, which means that the matched subterms must be identical in structure and content. The prelude provides syntactic equality as a function <a href="purelib.html#same"><code>same</code></a> and a comparison predicate ‘<a href="purelib.html#==="><code>===</code></a>’. Thus the above definition of <code>foo</code> is roughly equivalent to the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x y = x <span class="kw">if</span> same x y;</code></pre></div>
<p>It is important to note the differences between syntactic equality embodied by <a href="purelib.html#same"><code>same</code></a> and ‘<a href="purelib.html#==="><code>===</code></a>’, and the “semantic” equality operator ‘<a href="purelib.html#=="><code>==</code></a>’. The former are always defined on all terms, whereas ‘<a href="purelib.html#=="><code>==</code></a>’ is only available on data where it has been defined explicitly, either in the prelude or by the programmer. Also note that ‘<a href="purelib.html#=="><code>==</code></a>’ may assert that two terms are equal even if they are syntactically different. Consider, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">0</span>==<span class="dv">0.0</span>;
<span class="dv">1</span>
&gt; <span class="dv">0</span>===<span class="dv">0.0</span>;
<span class="dv">0</span></code></pre></div>
<p>This distinction is actually quite useful. It gives the programmer the flexibility to define ‘<a href="purelib.html#=="><code>==</code></a>’ in any way that he sees fit, which is consistent with the way the other comparison operators like ‘<a href="purelib.html#%3C"><code>&lt;</code></a>’ and ‘<a href="purelib.html#%3E"><code>&gt;</code></a>’ are handled in Pure.</p>
<p>Syntactic equality is also used in pattern matching in order to decide whether a constant in a pattern matches the corresponding subterm in the target expression. This explains why the pattern <code>foo 0</code>, as already mentioned, only matches an application of <code>foo</code> to the machine integer <code>0</code>, not <code>0.0</code> or <code>0L</code> which aren’t syntactically equal to <code>0</code>.</p>
<p>However, there is one caveat here. Due to its term rewriting heritage, Pure distinguishes between literal function symbols in patterns and named functions. The latter are runtime objects which are only considered syntactically equal if they not only have the same name but actually refer to the same (global or local) closure. In contrast, a function symbol in a pattern is just a literal symbol without reference to any particular closure that the symbol may be bound to in some context. Thus a function symbol in a pattern matches <em>any</em> instance of the symbol in the target expression, no matter whether it happens to be a pure constructor, quoted symbol or any named closure bound to that symbol.</p>
<p>This leads to some discrepancies between pattern matching and syntactic equality which may be surprising at first sight. For instance, consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = <span class="kw">case</span> x <span class="kw">of</span> bar y = x===bar y <span class="kw">end</span>;
&gt; bar x y = x+y;
&gt; foo (bar <span class="dv">99</span>);
<span class="dv">1</span>
&gt; foo (&#39;bar <span class="dv">99</span>);
<span class="dv">0</span>
&gt; foo (bar <span class="dv">99</span>) <span class="kw">with</span> bar x y = x*y <span class="kw">end</span>;
<span class="dv">0</span></code></pre></div>
<p>Note that the argument term <code>bar 99</code> matches the pattern <code>bar y</code> in the <a href="#case"><code>case</code></a> expression in either case, even though in the last two expressions <code>bar</code> is <em>not</em> considered syntactically equal to the global <code>bar</code> function because it is quoted (cf. <a href="#the-quote">The Quote</a>) or bound to a local closure of the same name, respectively.</p>
<h4 id="special-patterns">Special Patterns</h4>
<p>Last but not least, patterns may also contain the following special elements which are not permitted in right-hand side expressions:</p>
<ul>
<li>A Haskell-style <strong>“as” pattern</strong> of the form <em>variable</em> <code>@</code> <em>pattern</em> binds the given variable to the expression matched by the subpattern <em>pattern</em> (in addition to the variables bound by <em>pattern</em> itself). This is convenient if the value matched by the subpattern is to be used on the right-hand side of an equation.</li>
<li>A left-hand side variable (including the anonymous variable) may be followed by a <strong>type tag</strong> of the form <code>::</code> <em>name</em>, where <em>name</em> is either one of the built-in type symbols <code>int</code>, <code>bigint</code>, <code>double</code>, <code>string</code>, <code>matrix</code>, <code>pointer</code>, or an identifier denoting a user-defined data type. The variable can then match only values of the designated type. Thus, for instance, ‘<code>x::int</code>’ only matches machine integers. See the <a href="#type-tags">Type Tags</a> section below for details.</li>
</ul>
<p>To these ends, the expression syntax is augmented with the following grammar rule (but note that this form of expression is in fact only allowed on the left-hand side of a rule):</p>
<pre class="sourceCode bnf"><code>prim_expr : qualified_identifier
       (&quot;::&quot; qualified_identifier | &quot;@&quot; prim_expr)</code></pre>
<p>As shown, both “as” patterns and type tags are primary expressions, and the subpattern of an “as” pattern is a primary expression, too. Thus, if a compound expression is to be used as the subpattern, it <em>must</em> be parenthesized. For instance, the following function duplicates the head element of a list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo xs@(x:_) = x:xs;</code></pre></div>
<p>Note that if you accidentally forget the parentheses around the subpattern <code>x:_</code>, you still get a syntactically correct definition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo xs@x:_ = x:xs;</code></pre></div>
<p>But this gets parsed as <code>(foo xs@x):_ = x:xs</code>, which is most certainly <em>not</em> what you want. It is thus a good idea to just always enclose the subpattern with parentheses in order to prevent such glitches.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> Another pitfall is that the notation <code>foo::bar</code> is also used to denote “qualified symbols” in Pure, cf. <a href="#namespaces">Namespaces</a>. Usually this will be resolved correctly, but if <code>foo</code> happens to also be a valid namespace then most likely you’ll get an error message about an undeclared symbol. You can always work around this by adding spaces around the ‘<code>::</code>’ symbol, as in <code>foo :: bar</code>. Spaces are never permitted in qualified symbols, so this makes it clear that the construct denotes a type tag. The same applies if the variable or the tag is a qualified identifier; in this case they should always be separated by whitespace.</p>
</blockquote>
<hr />
<p><a name="type-tags"></a></p>
<h3 id="type-tags">Type Tags</h3>
<p>Like Lisp, Pure is essentially a typeless language and doesn’t really have a built-in notion of “data types”. Rather, all data belongs to the same universe of terms. However, for convenience it is possible to describe data domains by means of (unary) type <em>predicates</em> which may denote arbitrary sets of terms. The names of these type predicates can then be used as <strong>type tags</strong> on variables, so that they can only be matched by values of the given type.</p>
<p>We have to emphasize here that Pure’s notion of types has nothing to do with static typing. Type tags are merely used at runtime to restrict the kind of data that can be matched by a rule (and by the compiler to generate better code in some cases). But they will never cause the compiler to impose a static typing discipline and spit out corresponding “type errors”. (This wouldn’t make any sense in Pure anyway, as failure to match any of the rules given in the definition of a function simply means that a function application is in normal form.)</p>
<p>Some basic types are built into the language. The corresponding tags enable you to match the built-in types of terms for which there is no way to spell out all “constructors”, as there are infinitely many (or none, as in the case of <a href="#pointer/type"><code>pointer</code></a> values which are constructed and inspected using special primitives, but are otherwise “opaque” at the Pure level). Specifically, the following data types are built-in (in fact, the pattern matcher has special knowledge about these so that they can be matched very efficiently):</p>
<dl>
<dt><a name="int/type"></a><em>type</em> <code>int</code></dt>
<dd>The type of machine integers.
</dd>
<dt><a name="bigint/type"></a><em>type</em> <code>bigint</code></dt>
<dd>The type of arbitrary precision integers (GMP bigints).
</dd>
<dt><a name="double/type"></a><em>type</em> <code>double</code></dt>
<dd>The type of double precision floating point numbers.
</dd>
<dt><a name="string/type"></a><em>type</em> <code>string</code></dt>
<dd>The type of character strings.
</dd>
<dt><a name="matrix/type"></a><em>type</em> <code>matrix</code></dt>
<dd>The type of all numeric and symbolic matrix values.
</dd>
<dt><a name="pointer/type"></a><em>type</em> <code>pointer</code></dt>
<dd>The type of C pointer values.
</dd>
</dl>
<!-- -->
<p>Pure’s standard library provides additional data types along with the corresponding operations, such as rational and complex numbers, lists, tuples and the container data types (sets, dictionaries, etc.). These are all described in the <a href="purelib.html">Pure Library Manual</a>.</p>
<p>You can define your own data types using a special kind of rule syntax which is explained in <a href="#type-rules">Type Rules</a> below. For instance, we might represent points in the plane using a constructor symbol <code>Point</code> which gets applied to pairs of coordinates. We can then define the <code>point</code> data type as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> point (Point x y);</code></pre></div>
<p>This introduces the type symbol <code>point</code> and specifies that this type consists of terms of the form <code>Point x y</code>. We can now equip this data type with an operation <code>point</code> to construct a point from its coordinates, two operations <code>xcoord</code> and <code>ycoord</code> to retrieve the coordinates, and an operation <code>move</code> to change the coordinates to the given values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">point x y = Point x y;
xcoord (Point x y) = x;
ycoord (Point x y) = y;
move (Point _ _) x y = Point x y;</code></pre></div>
<p>Next we might define a function <code>translate</code> which shifts the coordinates of a point by a given amount in the x and y directions as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">translate x y p::point = move p (xcoord p+x) (ycoord p+y);</code></pre></div>
<p>Note the use of <code>point</code> as a type tag on the <code>p</code> variable. By these means, we can ensure that the argument is actually an instance of the point data type we just defined. The type tag acts just like an extra guard of the equation defining <code>translate</code>, but all the necessary type checking is done automatically during pattern matching. This is often more convenient (and, depending on the implementation, the compiler may generate more efficient code for a type tag than for an ordinary guard).</p>
<p>The <code>translate</code> function can be invoked as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> p::point = point <span class="dv">3</span> <span class="dv">3</span>;
&gt; p; translate <span class="dv">1</span> <span class="dv">2</span> p;
Point <span class="dv">3</span> <span class="dv">3</span>
Point <span class="dv">4</span> <span class="dv">5</span></code></pre></div>
<p>One important point to note here is that <code>translate</code> can be defined without knowing or assuming <em>anything</em> about the internal representation of the <code>point</code> data type. We have defined <code>point</code> as a <strong>concrete data type</strong> in this example, making its constructor and internal structure visible in the rest of the program. This is often convenient, but the <code>Point</code> constructor might just as well be hidden by making it a private member of some namespace (cf. <a href="#namespaces">Namespaces</a>), so that all accesses to the data structure would have to be done through the provided operations. Such a data type is also known as an <strong>abstract data type</strong> (ADT).</p>
<hr />
<blockquote>
<p><strong>Note:</strong> As we’ve already seen, Pure has some powerful capabilities which enable you to write functions to inspect and manipulate terms in a completely generic fashion. Thus the internal structure of term data is never truly opaque in Pure and it is always possible to break the “abstraction barrier” provided by an ADT. But if the user of an ADT plays such dirty tricks to wreak havoc on the internal representation of an ADT, he gets what he deserves.</p>
</blockquote>
<hr />
<p>Pure provides some additional facilities to ease the handling of abstract data types. Specifically, instead of defining <code>point</code> as a concrete data type using a <a href="#type"><code>type</code></a> rule, we might also specify it as an <strong>interface type</strong> which merely lists the supported operations as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> point <span class="kw">with</span>
  xcoord p::point;
  ycoord p::point;
  move p::point x y;
<span class="kw">end</span>;</code></pre></div>
<p>We can implement this type the same way as before:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">point x y = Point x y;
xcoord (Point x y) = x;
ycoord (Point x y) = y;
move (Point _ _) x y = Point x y;</code></pre></div>
<p>The definition of the <code>translate</code> function is also unchanged:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">translate x y p::point = move p (xcoord p+x) (ycoord p+y);</code></pre></div>
<p>The difference is that now the structure of members of the type is not made explicit <em>anywhere</em> in the definition of the type. Instead, the compiler figures out which data matches the <code>point</code> tag on its own. We can check the actual term patterns making up the <code>point</code> type with the <code>show interface</code> command:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show <span class="kw">interface</span> point
<span class="kw">type</span> point (Point x y);</code></pre></div>
<p>As you can see, the compiler derived our previous definition of the type. But in fact <code>translate</code> will now work with <em>any</em> data type which implements the <code>point</code> interface (i.e., provides the <code>xcoord</code>, <code>ycoord</code> and <code>move</code> operations), so we may swap out the underlying data structure on a whim. For instance, if we’d like to use vectors instead of constructor terms, all we have to do is to provide a corresponding construction function and implement the interface operations:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">vpoint x y = {x,y};
xcoord {x,y} = x;
ycoord {x,y} = y;
move {_,_} x y = {x,y};</code></pre></div>
<p>After these definitions the new data representation works just fine with existing <code>point</code> operations such as <code>translate</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show <span class="kw">interface</span> point
<span class="kw">type</span> point (Point x y);
<span class="kw">type</span> point {x,y};
&gt; <span class="kw">let</span> p::point = vpoint <span class="dv">3</span> <span class="dv">3</span>;
&gt; p; translate (<span class="dv">1</span>,<span class="dv">2</span>) p;
{<span class="dv">3</span>,<span class="dv">3</span>}
{<span class="dv">4</span>,<span class="dv">5</span>}</code></pre></div>
<p>This separation of interface and implementation of a data structure is an important ingredient of software engineering techniques. More examples and detailed explanations of Pure’s notions of type predicates and interface types can be found in the <a href="#type-rules">Type Rules</a> and <a href="#interface-types">Interface Types</a> sections.</p>
<h3 id="general-rules">General Rules</h3>
<p>The most general type of rule, used in function definitions and <a href="#case"><code>case</code></a> expressions, consists of a left-hand side pattern, a right-hand side expression and an optional guard. The left-hand side of a rule can be omitted if it is the same as for the previous rule. This provides a convenient means to write out a collection of equations for the same left-hand side which discriminates over different conditions:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">lhs       = rhs <span class="kw">if</span> guard;
          = rhs <span class="kw">if</span> guard;
          ...
          = rhs <span class="kw">otherwise</span>;</code></pre></div>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n  = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
        = <span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>This expands to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n  = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
fact n  = <span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>Pure also allows a collection of rules with different left-hand sides but the same right-hand side(s) to be abbreviated as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">lhs       |
          ...
lhs       = rhs;</code></pre></div>
<p>This is useful, e.g., if you specialize a rule to different type tags on the left-hand side variables. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n::<span class="dt">int</span>    |
fact n::<span class="dt">double</span> = n*fact(n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
               = <span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>This expands to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n::<span class="dt">int</span>    = n*fact(n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
               = <span class="dv">1</span> <span class="kw">otherwise</span>;
fact n::<span class="dt">double</span> = n*fact(n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
               = <span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>In fact, the left-hand sides don’t have to be related at all, so you can also write something like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x | bar y = x*y;</code></pre></div>
<p>Which expands to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x = x*y;
bar y = x*y;</code></pre></div>
<p>But more often you’ll have an “as” pattern which binds a common variable to a parameter value after checking that it matches one of several possible argument patterns (which is slightly more efficient than using an equivalent type-checking guard). E.g., the following definition binds the <code>xs</code> variable to the parameter of <code>foo</code>, which may be either the empty list or a list starting with an integer:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo xs@[] | foo xs@(_::<span class="dt">int</span>:_) = bar xs;</code></pre></div>
<p>The <code>|</code> notation also works in <a href="#case"><code>case</code></a> expressions, which is convenient if different cases should be mapped to the same value, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">case</span> ans <span class="kw">of</span> <span class="st">&quot;y&quot;</span> | <span class="st">&quot;Y&quot;</span> = <span class="dv">1</span>; _ = <span class="dv">0</span>; <span class="kw">end</span>;</code></pre></div>
<p>Sometimes it is useful if local definitions (<a href="#when"><code>when</code></a> and <a href="#with"><code>with</code></a>) can be shared by the right-hand side and the guard of a rule. This can be done by placing the local definitions behind the guard, as follows (we only show the case of a single <a href="#when"><code>when</code></a> clause here, but of course there may be any number of <a href="#when"><code>when</code></a> and <a href="#with"><code>with</code></a> clauses behind the guard):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">lhs = rhs <span class="kw">if</span> guard <span class="kw">when</span> defns <span class="kw">end</span>;</code></pre></div>
<p>Note that this is different from the following, which indicates that the definitions only apply to the guard but not the right-hand side of the rule:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">lhs = rhs <span class="kw">if</span> (guard <span class="kw">when</span> defns <span class="kw">end</span>);</code></pre></div>
<p>Conversely, definitions placed <em>before</em> the guard only apply to the right-hand side but not the guard (no parentheses are required in this case):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">lhs = rhs <span class="kw">when</span> defns <span class="kw">end</span> <span class="kw">if</span> guard;</code></pre></div>
<p>An example showing the use of a local variable binding spanning both the right-hand side and the guard of a rule is the following quadratic equation solver, which returns the (real) solutions of the equation <code>x^2+p*x+q = 0</code> if the discriminant <code>d = p^2/4-q</code> is nonnegative:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> math;
&gt; solve p q = -p/<span class="dv">2</span>+sqrt d,-p/<span class="dv">2</span>-sqrt d <span class="kw">if</span> d&gt;=<span class="dv">0</span> <span class="kw">when</span> d = p^<span class="dv">2</span>/<span class="dv">4</span>-q <span class="kw">end</span>;
&gt; solve <span class="dv">4</span> <span class="dv">2</span>; solve <span class="dv">2</span> <span class="dv">4</span>;
-<span class="dv">0.585786437626905</span>,-<span class="dv">3.41421356237309</span>
solve <span class="dv">2</span> <span class="dv">4</span></code></pre></div>
<p>Note that the above definition leaves the case of a negative discriminant undefined.</p>
<h3 id="simple-rules">Simple Rules</h3>
<p>As already mentioned, <a href="#when"><code>when</code></a>, <a href="#let"><code>let</code></a> and <a href="#const"><code>const</code></a> use a simplified kind of rule syntax which just consists of a left-hand and a right-hand side separated by the equals sign. In this case the meaning of the rule is to bind the variables in the left-hand side of the rule to the corresponding subterms of the value of the right-hand side. This is also called a <strong>pattern binding</strong>.</p>
<p>Guards or multiple left-hand or right-hand sides are not permitted in these rules. However, it is possible to omit the left-hand side if it is just the anonymous variable ‘<code>_</code>’ by itself, indicating that you don’t care about the result. The right-hand side is still evaluated, if only for its side-effects, which is handy, e.g., for adding debugging statements to your code. For instance, here is a variation of the quadratic equation solver which also prints the discriminant after it has been computed:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> math, system;
&gt; solve p q = -p/<span class="dv">2</span>+sqrt d,-p/<span class="dv">2</span>-sqrt d <span class="kw">if</span> d&gt;=<span class="dv">0</span>
&gt; <span class="kw">when</span> d = p^<span class="dv">2</span>/<span class="dv">4</span>-q; printf <span class="st">&quot;The discriminant is: %g</span><span class="ch">\n</span><span class="st">&quot;</span> d; <span class="kw">end</span>;
&gt; solve <span class="dv">4</span> <span class="dv">2</span>;
The discriminant is: <span class="dv">2</span>
-<span class="dv">0.585786437626905</span>,-<span class="dv">3.41421356237309</span>
&gt; solve <span class="dv">2</span> <span class="dv">4</span>;
The discriminant is: -<span class="dv">3</span>
solve <span class="dv">2</span> <span class="dv">4</span></code></pre></div>
<p>Note that simple rules of the same form <code>lhs = rhs</code> are also used in macro definitions (<a href="#def"><code>def</code></a>), to be discussed in the <a href="#macros">Macros</a> section. In this case, however, the rule denotes a real rewriting rule, not a pattern binding, hence the left-hand side is mandatory in these rules.</p>
<p><a name="type"></a></p>
<p><a name="type-rules"></a></p>
<h3 id="type-rules">Type Rules</h3>
<p>In Pure the definition of a type takes a somewhat unusual form, since it is not a static declaration of the structure of the type’s members, but rather an arbitrary predicate which determines through a runtime check which terms belong to the type. Thus the definition of a type looks more like an ordinary function definition (and that’s essentially what it is, although types live in their own space where they can’t be confused with functions of the same name).</p>
<p>The definition of a type thus consists of one or more type rules which basically have the same format as the <a href="#general-rules">general rules</a>, but with the keyword <a href="#type"><code>type</code></a> in front of each rule. Also, each left-hand side must have at most one argument pattern and exactly one right-hand side. Hence, if the definition of a type requires several right-hand sides, you normally have to write a separate <a href="#type"><code>type</code></a> rule for each of them. Multiple left-hand sides work the same as in the general rule format, though.</p>
<p>As already mentioned, there is an alternative way for defining types in an indirect way through so-called <a href="#interface-types">interface types</a> from which the corresponding type rules are derived automatically. These are part of Pure’s declaration syntax and thus will be discussed later in the <a href="#declarations">Declarations</a> section. In this section we focus on how you can write your own type rules in order to define types in a direct fashion.</p>
<p>The identifier in the head of the left-hand side of a type rule is the name of the type which can then be used as a type tag in other equations, cf. <a href="#type-tags">Type Tags</a>. This is just a normal, possibly qualified identifier subject to the same namespace mechanisms as other symbols; see <a href="#namespaces">Namespaces</a> for details. However, as the type symbol only gets used as a type tag, it can never collide with function and variable symbols and hence the same symbol can be used both as a type and as a function or variable name.</p>
<p>A collection of type rules specifies a predicate, i.e. a unary, truth-valued function which denotes a set of terms. The type consists precisely of those terms for which the type predicate yields a nonzero result. For instance, the following type defines the type <code>triple</code> as the set of all tuples with exactly three elements:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> triple (x,y,z) = ~tuplep z;</code></pre></div>
<p>Note that the type check consists of two parts here: The left-hand side pattern <code>(x,y,z)</code> restricts the set to all tuples with at least three elements. The right-hand side <code>~tuplep z</code> then verifies that the last component <code>z</code> is not a tuple itself, and thus the entire tuple consists of exactly three elements.</p>
<p>Another important point here is that the definition of the <code>triple</code> predicate is <em>partial</em>, as the given rule only applies to tuples with at least three elements. A value will only match the <code>triple</code> type tag if the predicate explicitly returns <a href="purelib.html#true"><code>true</code></a>; otherwise the match will fail, no matter what the result is (and even if the predicates just fails, i.e., returns an unevaluated normal form). Thus there is no need to make the predicate work on all terms (and in fact there are good reasons to <em>not</em> do so, see below).</p>
<p>In general, you should try to make your type definitions as specific as possible. This makes it possible to extend the predicate later, just like Pure allows you to extend the definition of a function to new types of arguments. For instance, if you later decide that lists with three elements should be considered as triples, too, then you may add the following type rule:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> triple [x,y,z] = true;</code></pre></div>
<p>This makes it possible to define a type in a piecemeal fashion. Each subsequent rule enlarges the term set of the type. Conversely, consider a definition like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> pair x = tuplep x &amp;&amp; #x==<span class="dv">2</span>;</code></pre></div>
<p>In this case the type rule applies to all values <code>x</code> and thus the type definition is complete; there is no way to extend it later. Whether to prefer the former or latter kind of definition depends on the situation. If you want to keep a type extensible, so that you can later make existing definitions of operations on the type work with new data representations, then you should use the former approach, otherwise the latter.</p>
<p>As an example for an extensible type definition, consider the following type <code>nat</code> which denotes the type of positive (machine) integers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> nat x::<span class="dt">int</span> = x&gt;<span class="dv">0</span>;</code></pre></div>
<p>This definition is complete for the case of machine integers, but allows the type to be extended for other base types, and we’ll do that in a moment. But first let’s define the factorial on <code>nat</code> values as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n::nat = <span class="kw">if</span> n==<span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n * fact (n-<span class="dv">1</span>);</code></pre></div>
<p>Note that this definition would loop on zero or negative values if we permitted arbitrary <code>int</code> arguments. But since we restricted the argument type to <code>nat</code>, this case cannot occur and so the definition is safe:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">0</span>;
fact <span class="dv">0</span>
&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>The way we defined <code>fact</code>, it works on positive machine integers, but nothing else:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact 10L;
fact 10L</code></pre></div>
<p>If we later decide that positive bigints should be considered as members of <code>nat</code> as well, we can simply add another rule for the <code>nat</code> type:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> nat x::<span class="dt">bigint</span> = x&gt;<span class="dv">0</span>;</code></pre></div>
<p>Et voila, our <code>fact</code> routine now magically works with bigints, too:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map fact (0L..10L);
[fact 0L,<span class="dv">1</span>,2L,6L,24L,120L,720L,5040L,40320L,362880L,3628800L]</code></pre></div>
<p>Note that we did all this without ever touching our original definition of <code>fact</code>. This works because the <code>bigint</code> data type already provides all the operations which we expect to use with the <code>nat</code> type. Pulling off this trick with other, more exotic kinds of data requires more preparation, since we’ll first have to provide the required operations. In this case, we need at least multiplication, as well as comparisons with 1 and subtraction by 1. For instance, and just for the fun of it, let’s implement our own variation of the <code>nat</code> type using Peano arithmetic:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> nat (s x) = true;

<span class="co">// addition</span>
x + <span class="dv">0</span>   = x;
x + <span class="dv">1</span>   = s x;
x + s y = s (x+y);

<span class="co">// multiplication</span>
x * <span class="dv">0</span>   = <span class="dv">0</span>;
x * <span class="dv">1</span>   = x;
x * s y = x + x*y;

<span class="co">// subtract 1</span>
s x - <span class="dv">1</span> = x;

<span class="co">// comparison with 0 and 1</span>
s x == <span class="dv">0</span> = false;
s x == <span class="dv">1</span> = x == <span class="dv">0</span>;</code></pre></div>
<p>This implements just the bare bones, but that should be enough to make <code>fact</code> work. Let’s give it a try:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact (s (s (s <span class="dv">0</span>)));
s (s (s (s (s (s <span class="dv">0</span>)))))</code></pre></div>
<p>So, counting the <code>s</code>’s, the factorial of 3 is 6. Works! (It goes without saying, though, that this implementation of <code>nat</code> is not very practical; you’ll get mountains of <code>s</code>’s for larger values of <code>n</code>.)</p>
<p>As you can see, a type definition may in general consist of many type rules which may be scattered out over different parts of a program. This works in exactly the same way as with ordinary functions.</p>
<p>There’s an additional convenience provided for type rules, namely that the right-hand side may be omitted if it’s just <a href="purelib.html#true"><code>true</code></a>. For instance, the rule</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> nat (s x) = true;</code></pre></div>
<p>from above can also be written simply as:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> nat (s x);</code></pre></div>
<p>This kind of notation is particularly convenient for “algebraic types” which are usually given by a collection of constructors with different arities. For instance, a binary tree data type might be defined as follows (here we employ the <code>|</code> symbol to separate the different left-hand sides so that we can give all the constructor patterns in one go):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;
<span class="kw">type</span> bintree nil | bintree (bin x left right);</code></pre></div>
<p>This method is also useful if you define your own abstract data types. In this case you’re free to choose any suitable representation, so you might just wrap up all data objects of the type with a special constructor symbol, which makes checking the type simple and efficient. This is also the approach taken in the <code>point</code> example in <a href="#type-tags">Type Tags</a> above, as well as by the container data types in the standard library.</p>
<p>The same notation can also be used to quickly make one type a “subtype” of another, or to create a type which is the union of several existing types. The following example can be found in the standard library:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> integer x::<span class="dt">int</span> | integer x::<span class="dt">bigint</span>;</code></pre></div>
<p>A type rule can also take the form of a function definition without arguments. The corresponding right-hand side may either be another type symbol, or any kind of closure denoting a (curried) type predicate. In this case the defined type is simply an <strong>alias</strong> for the type denoted on the right-hand side. This is often done, e.g., for numeric types, to document that they actually stand for special kinds of quantities:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> speed = <span class="dt">double</span>;
<span class="kw">type</span> size = <span class="dt">int</span>;</code></pre></div>
<p>Note that the definition of a type alias is always complete; there’s no way to extend the corresponding type later. Therefore type aliases are normally resolved at compile time, so that they incur no additional runtime cost. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; half x::speed = x/<span class="dv">2</span>;
&gt; show half
half x::<span class="dt">double</span> = x/<span class="dv">2</span>;</code></pre></div>
<p>(If necessary, this “type folding” can also be disabled with the <a href="#cmdoption-pure--nofold"><code>--nofold</code></a> pragma.)</p>
<p>Finally, it’s also possible to just specify the type name, without giving the right-hand side:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> thing;</code></pre></div>
<p>This doesn’t have any effect other than just declaring the type symbol, so that it can be used as a type tag in subsequent definitions. You then still have to give a proper definition of the type later (either as an explicit predicate or an alias).</p>
<p>Type aliases can also be used to quickly turn an existing predicate into a “convenience” type which can be used as a tag on the left-hand side of equations. The prelude defines a number of these, see <a href="purelib.html#prelude-types">Prelude Types</a>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> closure = closurep;</code></pre></div>
<p>Conversely, you can turn any type tag into an ordinary predicate which can be used on the right-hand side of other definitions. To these ends, the prelude provides the <a href="purelib.html#typep"><code>typep</code></a> predicate which takes a type symbol and the value to be checked as arguments. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> odd x::<span class="dt">int</span> = x mod <span class="dv">2</span>;
<span class="kw">type</span> even x::<span class="dt">int</span> = ~odd x;

odd x = typep odd x;
even x = typep even x;</code></pre></div>
<p>With those definitions you get:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map odd (<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]
&gt; map even (<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]</code></pre></div>
<p>There’s one caveat here. As the type symbol passed to <a href="purelib.html#typep"><code>typep</code></a> gets evaluated in normal code you have to be careful if the symbol is also defined as a parameterless function or a variable; in such a case you’ll have to quote the symbol, as described in section <a href="#the-quote">The Quote</a>. For instance, we might rewrite the above definitions as follows, giving “pointless” definitions of the <code>odd</code> and <code>even</code> predicates in terms of <a href="purelib.html#typep"><code>typep</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> odd x::<span class="dt">int</span> = x mod <span class="dv">2</span>;
<span class="kw">type</span> even x::<span class="dt">int</span> = ~odd x;

odd = typep (&#39;odd);
even = typep (&#39;even);</code></pre></div>
<p>Note that the quotes on <code>odd</code> and <code>even</code> are really needed here to prevent the predicate definitions from looping. If you need this a lot then you might define a little helper macro (cf. <a href="#macros">Macros</a>) which quotes the type symbol in an automatic fashion:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">def</span> typep ty::symbol = typep (&#39;ty);</code></pre></div>
<p>(However, this gets in the way if you want to check for computed type symbols, that’s why this macro isn’t defined in the prelude.)</p>
<p>Pure places no a priori restrictions on the rules defining a data type (other than that they must either define a unary predicate or an alias for an existing data type). As far as Pure is concerned, types are just subsets of the universe of terms. Thus any type of relation between two data types is possible; they might be unrelated (disjoint) term sets, one may be a subset of another, or they might be related in some other way (some terms may be members of both types, while others aren’t).</p>
<p>For instance, consider the types <code>nat</code> and <code>odd</code> from above. Both are subtypes of the <code>int</code> type (assuming our original definition of <code>nat</code> as the positive <code>int</code> values), but neither is a subtype of the other. It’s sometimes useful to define the “intersection type” of two such types, which can be done in a straightforward way using the logical conjunction of the two type predicates:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> nat x::<span class="dt">int</span> = x&gt;<span class="dv">0</span>;
<span class="kw">type</span> odd x::<span class="dt">int</span> = x mod <span class="dv">2</span>;
<span class="kw">type</span> odd_nat x  = typep nat x &amp;&amp; typep odd x;</code></pre></div>
<p>Similarly, a variation of the <code>integer</code> union type from above could be defined using logical disjunction (this employs the <a href="purelib.html#intp"><code>intp</code></a> and <a href="purelib.html#bigintp"><code>bigintp</code></a> predicates from the prelude):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> myinteger x = intp x || bigintp x;</code></pre></div>
<p>(Note that this isn’t quite the same as the previous definition, which uses explicit patterns in order to make the definition extensible.)</p>
<p>Since the right-hand side of a type definition may in general be any predicate, it is up to the programmer to ensure that the definition of a type is actually computable. In fact, you should strive for the best possible efficiency in type predicates. A type definition which has worse than <span class="math inline"><em>O</em>(1)</span> complexity may well be a serious performance hog depending on the way in which it is used, see <a href="#recursive-types">Recursive Types</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for more information about this.</p>
<p>Finally, note that in general it may be hard or even impossible to predict exactly when the code of a type definition will be executed at runtime. Thus, as a general rule, a type definition should not rely on side effects such as doing I/O (except maybe for debugging purposes), modifying references or external data structures via C pointers, etc.</p>
<h2 id="examples">Examples</h2>
<p>This section assumes that you’ve read the <a href="#pure-overview">Pure Overview</a> and <a href="#rule-syntax">Rule Syntax</a> sections, so that you are familiar with the basic elements of the Pure language. We now bring the pieces together and show you how simple but typical problems can be solved using Pure. You might use this section as a mini-tutorial on the Pure language. As we haven’t discussed the more advanced elements of the Pure language yet, the scope of this section is necessarily limited. But it should give you a pretty good idea of how Pure programs looks like. After working through these examples you should be able to write useful Pure programs and understand the more advanced features discussed in subsequent sections.</p>
<h3 id="hello-world">Hello, World</h3>
<p>The notorious “hello world” program can be written in Pure as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;
puts <span class="st">&quot;Hello, world!&quot;</span>;</code></pre></div>
<p>This employs the <a href="purelib.html#puts"><code>puts</code></a> function from Pure’s system module (which is in fact just the <code>puts</code> function from the C library). If you put these lines into a script file, say, hello.pure, you can run the program from the command line as follows:</p>
<pre class="sourceCode console"><code>$ pure hello.pure
Hello, world!</code></pre>
<p>You may notice a slight delay when executing the script, before the “<code>Hello, world!</code>” message appears. That’s because the interpreter first has to compile the definitions in your script as well as the prelude and other imported modules before the <code>puts &quot;Hello, world!&quot;</code> expression can be evaluated. The startup times can be reduced (sometimes considerably) by compiling scripts to native executables, see <a href="#compiled-scripts">Compiled Scripts</a> below.</p>
<h4 id="passing-parameters">Passing Parameters</h4>
<p>Sometimes you may want to pass parameters to a script from the command line. To these ends, just follow the script name with the required parameters. The interpreter makes the command line parameters (including the script name) available as a list of strings in the <a href="#argv"><code>argv</code></a> variable. For instance, here is a version of the “hello world” program which uses <a href="purelib.html#printf"><code>printf</code></a> to print the line <code>Hello, foo!</code> where <code>foo</code> is whatever was specified as the first command line parameter:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;
printf <span class="st">&quot;Hello, %s!</span><span class="ch">\n</span><span class="st">&quot;</span> (argv!<span class="dv">1</span>);</code></pre></div>
<p>This script is invoked as:</p>
<pre class="sourceCode console"><code>$ pure hello.pure foo
Hello, foo!</code></pre>
<p>Of course, many real-world programs will require more elaborate processing of command line parameters, such as recognizing program options. We won’t discuss this here, but you can have a look at the <a href="purelib.html#module-getopt">getopt</a> module which provides that kind of functionality in a convenient package.</p>
<h4 id="executable-scripts">Executable Scripts</h4>
<p>It is often convenient if you can turn a script into a standalone executable which can be invoked by just typing its name on the command line. There are several ways to do this.</p>
<p>First, on most systems you can invoke the Pure script through some kind of shell script or command file which contains the command to invoke the interpreter. The details of this depend on the operating system and type of shell that you use, however, so we won’t go into this here.</p>
<p>Second, on Unix-like systems it is possible to make any script file executable like this:</p>
<pre class="sourceCode console"><code>$ chmod a+x hello.pure</code></pre>
<p>However, we also have to tell the shell about the command interpreter which should be invoked to run the script. (Otherwise the shell itself may try to execute the script, which won’t work because it’s not a shell script.) As already mentioned in <a href="#overview-of-operation">Overview of Operation</a>, this is done by adding a special kind of comment, a “shebang”, to the beginning of the script, so that it looks like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#!/usr/local/bin/pure
<span class="kw">using</span> system;
puts <span class="st">&quot;Hello, world!&quot;</span>;</code></pre></div>
<p>Note that you <em>must</em> give the full path to the Pure interpreter in the shebang line. This path of course depends on where you installed Pure. The above shebang will work with an installation from source, unless you changed the installation prefix when configuring the source package. If you installed the interpreter from a binary package, the proper path will often be <code>/usr/bin/pure</code> instead. In any case, you can find out where the interpreter lives by typing the following command in the shell:</p>
<pre class="sourceCode console"><code>$ which pure
/usr/local/bin/pure</code></pre>
<p>If you get anything else on your system then you’ll have to fix the shebang accordingly. You should then be able to run the script as follows:</p>
<pre class="sourceCode console"><code>$ ./hello.pure
Hello, world!</code></pre>
<hr />
<blockquote>
<p><strong>Note:</strong> Many modern Unix-like systems provide the <code>/usr/bin/env</code> utility which can perform a search for the interpreter executable, so that you can also use a shebang like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#!/usr/bin/env pure</code></pre></div>
<p>This has the advantage that you don’t have to hardcode the path to the Pure interpreter into the shebang; the <code>/usr/bin/env</code> utility will locate the interpreter for you, provided that it is installed somewhere on the system <a href="#envvar-PATH"><code>PATH</code></a>.</p>
</blockquote>
<hr />
<h4 id="compiled-scripts">Compiled Scripts</h4>
<p>Last but not least, you can also turn a Pure script into an executable by “batch-compiling” it. This works on all supported systems (provided that you have the necessary LLVM tools and 3rd party compilers installed, see the <a href="install.html">installation instructions</a> for details). The result is a real native executable which can then be run directly just like any other binary program on your system. To these ends, the interpreter is run with the <a href="#cmdoption-pure-c"><code>-c</code></a> option which tells it to run in batch compilation mode, and the <a href="#cmdoption-pure-o"><code>-o</code></a> option which specifies the desired name of the executable. For instance:</p>
<pre class="sourceCode console"><code>$ pure -c hello.pure -o hello
Hello, world!
$ ./hello
Hello, world!</code></pre>
<p>You’ll notice that the compilation command in the first line above <em>also</em> prints the <code>Hello, world!</code> message. This reveals a rather unusual aspect of Pure’s batch compiler: it actually <em>executes</em> the script even during batch compilation. The reasons for this behaviour and potential uses are discussed in the <a href="#batch-compilation">Batch Compilation</a> section. If you want to suppress the program output during batch compilation, you can rewrite the program as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;
main = puts <span class="st">&quot;Hello, world!&quot;</span>;
compiling || main;</code></pre></div>
<p>Note that here we turned the code to be executed into a separate <code>main</code> function. This isn’t really necessary, but often convenient, since it allows us to run the code to be executed by just evaluating a single function. (Note that in contrast to C, the name <code>main</code> has no special significance in Pure; it’s just a function like any other. We still have to include a call to this function at the end of our program so that it gets executed.)</p>
<p>The last line now reads <code>compiling || main</code> which is a shorthand for “if the <code>compiling</code> variable is nonzero then do nothing, otherwise evaluate the <code>main</code> function”. In a batch compilation the interpreter sets this variable to a nonzero value so that the evaluation of <code>main</code> is skipped:</p>
<pre class="sourceCode console"><code>$ pure -c hello.pure -o hello
$ ./hello
Hello, world!</code></pre>
<p>We should mention here that batch-compiled scripts have some limitations because the compiled executable runs under a trimmed-down runtime system. This disables some of the advanced compile time features which are only available when running a script with the interpreter or at batch-compilation time. However, this won’t usually affect run-of-the-mill scripts like the one above. More information about this can be found in the <a href="#batch-compilation">Batch Compilation</a> section.</p>
<h3 id="running-the-interpreter">Running the Interpreter</h3>
<p>While Pure scripts can be run as standalone programs directly from the shell, most of the time you’ll probably use the Pure interpreter in an interactive way. You then simply run it like this:</p>
<pre class="sourceCode console"><code>$ pure

 __ \  |   |  __| _ \    Pure 0.66 (x86_64-unknown-linux-gnu)
 |   | |   | |    __/    Copyright (c) 2008-2017 by Albert Graef
 .__/ \__,_|_|  \___|    (Type &#39;help&#39; for help, &#39;help copying&#39;
_|                       for license information.)

Loaded prelude from /usr/lib/pure/prelude.pure.

&gt;</code></pre>
<p>The interpreter prints its sign-on message and leaves you at its command prompt. (You can also try <code>pure --plain</code> for a less fancy sign-on, or <code>pure -q</code> to completely suppress the message.)</p>
<p>At this point you can just start typing definitions and expressions to be evaluated. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n = <span class="kw">if</span> n&lt;=<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n*fact (n-<span class="dv">1</span>);
&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>Note that Pure is a free-format language, and thus definitions and expressions <em>must</em> be terminated with a semicolon, so that the interpreter knows when you’re done entering each item. This probably needs getting used to, but it’s convenient because you can easily type more than one expression on a single line, or split longer constructs across multiple lines:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">6</span>*<span class="dv">7</span>; <span class="dv">16.3805</span>*<span class="dv">5.0</span>;
<span class="dv">42</span>
<span class="dv">81.9025</span>
&gt; <span class="dv">16753418726345</span>
&gt; * <span class="dv">991726534256718265234</span>;
16614809890429729930396098173389730L</code></pre></div>
<p>If the interpreter appears to just eat away expressions without printing any results, then most likely you forgot to enter the terminating semicolon. In such a case you can just type the semicolon on a line by itself:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">6</span>*<span class="dv">7</span>
&gt; ;</code></pre></div>
<p>(This won’t do any harm even if it’s not needed, because an empty item is always valid input at Pure’s toplevel.)</p>
<p>The interpreter also reports syntax errors if you mistype an expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">16.3805</span>*(<span class="dv">5</span>;
&lt;stdin&gt;, line <span class="dv">8</span>: syntax error, unexpected &#39;;&#39;, expecting <span class="kw">when</span> or <span class="kw">with</span> or &#39;)&#39;</code></pre></div>
<p>In such a case, just correct the error and resubmit the offending input. The interpreter’s readline facility makes this pretty convenient, because you can use the cursor keys to recall previous input lines and edit them as needed.</p>
<p>Other kinds of errors may happen at runtime, when evaluating a syntactically correct expression. These give rise to so-called exceptions. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">1</span> div <span class="dv">0</span>;
&lt;stdin&gt;, line <span class="dv">9</span>: unhandled exception &#39;signal <span class="dv">8</span>&#39; while evaluating &#39;<span class="dv">1</span> div <span class="dv">0</span>&#39;</code></pre></div>
<p>Besides integer division by zero (flagged as ‘<code>signal 8</code>’ here), common sources of exceptions are failed matches and conditionals, interrupts (e.g., if the user aborts an evaluation with <code>Ctrl-c</code>) and stack overflows (cf. <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>). Normally these are fatal and require you to fix the program or the expression that you entered, but programs can also catch these errors and handle them in any desired way, cf. <a href="#exception-handling">Exception Handling</a>.</p>
<p>Note that in contrast to most other programming languages, undefined identifiers are generally <em>not</em> an error in Pure. Instead, you’ll simply get an unevaluated normal form:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo <span class="dv">5</span>;
foo <span class="dv">5</span></code></pre></div>
<p>Therefore, we recommend invoking the interpreter with the <a href="#cmdoption-pure-w"><code>-w</code></a> option so that it at least warns you about unknown symbols. You can also enter this option interactively or in a script using the <a href="#cmdoption-pure--warn"><code>--warn</code></a> pragma:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --warn
&gt; bar <span class="dv">5</span>;
&lt;stdin&gt;, line <span class="dv">12</span>: warning: implicit declaration <span class="kw">of</span> &#39;bar&#39;
bar <span class="dv">5</span></code></pre></div>
<p>The interpreter has a global variable environment in which you can store intermediate results:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = <span class="dv">16.3805</span>*<span class="dv">5</span>;
&gt; x; x/<span class="dv">2</span>; <span class="dv">1</span>/x;
<span class="dv">81.9025</span>
<span class="dv">40.95125</span>
<span class="dv">0.0122096395103935</span>
&gt; <span class="kw">let</span> y = <span class="dv">2</span>*x; y;
<span class="dv">163.805</span></code></pre></div>
<p>Another handy feature is the special built-in function <a href="purelib.html#ans"><code>ans</code></a> which yields the most recent result printed by the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">16.3805</span>*<span class="dv">5</span>;
<span class="dv">81.9025</span>
&gt; ans*<span class="dv">2</span>;
<span class="dv">163.805</span></code></pre></div>
<p>The interpreter recognizes a few other special commands which, like <a href="purelib.html#ans"><code>ans</code></a>, are only available when it is run interactively. For instance, you can purge the value of a variable like this (this also works with any other defined item, such as constants, functions and macros):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear x
&gt; x;
x</code></pre></div>
<p>Another useful command is <code>show</code> which prints the definition of anything that you can define in a Pure script, such as variables and functions. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show fact
fact n = <span class="kw">if</span> n&lt;=<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n*fact (n-<span class="dv">1</span>);</code></pre></div>
<p>You can also just type <code>show</code> to print all definitions done interactively at the command prompt, which lets us review our accomplishments so far:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show
fact n = <span class="kw">if</span> n&lt;=<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n*fact (n-<span class="dv">1</span>);
<span class="kw">let</span> y = <span class="dv">163.805</span>;</code></pre></div>
<p>The <code>dump</code> command saves these definitions in a file for later use:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; dump</code></pre></div>
<p>This command doesn’t print anything, but you can have a look at the written file in a text editor and maybe edit it as needed. By default, <code>dump</code> saves interactive definitions in a hidden file named <code>.pure</code> in the current directory, which gets reloaded automatically if we later rerun the interpreter in the same directory. We can also print this file, e.g., with the Unix <code>cat</code> command (note that ‘<code>!</code>’ executes a shell command):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; !cat .pure
<span class="co">// dump written Wed Sep  5 10:00:15 2012</span>
fact n = <span class="kw">if</span> n&lt;=<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n*fact (n-<span class="dv">1</span>);
<span class="kw">let</span> y = <span class="dv">163.805</span>;</code></pre></div>
<p>If we mess up badly, it’s often convenient to just rerun the interpreter from scratch so that we can try again in a clean environment:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; run</code></pre></div>
<p>As we’ve saved our scribblings with <code>dump</code> previously, those definitions will be reloaded automatically:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show
fact n = <span class="kw">if</span> n&lt;=<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n*fact (n-<span class="dv">1</span>);
<span class="kw">let</span> y = <span class="dv">163.805</span>;</code></pre></div>
<p>If you don’t want this then you can just remove the <code>.pure</code> file or rename it before invoking <code>run</code>.</p>
<p>Another helpful command is <code>help</code> which brings up the online documentation (this requires that you’ve configured the interpreter for the web browser that you use; see <a href="#online-help">Online Help</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help help</code></pre></div>
<p>Last but not least, you can use the following command to exit the interpreter and return to the command shell:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; quit</code></pre></div>
<p>Typing just an end-of-file character (usually <code>Ctrl-d</code> on Unix-like systems) at the beginning of the command line does the same.</p>
<p>There are a few other built-in commands that you may find useful when working with the interpreter, and you can even define your own. These interactive commands are special; they have their own syntax and need to be typed on a separate line. Please refer to <a href="#interactive-usage">Interactive Usage</a> for a detailed explanation of the command syntax and the available commands.</p>
<h3 id="basic-examples">Basic Examples</h3>
<p>Pure has a few built-in data types, namely numbers (machine integers, bigints and double precision floating point numbers), strings, matrices, symbols, functions and pointer values. Compound expressions are formed from these using function application. In the syntax of the Pure language, these are also known as <a href="#simple-expressions">simple expressions</a>. For want of a catchier name, we also simply call them <strong>terms</strong>. Pure is a programming language based on <strong>term rewriting</strong>, so all computations performed in Pure consist of the rewriting of terms. Some terms may reduce to other terms, others simply stand for themselves; the latter are also called <strong>normal forms</strong> and are what constitutes a “value” in the Pure language.</p>
<p>When the Pure interpreter starts up, it normally loads a collection of Pure scripts collectively called the <strong>prelude</strong>. The prelude defines many of the usual operations on numbers, strings, lists and other basic data structures that you may need, so you can start using the interpreter as a sophisticated kind of desktop calculator right away. Let’s begin with some simple calculations involving integer and floating point numbers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">6</span>*<span class="dv">7</span>;
<span class="dv">42</span>
&gt; <span class="dv">16.3805</span>*<span class="dv">5.0</span>;
<span class="dv">81.9025</span>
&gt; <span class="dv">16753418726345</span> * <span class="dv">991726534256718265234</span>;
16614809890429729930396098173389730L</code></pre></div>
<p>Note that the integer constants in the last example exceeded the 32 bit range of machine integers, so they were promoted to bigints. The result is again a bigint (indicated by the <code>L</code> suffix). You can also turn <em>any</em> integer constant into a bigint by explicitly adding the <code>L</code> suffix:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; 6L*7L;
42L</code></pre></div>
<p>Arithmetic with mixed operands will generally return the most general type capable of holding the result:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">6</span>*7L;
42L
&gt; <span class="dv">16.3805</span>*<span class="dv">5</span>;
<span class="dv">81.9025</span>
&gt; <span class="dv">16.3805</span>*5L;
<span class="dv">81.9025</span></code></pre></div>
<p>But note that most operations involving only machine integers will produce another machine integer; the result is <em>never</em> promoted to a bigint automatically, even in case of “overflow” (i.e., wrap-around). So the following will yield the same kind of signed 32 bit result as you’d get in C:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">2147483647</span> + <span class="dv">1</span>;
-<span class="dv">2147483648</span></code></pre></div>
<p>This has the advantage that you always know the type of the result of each operation beforehand by just looking at the types of the operands. It also makes it possible to compile machine integer operations to efficient native code. Therefore, if you suspect that a machine integer operation may wrap around and you’d thus prefer to do the calculation with bigints instead, you’ll have to convert at least one of the operands to a bigint beforehand:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; 2147483647L + <span class="dv">1</span>;
2147483648L</code></pre></div>
<p>Also note that, in contrast to C or Fortran, the result of the <a href="purelib.html#/"><code>/</code></a> (division) and <a href="purelib.html#%5E"><code>^</code></a> (exponentiation) operators is <em>always</em> a floating point value in Pure, even if both operands are integers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">14</span>/<span class="dv">12</span>;
<span class="dv">1.16666666666667</span>
&gt; 2L^60L;
<span class="dv">1.15292150460685e+18</span></code></pre></div>
<p>Integer division and modulo are done with the <a href="purelib.html#div"><code>div</code></a> and <a href="purelib.html#mod"><code>mod</code></a> operators, and exact powers of machine integers and bigints can be computed with the <a href="purelib.html#pow"><code>pow</code></a> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">14</span> div <span class="dv">12</span>; <span class="dv">14</span> mod <span class="dv">12</span>;
<span class="dv">1</span>
<span class="dv">2</span>
&gt; pow <span class="dv">2</span> <span class="dv">60</span>;
1152921504606846976L</code></pre></div>
<p>Also note that many of the standard math functions are available in a separate <a href="purelib.html#module-math">math</a> module, so we need to import that module if we want to use one of these (see <a href="#modules-and-imports">Modules and Imports</a> for a detailed explanation of Pure’s module system). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> math;
&gt; sqrt (<span class="dv">16.3805</span>*<span class="dv">5</span>)/.<span class="dv">05</span>;
<span class="dv">181.0</span></code></pre></div>
<p>The <a href="purelib.html#module-math">math</a> module also provides you with complex and rational number types for doing more advanced calculations, but we won’t go into that here.</p>
<p>Before we proceed, a few remarks about the syntax of function applications are in order. Function application is an explicit operation in Pure, so that functions become first class values which can be passed around as function arguments and results. Like in most modern functional languages, function application is simply denoted by juxtaposition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sqrt <span class="dv">2</span>;
<span class="dv">1.4142135623731</span></code></pre></div>
<p>In this case, you may also write <code>sqrt(2)</code> instead, but multiple arguments are normally specified as <code>f x y z</code> rather than <code>f(x,y,z)</code>. The former notation is known as <strong>currying</strong> (named after the American mathematician and logician Haskell B. Curry), and is ubiquitous in modern functional programming languages. The latter notation can be used in Pure as well, but it actually indicates that <code>f</code> is called on a <em>single</em>, structured argument (in this case a tuple). However, most predefined functions use the curried notation in Pure. For instance, the <a href="purelib.html#max"><code>max</code></a> function defined in the prelude takes two separate arguments, so it is invoked as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; max <span class="dv">4</span> <span class="dv">7</span>;
<span class="dv">7</span></code></pre></div>
<p>Function application associates to the left, so the above is parsed as <code>(max 4) 7</code>, where <code>max 4</code> is called a <strong>partial application</strong> of the <a href="purelib.html#max"><code>max</code></a> function. A partial application is a function in its own right; e.g., <code>max 4</code> denotes the function which computes <code>max 4 y</code> for each given <code>y</code>.</p>
<p>Parentheses are used for grouping expressions as usual. In particular, since function application associates to the left, a nested function application in a function argument must be parenthesized as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sqrt (sqrt <span class="dv">2</span>);
<span class="dv">1.18920711500272</span></code></pre></div>
<p>The same is true for any kind of expression involving operators, since function application binds stronger than any of these:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sqrt (<span class="dv">2</span>*<span class="dv">3</span>);
<span class="dv">2.44948974278318</span></code></pre></div>
<p>The <a href="purelib.html#map"><code>map</code></a> function lets us apply a function to each member of a given list, which gives us a quick way of tabulating function values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map sqrt (<span class="dv">0</span>..<span class="dv">2</span>);
[<span class="dv">0.0</span>,<span class="dv">1.0</span>,<span class="dv">1.4142135623731</span>]</code></pre></div>
<p>Here, the list argument is specified as an <strong>arithmetic sequence</strong> <code>0..2</code> which evaluates to the list <code>[0,1,2]</code>. This is fairly convenient when tabulating values of numeric functions. Here is another example which employs a partial application of the <a href="purelib.html#max"><code>max</code></a> function as the function argument:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (max <span class="dv">0</span>) (-<span class="dv">3</span>..<span class="dv">3</span>);
[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>Note that when the <code>max 0</code> function gets applied, say, to the first list member <code>-3</code>, we obtain the application <code>max 0 (-3)</code> which now has all the arguments that it needs; we also say that <code>max 0 (-3)</code> is a <strong>saturated</strong> application, which means that it’s “ready to go”. Evaluating <code>max 0 (-3)</code> gives <code>0</code> which becomes the first member of the result list returned by <code>map</code>. The other list members are calculated in an analogous fashion. It is easy to see that <code>max 0</code> thus computes what mathematicians call the “positive part” of its argument <code>x</code>, which is <code>x</code> itself if it is greater than <code>0</code> and <code>0</code> otherwise.</p>
<p>Operators aren’t special either, they are just functions in disguise. You can turn any operator into an ordinary function by enclosing it in parentheses. Thus <code>(+)</code> denotes the function which adds its two arguments, and <code>x+1</code> can also be written as <code>(+) x 1</code>; in fact, the former expression is nothing but syntactic sugar for the latter. You can easily verify this in the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (+) x <span class="dv">1</span>;
x+<span class="dv">1</span></code></pre></div>
<p>You can also have partial applications of operators like <code>(*) 2</code> which denotes a function which doubles its argument:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map ((*) <span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>];
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</code></pre></div>
<p>Moreover, Pure offers some convenient syntactic sugar to denote so-called <strong>operator sections</strong> which specify a binary operator with only either its left or right operand. So the doubling function above may also be denoted as <code>(2*)</code> or <code>(*2)</code>. Similarly, <code>(+1)</code> denotes the “increment by 1” and <code>(1/)</code> the reciprocal function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (+<span class="dv">1</span>) (<span class="dv">1</span>..<span class="dv">5</span>);
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
&gt; map (<span class="dv">1</span>/) (<span class="dv">1</span>..<span class="dv">5</span>);
[<span class="dv">1.0</span>,<span class="dv">0.5</span>,<span class="dv">0.333333333333333</span>,<span class="dv">0.25</span>,<span class="dv">0.2</span>]</code></pre></div>
<p>Note that the latter kind of section (also called a <strong>left section</strong>) is just a convenient shorthand for a partial application:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (<span class="dv">1</span>/);
(/) <span class="dv">1</span></code></pre></div>
<p>The former kind (a <strong>right section</strong>) can’t be handled this way, because it’s the <em>first</em> operand which is missing, and partial applications only allow you to omit trailing arguments. Instead, right sections expand to a partial application of the <a href="purelib.html#flip"><code>flip</code></a> function,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (+<span class="dv">1</span>);
flip (+) <span class="dv">1</span></code></pre></div>
<p>which is defined in the prelude as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">flip f x y = f y x;</code></pre></div>
<p>Note that <code>flip (+) 1</code> thus denotes a function which, when the missing operand is supplied, reduces to an application of the first (function) argument while also flipping around the operands. For another example, here’s how you can compute third powers <code>3^x</code> of some numbers <code>x</code> with a right section of the ‘<a href="purelib.html#%5E"><code>^</code></a>’ operator:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (^<span class="dv">3</span>) (<span class="dv">1</span>..<span class="dv">5</span>);
[<span class="dv">1.0</span>,<span class="dv">8.0</span>,<span class="dv">27.0</span>,<span class="dv">64.0</span>,<span class="dv">125.0</span>]</code></pre></div>
<p>Note that this is exactly the same as:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (flip (^) <span class="dv">3</span>) (<span class="dv">1</span>..<span class="dv">5</span>);
[<span class="dv">1.0</span>,<span class="dv">8.0</span>,<span class="dv">27.0</span>,<span class="dv">64.0</span>,<span class="dv">125.0</span>]</code></pre></div>
<p>Such explicit applications of <a href="purelib.html#flip"><code>flip</code></a> also work with ordinary functions like <a href="purelib.html#pow"><code>pow</code></a>, so if we want to compute the cubes as exact bigint numbers, we can also write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (flip pow <span class="dv">3</span>) (<span class="dv">1</span>..<span class="dv">5</span>);
[1L,8L,27L,64L,125L]</code></pre></div>
<p>Note the difference between <code>flip pow 3</code> which computes third powers, and <code>pow 3</code> which is a partial application that computes powers of 3.</p>
<p>Sometimes it is convenient to have function application as an explicit operation which can be passed as a function value to other functions. The <a href="purelib.html#$"><code>$</code></a> operator is provided for this purpose. <code>f $ x</code> is just <code>f x</code>, so you can write, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map ($<span class="dv">1</span>) [(+<span class="dv">2</span>),(*<span class="dv">2</span>),(/<span class="dv">2</span>)];
[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">0.5</span>]</code></pre></div>
<p>Recall that <code>($1)</code> is a right section which, when applied to an argument <code>f</code>, evaluates to <code>f $ 1 = f 1</code>. E.g., we have that <code>($1) (+2) = (+2) $ 1 = (+2) 1 = 1+2 = 3</code>. Hence the above expression actually applies a list of functions to the given argument <code>1</code>.</p>
<p>The <a href="purelib.html#$"><code>$</code></a> operator has a low precedence and is right-associative, so that it is sometimes used to eliminate the parentheses in cascading function calls. For instance, <code>sqrt $ sqrt $ 2*3</code> is the same as <code>sqrt (sqrt (2*3))</code>.</p>
<p>Another convenient operation for combining functions is the function composition operator, denoted ‘<a href="purelib.html#."><code>.</code></a>’. It applies two functions in sequence, so that <code>(f.g) x</code> evaluates to <code>f (g x)</code>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; g x = <span class="dv">2</span>*x-<span class="dv">1</span>;
&gt; map g (-<span class="dv">3</span>..<span class="dv">3</span>);
[-<span class="dv">7</span>,-<span class="dv">5</span>,-<span class="dv">3</span>,-<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>]
&gt; map (max <span class="dv">0</span> . g) (-<span class="dv">3</span>..<span class="dv">3</span>);
[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>]</code></pre></div>
<p>Operations like ‘<a href="purelib.html#."><code>.</code></a>’, which take functions as arguments and return other functions as results, are also called <strong>higher-order functions</strong>. We’ll have a closer look at these later.</p>
<p>As already mentioned, the interpreter also has a global variable environment in which you can store arbitrary expression values. This provides a means to define abbreviations for frequently-used expressions and for storing intermediate results. Global variable definitions are done with <a href="#let"><code>let</code></a>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = <span class="dv">16.3805</span>*<span class="dv">5</span>;
&gt; x;
<span class="dv">81.9025</span></code></pre></div>
<p>As we’ve explained above, functions are first-class citizens and can thus be assigned to variables as well:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> f = sqrt;
&gt; f x/<span class="dv">0.05</span>;
<span class="dv">181.0</span></code></pre></div>
<p>The value of a global variable can be changed at any time. So we can type:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> f = sin;
&gt; f x/<span class="dv">0.05</span>;
<span class="dv">4.38588407225469</span></code></pre></div>
<p>You can also bind several variables at once by using an expression <strong>pattern</strong> as the left-hand side of a variable definition. This is useful if we need to extract elements from an aggregate value such as a list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x1:x2:xs = map (^<span class="dv">3</span>) (<span class="dv">1</span>..<span class="dv">5</span>);
&gt; x1,x2,xs;
<span class="dv">1.0</span>,<span class="dv">8.0</span>,[<span class="dv">27.0</span>,<span class="dv">64.0</span>,<span class="dv">125.0</span>]</code></pre></div>
<p>Pure also provides a kind of “read-only” variables a.k.a. <strong>constants</strong>. They are defined pretty much like global variables (using the <a href="#const"><code>const</code></a> keyword in lieu of <a href="#let"><code>let</code></a>), but work more like a parameterless function whose value is precomputed at compile time:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">const</span> π = <span class="dv">4</span>*atan <span class="dv">1.0</span>;
&gt; show π
<span class="kw">const</span> π = <span class="dv">3.14159265358979</span>;
&gt; h x = sin (<span class="dv">2</span>*π*x);
&gt; show h
h x = sin (<span class="dv">6.28318530717959</span>*x);
&gt; map h [-<span class="dv">1</span>/<span class="dv">4</span>,-<span class="dv">1</span>/<span class="dv">8</span>,<span class="dv">0</span>,<span class="dv">1</span>/<span class="dv">8</span>,<span class="dv">1</span>/<span class="dv">4</span>];
[-<span class="dv">1.0</span>,-<span class="dv">0.707106781186547</span>,<span class="dv">0.0</span>,<span class="dv">0.707106781186547</span>,<span class="dv">1.0</span>]</code></pre></div>
<p>Note that the compiler normally computes constant subexpressions at compile time, such as <code>2*π</code> in the function <code>h</code>. This works with all simple scalars (machine ints and doubles), see <a href="#constant-definitions">Constant Definitions</a> for details.</p>
<p>As an aside, the last example also shows that Pure has no problems with Unicode. <code>π</code> is a Greek letter and thus an identifier as good as any other, although you will have a hard time finding that letter on an English keyboard. Fortunately, most operating systems nowadays provide you with an applet that lets you enter foreign language characters and other special symbols with ease.</p>
<h3 id="defining-functions">Defining Functions</h3>
<p>Now that we’ve learned how to run the interpreter and evaluate some expressions, it’s time to embark on some real programming. Like in other functional programming languages, we do this by defining <strong>functions</strong> which perform the desired computation. The form these definitions take in Pure is a collection of <strong>rewriting rules</strong> which specify how an application of the function reduces to another expression which then gets evaluated recursively to give the value of the function application.</p>
<p>In the simplest case, the left-hand side of a rewriting rule may just specify the function name along with some argument names. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">square x = x*x;</code></pre></div>
<p>Now, if we evaluate an expression like <code>square 7</code>, it reduces to <code>7*7</code> which in turn reduces to <code>49</code> by the built-in rules for integer arithmetic. You can verify this by entering the definition in the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; square x = x*x;
&gt; square <span class="dv">7</span>;
<span class="dv">49</span></code></pre></div>
<p>In fact, the above definition is completely generic; since <code>x</code> is an unqualified variable, we can apply <code>square</code> to <em>any</em> value <code>x</code> and have it evaluate to <code>x*x</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; square <span class="dv">7.0</span>;
<span class="dv">49.0</span>
&gt; square 7L;
49L
&gt; square (a+b);
(a+b)*(a+b)</code></pre></div>
<p>As the last example shows, this will even work if the supplied argument is no number at all, which is useful, e.g., if we want to do symbolic evaluations.</p>
<p>Functions can have as many arguments as you like, subject to the constraint that each equation defining the function has the <em>same</em> number of arguments on the left-hand side. For instance, suppose that we want to calculate the sum of two squares. We can do this using the <code>square</code> function from above as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sumsquares x y = square x + square y;
&gt; sumsquares <span class="dv">3</span> <span class="dv">4</span>;
<span class="dv">25</span></code></pre></div>
<p>The interpreter keeps track of the number of arguments of each defined function, so if we accidentally try to define <code>sumsquares</code> with three arguments later then we’ll get an error message:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sumsquares x y z = square x + square y + square z;
&lt;stdin&gt;, line <span class="dv">8</span>: function &#39;sumsquares&#39; was previously defined <span class="kw">with</span> <span class="dv">2</span> args</code></pre></div>
<p>This actually makes perfect sense if you think about the way curried function applications work. If the above was permitted, then an expression like <code>sumsquares x y</code> would become ambiguous (would it denote an invocation of the binary <code>sumsquares</code> or a partial application of the ternary one?).</p>
<p>Thus Pure doesn’t really have <strong>variadic</strong> functions which take a variable number of arguments. There are ways to emulate this behaviour in some cases, but usually it’s easier to just pass the arguments as a single structured value instead. It is customary to employ tuples for this purpose, so that the call uses the familiar notation <code>f (x,y,z)</code>. A typical example are optional arguments. For instance, suppose that we’d like to define a function <code>incr</code> which increments a numeric value, where the amount to be added can be specified as an optional second value which defaults to 1. This can be done in Pure as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">incr (x,y) = x+y;
incr x = x+<span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>These equations <em>must</em> be in the indicated order. Pure considers different equations for the same function in the order in which they are written. Therefore “special case” rules, like the one for <code>incr (x,y)</code> in this example, must be listed first. (Note that if the second equation came first, <code>incr (5,2)</code> would reduce to <code>(5,2)+1</code> rather than <code>5+2</code>, because <code>x</code> also matches, in particular, any tuple <code>x,y</code>.)</p>
<p>Functions taking a single tuple argument are also (somewhat misleadingly) called <strong>uncurried</strong> functions, because their arguments have to be given all in one go, which precludes partial applications of the function. While curried functions are often preferred, uncurried functions can be more convenient at times, e.g., if you have to map a function to a list containing given combinations of arguments. For instance, given the above definition of <code>incr</code> we may write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map incr [(<span class="dv">5</span>,<span class="dv">1</span>),(<span class="dv">5</span>,<span class="dv">2</span>),(<span class="dv">6</span>,<span class="dv">3</span>),(<span class="dv">7</span>,<span class="dv">5</span>)];
[<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">12</span>]</code></pre></div>
<p>To make this work with curried functions, the prelude provides a function <a href="purelib.html#uncurry"><code>uncurry</code></a> which turns a curried function of two arguments into an uncurried one which takes a single tuple argument:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (uncurry (+)) [(<span class="dv">5</span>,<span class="dv">1</span>),(<span class="dv">5</span>,<span class="dv">2</span>),(<span class="dv">6</span>,<span class="dv">3</span>),(<span class="dv">7</span>,<span class="dv">5</span>)];
[<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">12</span>]</code></pre></div>
<p>On the other hand, some generic list processing functions such as <a href="purelib.html#foldl"><code>foldl</code></a> expect curried functions, so the reverse transformation <a href="purelib.html#curry"><code>curry</code></a> is also provided:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldl (curry incr) <span class="dv">0</span> (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">55</span></code></pre></div>
<p>In fact, the definitions of <code>curry</code> and <code>uncurry</code> don’t involve any special magic, they just translate curried calls to uncurried ones and vice versa. From the horse’s mouth:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show curry uncurry
curry f x y = f (x,y);
uncurry f (x,y) = f x y;</code></pre></div>
<p>A function can also have zero arguments, i.e., you can define parameterless functions such as:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo = <span class="dv">1</span>..<span class="dv">3</span>;</code></pre></div>
<p>The function is then simply invoked without any arguments:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>It is worth noting the difference between this and the variable definition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> bar = <span class="dv">1</span>..<span class="dv">3</span>;</code></pre></div>
<p>While <code>bar</code> and <code>foo</code> yield the same result <code>[1,2,3]</code>, they do so in different ways. <code>bar</code> is a global variable whose value is computed once and then stored under its name, so that the value can be simply recalled when <code>bar</code> is later invoked in an expression. Also, the value of <code>bar</code> can be changed at any time with an appropriate <a href="#let"><code>let</code></a> statement. (If the value is not supposed to change later then you can also define it as a <a href="#const"><code>const</code></a> instead.)</p>
<p>In contrast, <code>foo</code> is a function which recomputes the list value on each invocation. To avoid the overhead of recalculating the same value each time it is needed, a variable or constant is usually preferred over a parameterless function in Pure. However, a parameterless function will be needed if the computation involves some hidden side effects which cause a new value to be produced for each invocation. For instance, the <a href="purelib.html#module-math">math</a> module provides a parameterless function <a href="purelib.html#random"><code>random</code></a> which computes a new pseudo random number each time it is called:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> math;
&gt; random, random, random;
-<span class="dv">795755684</span>,<span class="dv">581869302</span>,-<span class="dv">404620562</span></code></pre></div>
<p>Many functions also involve conditionals which let them take different computation paths depending on the outcome of a condition. One way to do this is to employ a <strong>conditional expression</strong>. For instance, we may compute the sign of a number as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sign x = <span class="kw">if</span> x&gt;<span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="kw">if</span> x&lt;<span class="dv">0</span> <span class="kw">then</span> -<span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>;
&gt; map sign (-<span class="dv">3</span>..<span class="dv">3</span>);
[-<span class="dv">1</span>,-<span class="dv">1</span>,-<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]</code></pre></div>
<p>Alternatively, you can also use a collection of <strong>conditional rules</strong> instead:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sign x =  <span class="dv">1</span> <span class="kw">if</span> x&gt;<span class="dv">0</span>;
       = -<span class="dv">1</span> <span class="kw">if</span> x&lt;<span class="dv">0</span>;
   =  <span class="dv">0</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>Note that here we omitted the left-hand side in the second and third equations, in which case the compiler assumes that it’s the same as for the first equation; cf. <a href="#rule-syntax">Rule Syntax</a> for details. Also note that the <a href="#otherwise"><code>otherwise</code></a> keyword is only syntactic sugar in Pure, you can always omit it. However, it tends to improve readability by marking the default case of a definition.</p>
<p>Both styles are frequently used in Pure programs; it depends on the situation which one is more appropriate. Conditional rules make the conditions stick out more clearly and hence tend to improve readability. On the other hand, conditional expressions can be nested more easily and thus facilitate the programming of complicated decision trees.</p>
<p>Function definitions may also be recursive, i.e., a function may invoke itself either directly or indirectly in its definition. For instance, here is a definition of the Ackerman function using conditional rules:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">ack x y = y+<span class="dv">1</span> <span class="kw">if</span> x == <span class="dv">0</span>;
        = ack (x-<span class="dv">1</span>) <span class="dv">1</span> <span class="kw">if</span> y == <span class="dv">0</span>;
        = ack (x-<span class="dv">1</span>) (ack x (y-<span class="dv">1</span>)) <span class="kw">otherwise</span>;</code></pre></div>
<p>We will have more to say about recursive functions later; see <a href="#recursion">Recursion</a> below.</p>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>So far we have only seen function definitions involving just unqualified variables as parameters. In general it is possible to specify arbitrary <a href="#patterns">patterns</a> for the parameters, in which case the actual arguments are checked against the patterns and, if everything matches up, the right-hand side of the rule is invoked with the variables in the patterns bound to their corresponding values.</p>
<p>The simplest nontrivial patterns are <a href="#type-tags">type tags</a> which can be placed on a variable to restrict the type of value an argument can match. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; square x::<span class="dt">int</span> = x*x;
&gt; square <span class="dv">7</span>;
<span class="dv">49</span></code></pre></div>
<p>Note that in contrast to our previous generic definition of the <code>square</code> function we gave in <a href="#defining-functions">Defining Functions</a>, this definition now only applies to the case of an <code>int</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; square <span class="dv">7.0</span>;
square <span class="dv">7.0</span></code></pre></div>
<p>Polymorphic definitions can be made by giving separate equations for the different argument types. For instance, we can easily add an equation for the <code>double</code> case:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; square x::<span class="dt">double</span> = x*x;
&gt; show square
square x::<span class="dt">int</span> = x*x;
square x::<span class="dt">double</span> = x*x;
&gt; square <span class="dv">7</span>; square <span class="dv">7.0</span>;
<span class="dv">49</span>
<span class="dv">49.0</span></code></pre></div>
<p>Here the right-hand sides of both rules are the same. Pure has a convenient shorthand notation for this case which lets you factor out the common right-hand side using the ‘<code>|</code>’ delimiter as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">square x::<span class="dt">int</span> | square x::<span class="dt">double</span> = x*x;</code></pre></div>
<p>The compiler expands this to the same two rules as above:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">square x::<span class="dt">int</span> = x*x;
square x::<span class="dt">double</span> = x*x;</code></pre></div>
<p>Let’s compare this to our earlier generic definition of <code>square</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">square x = x*x;</code></pre></div>
<p>There are two different kinds of polymorphism at work here. The latter, generic definition is an example of <strong>parametric polymorphism</strong>; it applies to <em>any</em> type of argument <code>x</code> whatsoever (at least if it makes sense to multiply a member of the type with itself). Also note that this definition is “closed”; because equations are considered in the order in which they are written, there’s no way you could add another “special case” rule to this definition later.</p>
<p>In contrast, the former definition leaves any application of <code>square</code> to a value other than <code>int</code> or <code>double</code> undefined. This gives us the opportunity to define <code>square</code> on as many types of arguments as we like, and (this is the crucial point) define the function in <em>different</em> ways for different argument types. This is also known as <strong>ad-hoc polymorphism</strong> or <strong>function overloading</strong>. For instance, if we later need to square 2x2 matrices, we might add a rule like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">square {a,b;c,d} = {a*a+b*c,a*b+b*d;c*a+d*c,c*b+d*d};</code></pre></div>
<p>Pure places no restriction on the number of equations used to define a function, and the different equations may in fact be scattered out over many different places. So as long as the left-hand side patterns properly discriminate between the different cases, you can overload any operation in Pure to handle as many argument types as you want. However, it is important to note that in contrast to overloaded functions in statically typed languages such as C++, there’s really only <em>one</em> <code>square</code> function here which handles all the different argument types. The necessary “dispatching” to select the proper rewriting rule for the argument values at hand is done at runtime by pattern matching.</p>
<p>Parametric polymorphism has the advantage that it lets you define polymorphic functions in a very concise way. On the other hand, ad-hoc polymorphism lets you deal with disparate cases of an operation which cannot easily be reconciled. It also allows you to tailor the definition to the specific case at hand, which might be more efficient than using a generic rule. You can also combine both approaches, but in this case you have to list the special case rules before the generic ones. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">square x::<span class="dt">int</span> | square x::<span class="dt">double</span> |
square x = x*x;</code></pre></div>
<p>(Note that the first two rules are just specialization of the last rule to <code>int</code> and <code>double</code> arguments, so we could in fact eliminate the special case rules here and still get the same results. But the type tags tell the compiler that the argument in these rules is always an <code>int</code> or <code>double</code>, respectively, so it may generate more efficient code for these cases.)</p>
<p>Patterns may also involve constant values, in which case the constant must be matched literally in the argument. For instance, here is another definition of the Ackerman function from <a href="#defining-functions">Defining Functions</a> which uses constant argument patterns instead of conditional rules:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">ack <span class="dv">0</span> y = y+<span class="dv">1</span>;
ack x <span class="dv">0</span> = ack (x-<span class="dv">1</span>) <span class="dv">1</span>;
ack x y = ack (x-<span class="dv">1</span>) (ack x (y-<span class="dv">1</span>)) <span class="kw">otherwise</span>;</code></pre></div>
<p>The first two rules take care of the “base cases” <code>x==0</code> and <code>y==0</code>. Note that these rules <em>must</em> be given in the indicated order to make them work. Specifically, the left-hand side <code>ack x y</code> of the last equation also matches, in particular, terms like <code>ack 0 y</code> and <code>ack x 0</code>, so placing the last equation before the first two will “shadow” those rules and cause non-termination, resulting in a stack overflow. Similarly, placing the second equation before the first one will cause the definition to loop on <code>ack 0 0</code>.</p>
<p>Another point that deserves mentioning here is that constants on the left-hand side of a rule <em>must</em> be matched literally, cf. <a href="#constant-patterns">Constant Patterns</a>. E.g., <code>ack 0 y</code> only matches if the first argument is really <code>0</code>, not <code>0.0</code> or <code>0L</code> (although these compare equal to <code>0</code>). So the above definition of <code>ack</code> isn’t quite the same as our previous definition from <a href="#defining-functions">Defining Functions</a>. If you wanted the definition above to also work with double and bigint values, you’d have to add corresponding rules for the <code>0.0</code> and <code>0L</code> cases.</p>
<p>Last but not least, patterns are also used to “deconstruct” structured values like lists, tuples and matrices, binding variables to the component values. For instance, to compute the sum of a list of values, you may write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sum [] = <span class="dv">0</span>;
&gt; sum (x:xs) = x+sum xs;
&gt; sum (<span class="dv">1</span>..<span class="dv">100</span>);
<span class="dv">5050</span></code></pre></div>
<p>This definition works in a straightforward recursive manner. The first rule involves the constant pattern <code>[]</code> and thus handles the base case of an empty list, in which case the sum is zero. The second rule has a structured argument pattern <code>x:xs</code> which denotes a list with head element <code>x</code> and tail <code>xs</code>; in this case the result is <code>x</code> added to the sum of the remaining list elements <code>xs</code>. (In fact, this computational pattern is so common that the prelude provides a family of functions such as <a href="purelib.html#foldl"><code>foldl</code></a> and <a href="purelib.html#foldr"><code>foldr</code></a> to do this kind of operation in a generic way. Our <code>sum</code> function above is actually equivalent to <code>foldr (+) 0</code>, see <a href="#list-processing">List Processing</a> below for details.)</p>
<p>Instead of placing the patterns directly into the left-hand sides of the function definition, you might also do the necessary pattern-matching in the right hand side, by employing a <a href="#case"><code>case</code></a> expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum xs = <span class="kw">case</span> xs <span class="kw">of</span> [] = <span class="dv">0</span>; x:xs = x+sum xs <span class="kw">end</span>;</code></pre></div>
<p>This works a bit different, though, since a <a href="#case"><code>case</code></a> expression raises an exception if the target expression is not matched (cf. <a href="#patterns">Patterns</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sum (<span class="dv">1</span>:<span class="dv">2</span>:xs);
&lt;stdin&gt;, line <span class="dv">2</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;sum (<span class="dv">1</span>:<span class="dv">2</span>:xs)&#39;</code></pre></div>
<p>To avoid that, you may want to add a type tag, which ensures that the argument of <code>sum</code> is of the proper type:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum xs::list = <span class="kw">case</span> xs <span class="kw">of</span> [] = <span class="dv">0</span>; x:xs = x+sum xs <span class="kw">end</span>;</code></pre></div>
<p>Now the case of an improper list is handled a bit more gracefully, yielding the same normal form expression you’d get with the first definition of <code>sum</code> above:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sum (<span class="dv">1</span>:<span class="dv">2</span>:xs);
<span class="dv">1</span>+(<span class="dv">2</span>+sum xs)</code></pre></div>
<p>Pure also allows to define <code>sum</code> in a more traditional way which will be familiar to Lisp programmers (note that <a href="purelib.html#head"><code>head</code></a> and <a href="purelib.html#tail"><code>tail</code></a> correspond to Lisp’s “car” and “cdr”):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum xs::list = <span class="kw">if</span> null xs <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> head xs + sum (tail xs);</code></pre></div>
<p>Choosing one or the other is again a question of style. However, if you’re dealing with concrete data structures such as lists, pattern-matching definitions are often more convenient and easier to understand.</p>
<p>Pattern matching also works with user-defined constructors (cf. <a href="#data-types">Data Types</a>). For instance, here’s how to implement an insertion operation which can be used to construct a binary tree data structure useful for sorting and searching:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;

insert nil y         = bin y nil nil;
insert (bin x L R) y = bin x (insert L y) R <span class="kw">if</span> y&lt;x;
                 = bin x L (insert R y) <span class="kw">otherwise</span>;</code></pre></div>
<p>Note that <code>nil</code> needs to be declared as a <a href="#nonfix"><code>nonfix</code></a> symbol here, so that the compiler doesn’t mistake it for a variable; see <a href="#the-head-function-rule">The “Head = Function” Rule</a> for details. The following example illustrates how the above definition may be used to obtain a binary tree data structure from a list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; tree [] = nil;
&gt; tree (x:xs) = insert (tree xs) x;
&gt; tree [<span class="dv">7</span>,<span class="dv">12</span>,<span class="dv">9</span>,<span class="dv">5</span>];
bin <span class="dv">5</span> nil (bin <span class="dv">9</span> (bin <span class="dv">7</span> nil nil) (bin <span class="dv">12</span> nil nil))</code></pre></div>
<p>Conversely, it’s also easy to convert such a tree structure back to a list. We can then combine these operations to sort a list in ascending order:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; list nil = [];
&gt; list (bin x L R) = list L + (x:list R);
&gt; list (tree [<span class="dv">7</span>,<span class="dv">12</span>,<span class="dv">9</span>,<span class="dv">5</span>]);
[<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">12</span>]</code></pre></div>
<h3 id="local-functions-and-variables">Local Functions and Variables</h3>
<p>Up to this point our examples only involved global functions and variables. When the problems to be solved become more difficult, it will be necessary to structure the solution in some way, so that you’ll often end up with many small functions which need to work in concert to solve the problem at hand. Typically only a few of these functions will serve as actual entry points, while other functions are only to be used internally. Pure supports this through <strong>local</strong> functions and variables whose scope is limited either to the right-hand side of a rule or one of its subexpression. This offers two main advantages:</p>
<ul>
<li>Local functions and variables are hidden from the main scope so that they can only be used in the context where they are needed and don’t clutter up the global environment. This provides a way to define functions in a modular fashion while hiding internal details from the rest of the program.</li>
<li>The right-hand sides of local definitions have full access to other local functions and variables in their parent environments, which eliminates the “plumbing” which would otherwise be needed to pass these values around. For instance, a local function nested in another function can freely access the parent function’s arguments and other local variables in its scope.</li>
</ul>
<p>Local functions are defined using the <a href="#with"><code>with</code></a> construct, while local variables can be introduced with a <a href="#when"><code>when</code></a> or <a href="#case"><code>case</code></a> expression, see <a href="#special-expressions">Special Expressions</a> for details. These constructs can be tacked on to any expression, and they can also be nested. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; f <span class="dv">5</span> <span class="kw">with</span> f x = y+y <span class="kw">when</span> y = x*x <span class="kw">end</span> <span class="kw">end</span>;
<span class="dv">50</span></code></pre></div>
<p>Note that the local function <code>f</code> there computes twice the square of its argument <code>x</code>. To these ends, first <code>x*x</code> is assigned to the local variable <code>y</code> whose value is then doubled by computing <code>y+y</code> which becomes the result of <code>f</code>.</p>
<p>Local functions can also be created without actually naming them, by employing a so-called <strong>lambda abstraction</strong>. For instance, a function which squares its argument might be denoted as <code>\x -&gt; x*x</code>. This is pretty much the same as a local function <code>f with f x = x*x end</code> except that the function remains nameless. This notation is pretty convenient for making up little “one-off” functions which are to be applied on the spot or passed as function arguments or results to other functions. For instance, here’s how you can compute the first ten squares, first with an ordinary (named) local function, and then with an equivalent lambda:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map f (<span class="dv">1</span>..<span class="dv">10</span>) <span class="kw">with</span> f x = x*x <span class="kw">end</span>;
[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">9</span>,<span class="dv">16</span>,<span class="dv">25</span>,<span class="dv">36</span>,<span class="dv">49</span>,<span class="dv">64</span>,<span class="dv">81</span>,<span class="dv">100</span>]
&gt; map (\x -&gt; x*x) (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">9</span>,<span class="dv">16</span>,<span class="dv">25</span>,<span class="dv">36</span>,<span class="dv">49</span>,<span class="dv">64</span>,<span class="dv">81</span>,<span class="dv">100</span>]</code></pre></div>
<p>For obvious reasons lambdas work best for non-recursive functions. While there are techniques to create recursive functions out of lambdas using so-called fixed point combinators (cf. <a href="purelib.html#fix"><code>fix</code></a>), named functions are much more convenient for that purpose.</p>
<p><a href="#pattern-matching">Pattern matching</a> works in local definitions as usual. For instance, here are several ways to swap two values represented as a tuple, using either a local function or a <a href="#when"><code>when</code></a> or <a href="#case"><code>case</code></a> expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; swap (<span class="dv">1</span>,<span class="dv">2</span>) <span class="kw">with</span> swap (x,y) = y,x <span class="kw">end</span>;
<span class="dv">2</span>,<span class="dv">1</span>
&gt; (\(x,y) -&gt; y,x) (<span class="dv">1</span>,<span class="dv">2</span>);
<span class="dv">2</span>,<span class="dv">1</span>
&gt; y,x <span class="kw">when</span> x,y = <span class="dv">1</span>,<span class="dv">2</span> <span class="kw">end</span>;
<span class="dv">2</span>,<span class="dv">1</span>
&gt; <span class="kw">case</span> <span class="dv">1</span>,<span class="dv">2</span> <span class="kw">of</span> x,y = y,x <span class="kw">end</span>;
<span class="dv">2</span>,<span class="dv">1</span></code></pre></div>
<p>You’ll also frequently find code like the following, where a global “wrapper” function just sets up some initial parameter values and then invokes a local “worker” function which does all the real work. The following function calculates the sum of the positive integers up to <code>n</code> (the “accumulating parameters” technique used in this example will be explained later, cf. <a href="#recursion">Recursion</a>).</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum n = sum <span class="dv">0</span> n <span class="kw">with</span>
  sum s n = s <span class="kw">if</span> n &lt; <span class="dv">0</span>;
          = sum (s+n) (n-<span class="dv">1</span>) <span class="kw">otherwise</span>;
<span class="kw">end</span>;</code></pre></div>
<p>Note that there are actually <em>two</em> separate functions named <code>sum</code> here. This works because according to the <a href="#scoping-rules">scoping rules</a> the right-hand side of the global definition is under the scope of the <a href="#with"><code>with</code></a> clause, and thus the call <code>sum 0 n</code> on the right-hand refers to the <em>local</em> <code>sum</code> function, not the global one. (While it is perfectly correct and even makes sense in this example, this style may be somewhat confusing, so we often prefer to give wrapper and worker different names for clarity.)</p>
<p>As discussed in <a href="#scoping-rules">Scoping Rules</a>, a local function can refer to other local functions and variables in its parent environments. It can also be returned as a function value, which is where things get really interesting. The local function value then becomes a <strong>lexical closure</strong> which carries around with it the local variable environment it was created in. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; adder x = add <span class="kw">with</span> add y = x+y <span class="kw">end</span>;
&gt; <span class="kw">let</span> g = adder <span class="dv">5</span>; g; map g (<span class="dv">1</span>..<span class="dv">5</span>);
add
[<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>Note that here the local function <code>add</code> refers to the argument value <code>x</code> of its parent function <code>adder</code>. The invocation <code>adder 5</code> thus returns an instance of <code>add</code> which has <code>x</code> bound to the value <code>5</code>, so that <code>add y</code> reduces to <code>5+y</code> for each <code>y</code>. This works as if this instance of the <code>add</code> closure had an invisible <code>x</code> argument of <code>5</code> attached to it. (And this is in fact how closures are implemented internally, using a transformation called <a href="http://en.wikipedia.org/wiki/Lambda_lifting">lambda lifting</a> which effectively turns local functions into global ones.) You should study this example carefully until you fully understand how it works; we’ll see a bunch of other, more complicated examples of this kind later.</p>
<p>Lexical closures also provide a means to encapsulate data in a way reminiscent of object-oriented programming. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> coords;

point (x,y) = \msg -&gt; <span class="kw">case</span> msg <span class="kw">of</span>
  coords = x,y;
  move (dx,dy) = point (x+dx,y+dy);
<span class="kw">end</span>;</code></pre></div>
<p>The anonymous function returned by <code>point</code> in fact works like an “object” which can be queried for its coordinates and moved by a given offset through corresponding “messages” passed as arguments to the object:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> p = point (<span class="dv">1</span>,<span class="dv">2</span>); p;
#&lt;closure <span class="dv">0x7f420660e658</span>&gt;
&gt; p coords; p (move (<span class="dv">2</span>,<span class="dv">3</span>)) coords;
<span class="dv">1</span>,<span class="dv">2</span>
<span class="dv">3</span>,<span class="dv">5</span></code></pre></div>
<p>Note that this still lacks some typical features of object-oriented programming such as mutability and inheritance. It isn’t really hard to add these, but this requires the use of some of Pure’s more advanced machinery which we didn’t discuss yet. For instance, mutability can be implemented in Pure by using so-called <a href="purelib.html#expression-references">expression references</a>, a kind of mutable storage cells which can hold arbitrary expression values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = ref <span class="dv">99</span>; get x;
<span class="dv">99</span>
&gt; put x <span class="dv">2</span>;
<span class="dv">2</span>
&gt; get x;
<span class="dv">2</span></code></pre></div>
<p>Using these we can rewrite our definition of the <code>point</code> object as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> coords;

point (x,y) = (\msg -&gt; <span class="kw">case</span> msg <span class="kw">of</span>
  coords = get x, get y;
  move (dx,dy) = put x (get x+dx), put y (get y+dy);
<span class="kw">end</span>) <span class="kw">when</span>
  x,y = ref x,ref y;
<span class="kw">end</span>;</code></pre></div>
<p>Note that the coordinates are kept in corresponding expression references assigned to the local <code>x</code> and <code>y</code> variables, which now shadow the <code>x</code> and <code>y</code> arguments of <code>point</code>. This makes it possible to have <code>move</code> actually modify the <code>point</code> object in-place:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> p = point (<span class="dv">1</span>,<span class="dv">2</span>); p coords;
<span class="dv">1</span>,<span class="dv">2</span>
&gt; p (move (<span class="dv">2</span>,<span class="dv">3</span>)); p coords;
<span class="dv">3</span>,<span class="dv">5</span>
<span class="dv">3</span>,<span class="dv">5</span></code></pre></div>
<p>It goes without saying that this style isn’t preferred in functional programs, but it certainly has its uses, especially when interfacing to imperative code written in other languages such as C.</p>
<h3 id="data-types">Data Types</h3>
<p>Before we consider the more advanced uses of functions in Pure, a few remarks about data types are in order. Like Lisp, Pure is basically a “typeless” language. That doesn’t mean that there are no data types; in fact, they’re a dime a dozen in Pure. But Pure lets you make up your own data structures as you go, without even formally defining a data type. Data types <em>can</em> be defined and associated with a name pretty much in the same way as functions, but that’s just a convenience and completely optional. This sets Pure apart from statically typed languages like ML and Haskell, where explicit data type definitions are mandatory if you want to introduce new data structures.</p>
<p>As we’ve seen, Pure knows about a few built-in types such as numbers, strings, symbols and functions; everything else is a function application. If a symbol is defined as a function, which merely means that there are some rewriting rules for it, then an application of that function to some arguments may evaluate to something else. But if it doesn’t, then Pure is perfectly happy with that; it just means that the function application is in normal form and thus becomes a “value”. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; cons <span class="dv">3</span> (cons <span class="dv">5</span> nil);
cons <span class="dv">3</span> (cons <span class="dv">5</span> nil)</code></pre></div>
<p>There’s nothing mysterious about this; the <code>cons</code> and <code>nil</code> symbols being used here aren’t defined anywhere, and thus any terms constructed with these symbols are just “data”, no questions asked. We also call such symbols <strong>constructors</strong>. (Note that these are different from constructors in object-oriented programming; constructor applications in term rewriting and functional programming normally don’t execute any code, they’re just literal data objects.)</p>
<p>We can now go ahead and define some operations on this kind of data. (To these ends, it’s necessary to declare <code>nil</code> as a nonfix symbol so that we can use it as a literal in patterns; cf. <a href="#pattern-matching">Pattern Matching</a>.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;

#nil = <span class="dv">0</span>;
#cons x xs = #xs+<span class="dv">1</span>;

head (cons x xs) = x;
tail (cons x xs) = xs;

nil + ys = ys;
cons x xs + ys = cons x (xs + ys);</code></pre></div>
<p>Et voilà, we’ve just created our own list data structure! It’s admittedly still a bit paltry, but if we keep at it and define all the other functions that we need then we could turn it into a full-blown replacement for Pure’s list data structure. In fact Pure’s lists work in a very similar fashion, using the infix ‘<code>:</code>’ constructor and the empty list <code>[]</code> in lieu of <code>cons</code> and <code>nil</code>, respectively.</p>
<p>If we want, we can define a new data type for the data structure we just invented. This works by giving a number of <a href="#type-rules">type rules</a> similar to those used in function definitions. In general, these may denote arbitrary unary predicates, but in our case it’s sufficient to just list the patterns of terms which are supposed to be members of the type (see <a href="#type-rules">Type Rules</a> for an explanation of the definition syntax):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> mylist nil | mylist (cons x xs);</code></pre></div>
<p>This definition lets us use the <code>mylist</code> type as a tag on the left-hand side of an equation, cf. <a href="#pattern-matching">Pattern Matching</a>. But if we’re content with using the patterns directly then we might just as well do without that.</p>
<p>Types consisting solely of constructor term patterns are sometimes also called <strong>algebraic types</strong>. In fact, most user-defined data structures are algebraic types in Pure, and there are plenty of examples of these in the standard library as well. In particular, lists and tuples are algebraic types, as are complex and rational numbers, and most of Pure’s container data types such as dictionaries and sets are also implemented as algebraic types.</p>
<p>Pure differs from most functional languages in that symbols may act as <em>both</em> constructors and defined functions, depending on the arguments. Thus Pure allows you to have “constructors with equations”. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">cons nil ys = ys;
cons (cons x xs) ys = cons x (cons xs ys);</code></pre></div>
<p>Now <code>cons</code> has become a (partially) defined function. Note that these rules make <code>cons</code> associative and turn <code>nil</code> into a left-neutral element for <code>cons</code>. This in fact makes <code>cons</code> behave like concatenation, so that our lists are always flat now:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; cons (cons <span class="dv">1</span> (cons <span class="dv">2</span> nil)) (cons <span class="dv">3</span> nil);
cons <span class="dv">1</span> (cons <span class="dv">2</span> (cons <span class="dv">3</span> nil))</code></pre></div>
<p>Examples of such constructor equations can be found in the standard library as well, such as the rules used to flatten tuples, keep rational numbers in lowest terms, or confine the angles of complex numbers in polar notation.</p>
<p>Another possible use of constructor equations is to check the well-formedness of constructor terms. For instance, in our example we might want to preclude terms like <code>cons 1 2</code> which don’t have a <code>mylist</code> in the second argument to <code>cons</code>. This can be done with a constructor equation which raises an exception in such cases (cf. <a href="#exception-handling">Exception Handling</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; cons x y = <span class="fu">throw</span> (bad_mylist y) <span class="kw">if</span> ~typep mylist y;
&gt; cons <span class="dv">1</span> <span class="dv">2</span>;
&lt;stdin&gt;, line <span class="dv">18</span>: unhandled exception &#39;bad_mylist <span class="dv">2</span>&#39; while evaluating &#39;cons <span class="dv">1</span> <span class="dv">2</span>&#39;</code></pre></div>
<p>A specific kind of algebraic data types which are useful in many applications are the <strong>enumerated types</strong>. In this case the type consists of symbolic constants (nonfix symbols) only, which are the elements of the type. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> sun mon tue wed thu fri sat;
<span class="kw">type</span> day sun | day mon | day tue | day wed | day thu | day fri | day sat;</code></pre></div>
<p>However, to make this type actually work as an enumerated type, we may want to provide definitions for basic arithmetic, <a href="purelib.html#ord"><code>ord</code></a>, <a href="purelib.html#succ"><code>succ</code></a>, etc. This is rather straightforward, but tedious. So as of Pure 0.56, the standard library provides a little utility module, <a href="purelib.html#module-enum">enum</a>, which generates the necessary definitions in an automatic fashion. All we have to do is to import the module and then invoke the <a href="purelib.html#enum"><code>enum</code></a> function on the type and we’re set:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> enum;
enum day;</code></pre></div>
<p>It’s also possible to define the type and make it enumerable in one go using the <a href="purelib.html#defenum"><code>defenum</code></a> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">defenum day [sun,mon,tue,wed,thu,fri,sat];</code></pre></div>
<p>In either case, we can now perform calculations with the members of the type just like with other predefined enumerated types such as numbers and characters:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ord sun;
<span class="dv">0</span>
&gt; day (ans+<span class="dv">3</span>);
wed
&gt; pred sat;
fri
&gt; sun+<span class="dv">3</span>;
wed
&gt; fri-<span class="dv">2</span>;
wed
&gt; fri-tue;
<span class="dv">3</span>
&gt; mon..fri;
[mon,tue,wed,thu,fri]
&gt; sun:tue..sat;
[sun,tue,thu,sat]
&gt; sat:fri..mon;
[sat,fri,thu,wed,tue,mon]</code></pre></div>
<p>A more abstract way to define algebraic types are the <a href="#interface-types">interface types</a>. For instance, if we take another look at the operations defined on our list type, we may observe that the data structure is quite apparent from the patterns in the rules of operations such as ‘<code>#</code>’ and ‘<code>+</code>’. Pure lets us leverage that information by creating an algebraic type from a collection of operation patterns it supports. For instance, we may write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> list_alike <span class="kw">with</span>
  #x::list_alike;
  x::list_alike + y;
<span class="kw">end</span>;</code></pre></div>
<p>This defines a generic type consisting of all terms which may be passed as an argument to both ‘<code>#</code>’ and ‘<code>+</code>’. We can ask the interpreter about the patterns actually matched by the type as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show <span class="kw">interface</span> list_alike
<span class="kw">type</span> list_alike s::<span class="dt">string</span>;
<span class="kw">type</span> list_alike [];
<span class="kw">type</span> list_alike (x:xs);
<span class="kw">type</span> list_alike nil;
<span class="kw">type</span> list_alike (cons x xs);</code></pre></div>
<p>Note that the <code>list_alike</code> type not only includes our own list type, but also any other data structure providing the ‘<code>#</code>’ and ‘<code>+</code>’ operations. This also comprises the standard list and string types for which there are definitions of the ‘<code>#</code>’ and ‘<code>+</code>’ operations in the prelude.</p>
<p>Pure’s interface types are a first attempt at formalizing the notion of <a href="http://en.wikipedia.org/wiki/Duck_typing">Duck typing</a> in Pure. They are thus still a bit experimental and require some diligence in defining the interface operations in a suitable way. Please check <a href="#interface-types">Interface Types</a> in the <a href="#declarations">Declarations</a> section for more information and examples.</p>
<h3 id="recursion">Recursion</h3>
<p>Recursion means that a function calls itself, either directly or indirectly. It is one of the most fundamental techniques in functional programming, and you won’t find many useful Pure programs which don’t use it in one form or another. That’s because most interesting programs execute pieces of code repeatedly. Pure doesn’t have any special looping constructs, so recursion is the only way to do this in Pure. We’ve already seen various examples of this throughout the manual, so let’s take a closer look at it now and learn a few related tricks along the way.</p>
<p>For a simple example, consider the factorial. In order to compute the factorial of an integer <code>n</code>, we need to multiply the positive integers up to <code>n</code>. There’s a straightforward recursive definition which does this:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;</code></pre></div>
<p>If you prefer conditional rules instead, you can also write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
       = <span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>It’s not hard to see how this definition operates. The first rule only applies if <code>n&gt;0</code>, otherwise the second rule kicks in so that <code>fact n</code> becomes <code>1</code> if <code>n</code> is zero or negative (which is consistent with our informal description because in this case the product of all positive integers up to <code>n</code> is the empty product which is <code>1</code> by mathematical convention). The first rule is the interesting one where the recursion happens. If <code>n&gt;0</code> then we may compute <code>fact n</code> by computing <code>fact (n-1)</code> recursively and multiplying that with <code>n</code>, giving <code>n*(n-1)*...*1</code>. Let’s check that this works:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>Note that these numbers grow fairly quickly; they outgrow the 32 bit range and start wrapping around already at <code>n==13</code>. To avoid that, you’ll have to do the computation with bigints, or you could use floating point values if you don’t mind the limited precision.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">13</span>;
<span class="dv">1932053504</span>
&gt; fact 13L;
6227020800L
&gt; fact 30L;
265252859812191058636308480000000L
&gt; fact <span class="dv">30.0</span>;
<span class="dv">2.65252859812191e+32</span></code></pre></div>
<p>However, you’ll run into another, more serious obstacle if you want to compute factorials for some really big values of <code>n</code>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact 200000L;
&lt;stdin&gt;, line <span class="dv">7</span>: unhandled exception &#39;stack_fault&#39; while evaluating &#39;fact 200000L&#39;</code></pre></div>
<p>Oops. What happened there? Well, each recursive invocation of <code>fact</code> needs some small amount of memory on the execution stack, a so-called “stack frame”. Thus, when <code>n</code> becomes big enough then our definition is in danger of running out of stack space. (This is also why you keep hearing in most CS 101 courses that you should try to avoid recursion. If you’ve forgotten how subroutine calls are executed by keeping the execution context on a stack then it’s time to revisit those CS 101 lecture notes now.)</p>
<p>So how can we avoid using all that stack space? In a language like C we’d be using a specialized loop construct instead of recursion, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> fact(<span class="dt">int</span> n)
{
  <span class="dt">int</span> p = <span class="dv">1</span>;
  <span class="cf">while</span> (n&gt;<span class="dv">0</span>) { p = n*p; n = n-<span class="dv">1</span>; }
  <span class="cf">return</span> p;
}</code></pre></div>
<p>Pure doesn’t have a <code>while</code> loop, but we can rewrite the definition so that it becomes <strong>tail-recursive</strong>. This means that the recursive call becomes the final operation on the right-hand side of the recursive rule. The Pure compiler treats this pretty much like a loop in traditional programming languages.</p>
<p>The trick of the trade to turn a recursive function into a tail-recursive one is the <strong>accumulating parameter</strong> technique. The idea here is to have a separate “worker” function which carries around an extra argument representing the intermediate result for the current iteration. The final value of that parameter is then returned as the result. In the case of the factorial this can be done as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n = loop n <span class="dv">1</span> <span class="kw">with</span>
  loop n p = loop (n-<span class="dv">1</span>) (n*p) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
           = p <span class="kw">otherwise</span>;
<span class="kw">end</span>;</code></pre></div>
<p>Note that <code>fact</code> has now become a simple “wrapper” which supplies the initial value of the accumulating parameter (<code>p</code> in this case) for the “worker” function <code>loop</code> which does all the hard work. This kind of design is fairly common in functional programs.</p>
<p>Our worker function is tail-recursive since the recursive call to <code>loop</code> is indeed the final call on the right-hand side of the first equation defining <code>loop</code>. The Pure compiler generates code which optimizes such “tail calls” so that they reuse the stack frame of the calling function. Thus a tail-recursive function like <code>loop</code> will execute in constant stack space; in fact it will be just as efficient as the <code>while</code> loop in our little C snippet above (up to constant factors, of course). After entering our new definition of <code>fact</code> we can now compute <code>fact 200000L</code> just fine (this may take a little while, though, depending on how fast your computer is; the result has 973351 digits):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact 200000L;
<span class="dv">14202253454703144049669463336823059760899</span>... <span class="co">// lots of digits follow</span></code></pre></div>
<p>The accumulating parameter technique isn’t fully general, but it covers all the kinds of simple iterative algorithms which you’d do using loop constructs in traditional programming languages. Some algorithms may require additional techniques such as <strong>tabulation</strong> (keeping track of some or all intermediate results), however, so that they can be written in an iterative form. To see how this can be done in Pure, let’s consider the Fibonacci numbers. These can be computed with the following naive recursive definition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fib n = <span class="kw">if</span> n&lt;=<span class="dv">1</span> <span class="kw">then</span> n <span class="kw">else</span> fib (n-<span class="dv">2</span>) + fib (n-<span class="dv">1</span>);</code></pre></div>
<p>Here are some members of this famous sequence:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map fib (<span class="dv">0</span>..<span class="dv">20</span>);
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">13</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">55</span>,<span class="dv">89</span>,<span class="dv">144</span>,<span class="dv">233</span>,<span class="dv">377</span>,<span class="dv">610</span>,<span class="dv">987</span>,<span class="dv">1597</span>,<span class="dv">2584</span>,<span class="dv">4181</span>,<span class="dv">6765</span>]</code></pre></div>
<p>Note that the right-hand side of the definition above involves <em>two</em> recursive invocations of <code>fib</code> in the <a href="#else"><code>else</code></a> branch. This is bad because it means our definition will need exponential running time. (More precisely, you’ll find that the ratio between the running times of successive invocations quickly starts approaching the golden ratio φ = 1.618…, which is no accident because the times are proportional to the Fibonacci function itself!)</p>
<p>Using a simple iterative algorithm, it is possible to calculate the Fibonacci numbers in linear time instead. Observe that each member of the sequence is simply the sum of the two preceding members. If we keep track of the last two members of the sequence then we can compute the next member with a single addition. This yields the following tail-recursive implementation which uses the same kind of “wrapper-worker” design:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fib n = loop n 0L 1L <span class="kw">with</span>
  loop n a b = loop (n-<span class="dv">1</span>) b (a+b) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
             = a <span class="kw">otherwise</span>;
<span class="kw">end</span>;</code></pre></div>
<p>Note that as a matter of prudence we primed the iteration with the bigints <code>0L</code> and <code>1L</code> so that we can compute large Fibonacci numbers without suffering wrap-around. For instance, try the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fib <span class="dv">1000000</span>;
<span class="dv">1953282128707757731632014947596256332443</span>... <span class="co">// lots of digits follow</span></code></pre></div>
<p>Recursion also naturally occurs when traversing recursive data structures. We’ve already seen various examples of these, such as the binary tree data structure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;

insert nil y         = bin y nil nil;
insert (bin x L R) y = bin x (insert L y) R <span class="kw">if</span> y&lt;x;
                 = bin x L (insert R y) <span class="kw">otherwise</span>;</code></pre></div>
<p>The <code>insert</code> function implements a binary tree insertion algorithm which keeps the tree (represented with the <code>bin</code> and <code>nil</code> constructor symbols) sorted. To these ends, it recurses into the left or right subtree, depending on whether the element <code>y</code> to be inserted is less than the current element <code>x</code> or not. The final result is a new tree which has a <code>nil</code> subtree replaced with a new <code>bin y nil nil</code> subtree at the right location.</p>
<p>If we do an <strong>inorder</strong> traversal of such a binary tree (at each non-<code>nil</code> subtree, first visit the left subtree, then note the element at the top of the current subtree, and finally visit the right subtree), we obtain the elements of the tree in ascending order. This traversal is also implemented recursively, e.g., as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">list nil = [];
list (bin x L R) = list L + (x:list R);</code></pre></div>
<p>Note that these functions can’t be made tail-recursive using the accumulating parameter technique, because traversing a tree structure requires more general forms of recursion. There is in fact a more general <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing</a> technique to do this, which we will look at in <a href="#the-same-fringe-problem">The Same-Fringe Problem</a> below; alas, it’s not as easy as accumulating parameters. Fortunately, some important recursive structures such as lists only involve simple recursion and can thus be traversed and manipulated in a tail-recursive fashion more easily. For instance, consider our earlier definition of the <code>sum</code> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum [] = <span class="dv">0</span>;
sum (x:xs) = x+sum xs;</code></pre></div>
<p>This definition isn’t tail-recursive, but we can easily massage it into this form using the accumulating parameter technique:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum xs::list = loop <span class="dv">0</span> xs <span class="kw">with</span>
  loop s [] = s;
  loop s (x:xs) = loop (s+x) xs;
<span class="kw">end</span>;</code></pre></div>
<p>Functions can also be <strong>mutually recursive</strong>, in which case two or more functions are defined in terms of each other. For instance, suppose that we’d like to skip every other element of a list (i.e., return a list with only the elements having either even or odd indices, respectively). One way to do this involves two functions (named <code>pick</code> and <code>skip</code> here) which recursively call each other:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; pick [] = []; pick (x:xs) = x:skip xs;
&gt; skip [] = []; skip (x:xs) = pick xs;
&gt; pick (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>]
&gt; skip (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</code></pre></div>
<h4 id="a-numeric-root-finder">A Numeric Root Finder</h4>
<p>Let’s now see how we can apply the techniques explained above in the context of a somewhat more practical example: a numeric root finder. That is, we’re going to write a function which takes another function <code>f</code> and determines a (double) value <code>x</code> such that <code>f x</code> becomes (close to) zero.</p>
<p>We’ll develop this in a bottom-up fashion. The method we employ here is known as the Newton-Raphson algorithm, whose basic building block is the following routine <code>improve</code> which improves a given candidate solution <code>x</code> by computing a first-order approximation of the root. This involves computing (a numeric approximation of) the first derivative at the given point, which we do using a second function <code>derive</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">improve f x = x - f x / derive f x;
derive f x = (f (x+dx) - f x) / dx;</code></pre></div>
<p>If you still remember your calculus then these should look familiar. Note that in both functions, <code>f</code> is our target function to be solved and <code>x</code> the current candidate solution. The second equation is nothing but the difference quotient of the function at the point <code>x</code>, using <code>dx</code> as the increment along the <code>x</code> axis. The <code>improve</code> function computes the intersection of the corresponding secant of <code>f</code> with the <code>x</code> axis.</p>
<p>To illustrate how the method works, let’s perform a few improvement steps manually, using the target function <code>f x = x*x-2</code> which becomes zero at the square root of 2. Here we choose a <code>dx</code> value of <code>1e-8</code> and start from the initial guess <code>2</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> dx = <span class="dv">1e-8</span>;
&gt; improve f x = x - f x / derive f x;
&gt; derive f x = (f (x+dx) - f x) / dx;
&gt; f x = x*x-<span class="dv">2</span>;
&gt; improve f <span class="dv">2</span>;
<span class="dv">1.49999999696126</span>
&gt; improve f ans;
<span class="dv">1.41666666616021</span>
&gt; improve f ans;
<span class="dv">1.41421568628522</span>
&gt; improve f ans;
<span class="dv">1.41421356237468</span></code></pre></div>
<p>It should be apparent by now that this converges to the square root of 2 rather quickly. To automate this process, we need another little helper function which iterates <code>improve</code> until the current candidate solution is “good enough”. A suitable termination criterion is that the improvement drops below a certain threshold (i.e., <code>abs (x-f x) &lt;= dy</code> for some reasonably small <code>dy</code>). For extra safety, we’ll also bail out of the loop if a prescribed number <code>n</code> of iterations has been performed. This function can be implemented in a tail-recursive fashion as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">loop n f x = x <span class="kw">if</span> n &lt;= <span class="dv">0</span>;
  = <span class="kw">if</span> abs (x-y) &lt; dy <span class="kw">then</span> y <span class="kw">else</span> loop (n-<span class="dv">1</span>) f y <span class="kw">when</span> y = f x <span class="kw">end</span>;</code></pre></div>
<p>Let’s give it a try:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> dy = <span class="dv">1e-12</span>;
&gt; loop n f x = x <span class="kw">if</span> n &lt;= <span class="dv">0</span>;
&gt;   = <span class="kw">if</span> abs (x-y) &lt; dy <span class="kw">then</span> y <span class="kw">else</span> loop (n-<span class="dv">1</span>) f y <span class="kw">when</span> y = f x <span class="kw">end</span>;
&gt; loop <span class="dv">20</span> (improve dx f) <span class="dv">2</span>;
<span class="dv">1.4142135623731</span>
&gt; ans*ans;
<span class="dv">2.0</span></code></pre></div>
<p>Looks good. So let’s finally wrap this up in a main entry point <code>solve</code> which takes the function to be solved and an initial guess as parameters. Our little helper functions <code>improve</code>, <code>derive</code> and <code>loop</code> are only used internally, so we can turn them into local functions of <code>solve</code>. The additional parameters of the algorithm are implemented as global variables so that we can easily modify their values if needed. The end result looks as follows. Note that the initial guess <code>x</code> is an implicit parameter of the <code>solve</code> function, so the function actually gets invoked as <code>solve f x</code>.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> dx = <span class="dv">1e-8</span>;  <span class="co">// delta value for the approximation of the derivative</span>
<span class="kw">let</span> dy = <span class="dv">1e-12</span>; <span class="co">// delta value for testing convergence</span>
<span class="kw">let</span> nmax = <span class="dv">20</span>;  <span class="co">// maximum number of iterations</span>

solve f = loop nmax (improve f) <span class="kw">with</span>
  loop n f x = x <span class="kw">if</span> n &lt;= <span class="dv">0</span>;
    = <span class="kw">if</span> abs (x-y) &lt; dy <span class="kw">then</span> y <span class="kw">else</span> loop (n-<span class="dv">1</span>) f y <span class="kw">when</span> y = f x <span class="kw">end</span>;
  improve f x = x - f x / derive f x;
  derive f x = (f (x+dx) - f x) / dx;
<span class="kw">end</span>;</code></pre></div>
<p>Here are some examples showing how the <code>solve</code> function is used. Note that we specify the target functions to be solved as lambdas here. E.g., <code>\t -&gt; t^3-x</code> denotes a function mapping <code>t</code> to <code>t^3-x</code>, which becomes zero if <code>t</code> equals the cube root of <code>x</code>.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sqrt x = solve (\t -&gt; t*t-x) x;
&gt; sqrt <span class="dv">2</span>; sqrt <span class="dv">5</span>;
<span class="dv">1.4142135623731</span>
<span class="dv">2.23606797749979</span>
&gt; cubrt x = solve (\t -&gt; t^<span class="dv">3</span>-x) x;
&gt; cubrt <span class="dv">8</span>;
<span class="dv">2.0</span></code></pre></div>
<p>Our little root finder isn’t perfect. It needs a fairly well-behaved target function and/or a good initial guess to work properly. For instance, consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; solve (\t -&gt; <span class="dv">1</span>/t-<span class="dv">2</span>) <span class="dv">1</span>;
<span class="dv">0.00205230175365927</span></code></pre></div>
<p>Here <code>solve</code> didn’t find the real root at 0.5 at all. In fact, if you print the solution candidates then you will find that <code>solve</code> converges rather slowly in this case and thus bails out after 20 iterations before a good solution is found. Increasing the <code>nmax</code> value fixes this:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> nmax = <span class="dv">50</span>;
&gt; solve (\t -&gt; <span class="dv">1</span>/t-<span class="dv">2</span>) <span class="dv">1</span>;
<span class="dv">0.5</span></code></pre></div>
<p>There are other pathological cases where the algorithm performs even more poorly. Further improvements of the method presented here can be found in textbooks on numeric algorithms; the interested reader may want to cut his teeth on these algorithms by translating them to Pure in the way we’ve shown here.</p>
<h4 id="the-same-fringe-problem">The Same-Fringe Problem</h4>
<p>This is one of the classical problems in functional programming which has a straightforward recursive solution, but needs some thought if we want to solve it in an efficient way. Consider a (rooted, directed) tree consisting of branches and leaves. To keep things simple, we may represent these structures as nested lists, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> t1 = [[a,b],c,[[d]],e,[f,[[g,h]]]];
<span class="kw">let</span> t2 = [a,b,c,[[d],[],e],[f,[g,[h]]]];
<span class="kw">let</span> t3 = [[a,b],d,[[c]],e,[f,[[g,h]]]];</code></pre></div>
<p>Thus each inner node of the tree is represented as a list containing its (zero or more) subtrees, and the leaves are the “atomic” (non-list) elements. The <strong>fringe</strong> of such a structure is the list of all leaves in left-to-right order, which can be computed as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fringe t = <span class="kw">if</span> listp t <span class="kw">then</span> catmap fringe t <span class="kw">else</span> [t];</code></pre></div>
<p>Note that <a href="purelib.html#listp"><code>listp</code></a> is a predicate which decides whether its argument is a (proper or improper) list and the <a href="purelib.html#catmap"><code>catmap</code></a> function applies the given function to a list, like <a href="purelib.html#map"><code>map</code></a>, and concatenates all the resulting lists, like <a href="purelib.html#cat"><code>cat</code></a>. Thus, if the argument <code>t</code> is an “atom” (leaf) then <code>fringe</code> simply returns <code>[t]</code>, otherwise it recursively applies itself to all the subtrees and concatenates the results:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fringe t1;
[a,b,c,d,e,f,g,h]
&gt; fringe t2;
[a,b,c,d,e,f,g,h]
&gt; fringe t3;
[a,b,d,c,e,f,g,h]</code></pre></div>
<p>Note that <code>t1</code> and <code>t2</code> differ in structure but have the same fringe, while <code>t1</code> and <code>t3</code> have the same structure but different fringes. The problem now is to decide, given any two trees, whether they have the same fringe. Of course, we can easily solve this by just computing the fringes and comparing them with ‘<a href="purelib.html#==="><code>===</code></a>’ (note that we employ <a href="#syntactic-equality">syntactic equality</a> here which also allows us to compare symbols, for which ‘<a href="purelib.html#=="><code>==</code></a>’ isn’t normally defined):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fringe t1 === fringe t2;
<span class="dv">1</span>
&gt; fringe t3 === fringe t2;
<span class="dv">0</span></code></pre></div>
<p>However, this is rather inefficient since we always have to fully construct the fringes which may need considerable extra time and space if the trees are large. Most of this effort may be completely wasted if we only need to inspect a tiny fraction of the fringes to find out that they’re different, as in the case of <code>t2</code> and <code>t3</code>. Also note that our version of the <code>fringe</code> function isn’t tail-recursive and we may thus run into stack overflows for large trees.</p>
<p>This problem, while posed in an abstract way here, is not only of academic interest. For instance, trees may be used as an alternative string data structure which implements concatenation in constant time by just delaying it. In this case we certainly don’t want to explicitly carry out all those concatenations in order to decide whether two such objects are the same.</p>
<p>Therefore, this problem has been studied extensively and more efficient approaches have been developed. One way to solve the problem involves the technique of <strong>continuation passing</strong> which is a generalization of the accumulating parameter technique we already discussed. It never constructs any part of the fringes explicitly and also works in constant stack space. The algorithm can be implemented in Pure as follows. (This is a slightly modified transliteration of a Lisp program given in Henry Baker’s article “Iterators: Signs of Weakness in Object-Oriented Languages”, ACM OOPS Messenger 4(3), 1993, pp. 18-25, which is also available from <a href="http://home.pipeline.com/~hbaker1/">Henry Baker’s Archive of Research Papers</a>.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">samefringe t1 t2 =
samefringe (\c -&gt; genfringe t1 c done) (\c -&gt; genfringe t2 c done) <span class="kw">with</span>
  done c = c [] done;
  samefringe g1 g2 =
    g1 (\x1 g1 -&gt; g2 (\x2 g2 -&gt; x1===x2 &amp;&amp; (x1===[] || samefringe g1 g2)));
  genfringe [] c g = g c;
  genfringe (x:t) c g = genfringe x c (\c -&gt; genfringe t c g);
  genfringe x c g = c x g;
<span class="kw">end</span>;</code></pre></div>
<p>As Baker admits himself, this style of programming isn’t “particularly perspicuous”, so we’ll explain the algorithm in a moment. But first let us verify that the program indeed works as advertized. It’s helpful to print out the actual comparisons performed in the innermost lambda in the definition of the local <code>samefringe</code> function, which can be done by adding a little debugging statement as follows (this also needs an import clause “<code>using system;</code>” to make the <a href="purelib.html#printf"><code>printf</code></a> function available):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">samefringe g1 g2 =
  g1 (\x1 g1 -&gt; g2 (\x2 g2 -&gt; printf <span class="st">&quot;%s === %s?</span><span class="ch">\n</span><span class="st">&quot;</span> (str x1,str x2) $$
                              x1===x2 &amp;&amp; (x1===[] || samefringe g1 g2)));</code></pre></div>
<p>With this we get:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; samefringe t1 t2;
a === a?
b === b?
c === c?
d === d?
e === e?
f === f?
g === g?
h === h?
[] === []?
<span class="dv">1</span></code></pre></div>
<p>So in this case we do a complete traversal of both trees which is the best that we can hope for if the fringes are the same. Note that the final comparison <code>[] === []</code> ensures that we also hit the end of the two fringes at the same time. This test deals with the corner case that one fringe is a prefix of the other. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> t4 = [[a,b],c,[[d]],e,[f,[[g,h,i]]]];
&gt; samefringe t4 t2;
a === a?
b === b?
c === c?
d === d?
e === e?
f === f?
g === g?
h === h?
i === []?
<span class="dv">0</span></code></pre></div>
<p>Things go a bit differently, however, when comparing <code>t3</code> and <code>t2</code>; as soon as we hit the first discrepany between the two fringes, the algorithm bails out and correctly asserts that the fringes are different:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; samefringe t3 t2;
a === a?
b === b?
d === c?
<span class="dv">0</span></code></pre></div>
<p>Let’s take a closer look at the various parts of the algorithm now. First, the <code>genfringe</code> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">genfringe [] c g = g c;
genfringe (x:t) c g = genfringe x c (\c -&gt; genfringe t c g);
genfringe x c g = c x g;</code></pre></div>
<p>This routine generates the fringe of a tree, given as the first argument, on the fly. The second argument <code>c</code> (the “consumer”) is a function which gets invoked on the current leaf, to do any required processing. (As we’ll see later, it may also get invoked with the special “sentinel” value <code>[]</code> to indicate the end of the fringe.)</p>
<p>The third argument <code>g</code> (the “generator”) is a <strong>continuation</strong>, a kind of “callback function” to be invoked <em>after</em> the current subtree has been traversed, in order to process the remainder of the tree. It takes the consumer function <code>c</code> as its sole argument. Consequently, <code>genfringe</code> simply invokes the continuation <code>g</code> on the consumer <code>c</code> when applied to an empty subtree <code>[]</code>, i.e., if there aren’t any leaves to be processed. This case is handled in the first equation for <code>genfringe</code>.</p>
<p>The second equation for <code>genfringe</code> is the interesting one where the recursion happens. It deals with a nonempty tree <code>x:t</code> by invoking itself recursively on <code>x</code>, setting up a new continuation <code>\c -&gt; genfringe t c g</code>, which will take care of processing the rest of the subtree <code>t</code>, after which it chains to the previous continuation <code>g</code> which will handle the rest of the tree.</p>
<p>The third equation for <code>genfringe</code> handles the case of a non-list argument, i.e., a leaf. In this case we just pass the leaf <code>x</code> to the consumer function <code>c</code> along with the continuation <code>g</code>. The consumer processes <code>x</code> as needed and may then decide to call the continuation <code>g</code> on itself in order to continue processing the rest of the tree, or simply bail out, returning any value. Note that this entire process is tail-recursive, as long as <code>c</code> chains to <code>g</code> as the last call. It thus only needs constant stack space in addition to what <code>c</code> itself uses.</p>
<p>Note that we need an initial continuation <code>g</code> to get the process started. This is provided by the <code>done</code> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">done c = c [] done;</code></pre></div>
<p>As we’ve defined it, <code>done</code> invokes the consumer <code>c</code> on an empty list to signal the end of the fringe. For good measure, it also passes itself as the continuation argument; however, normally the consumer will never use this argument and just bail out when invoked on the <code>[]</code> value.</p>
<p>To see how this works, we can just enter <code>done</code> and <code>genfringe</code> as global functions and invoke them on a suitable consumer function, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; done c = c [] done;
&gt; genfringe [] c g = g c;
&gt; genfringe (x:t) c g = genfringe x c (\c -&gt; genfringe t c g);
&gt; genfringe x c g = c x g;
&gt; c x g = <span class="kw">if</span> x===[] <span class="kw">then</span> g <span class="kw">else</span> printf <span class="st">&quot;%s... &quot;</span> (str x) $$ g c;
&gt; genfringe t1 c done;
a... b... c... d... e... f... g... h... done</code></pre></div>
<p>In the case of <code>samefringe</code>, we use the local <code>samefringe</code> function as our consumer instead. This works pretty much the same, except that <code>samefringe</code> employs <em>two</em> continuations <code>g1</code> and <code>g2</code> to traverse both trees at the same time:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">samefringe g1 g2 =
  g1 (\x1 g1 -&gt; g2 (\x2 g2 -&gt; x1===x2 &amp;&amp; (x1===[] || samefringe g1 g2)));</code></pre></div>
<p>Note that the outer lambda <code>(\x1 g1 -&gt; ...)</code> becomes the consumer for the first generator <code>g1</code> which traverses <code>t1</code>. When called, it then invokes the second generator <code>g2</code>, which traverses <code>t2</code>, on the consumer (inner lambda) <code>(\x2 g2 -&gt; ...)</code>. This in turn does the necessary tests to verify that the current leaf elements are the same, or to bail out from the recursion if they aren’t or if we reached the end of the fringes. Also note that this is still tail-recursive because the short-circuit logical operations <a href="purelib.html#&amp;&amp;"><code>&amp;&amp;</code></a> and <a href="purelib.html#%7C%7C"><code>||</code></a> are both tail-recursive in their second operand (cf. <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>).</p>
<h3 id="higher-order-functions">Higher-Order Functions</h3>
<p>As we have seen, functions are first-class citizens in Pure which can be created on the fly (using partial applications as well as lambdas and local functions), assigned to variables and passed around freely as function arguments and results. Thus it becomes possible to define <strong>higher-order functions</strong> which take other functions as arguments and/or return them as results. This is generally considered a hallmark feature of functional programming, and much of the power of functional programming stems from it. In fact, higher-order functions are so deeply ingrained in the modern functional programming style that you’ll hardly find a nontrivial program that doesn’t use them in some way, and we have already seen many examples of them throughout the manual. While most imperative programming languages today let you treat functions as values, too, they’re typically much more limited in the ways that new functions can be created dynamically. Only recently have partial application and anonymous closures arrived in some mainstream imperative languages, and they are often still rather awkward to use.</p>
<p>The simplest case of a higher-order function is a function which takes another function as an argument. For instance, we have seen the function <a href="purelib.html#map"><code>map</code></a> which applies a function to each member of a list. If it wasn’t in the prelude, it could be defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">map f [] = [];
map f (x:xs) = f x : map f xs;</code></pre></div>
<p>(Note that this isn’t the actual definition from the prelude, which goes to some lengths to make the operation tail-recursive and properly handle lazy lists. But we won’t dive into these technicalities here since we’re only interested in the higher-order aspect right now.)</p>
<p>This definition is rather straightforward: To map a function <code>f</code> to a list, just apply it to the head element <code>x</code> and recurse into the tail <code>xs</code>. The recursion stops at the empty list which is returned as is. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (*<span class="dv">2</span>) (<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>]</code></pre></div>
<p>The prelude includes an entire collection of such generic list functions which have proven their utility as basic building blocks for many list processing tasks. We’ll have a closer look at these later, see <a href="#list-processing">List Processing</a>.</p>
<p>Another numerical example is the function <code>derive</code> which we used in our root finder example to calculate the difference quotient of a function <code>f</code> at a given point <code>x</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">derive f x = (f (x+dx) - f x) / dx;</code></pre></div>
<p>This example is also interesting because we can turn <code>derive</code> into a function mapping functions to other functions, by partially applying it to the target function. So we may write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> dx = <span class="dv">1e-8</span>;
&gt; map (derive square) (<span class="dv">1</span>..<span class="dv">4</span>) <span class="kw">with</span> square x = x*x <span class="kw">end</span>;
[<span class="dv">1.99999998784506</span>,<span class="dv">3.99999997569012</span>,<span class="dv">5.99999996353517</span>,<span class="dv">7.99999995138023</span>]</code></pre></div>
<p>This illustrates an easy way to create new functions from existing ones: partial application. (In fact we also did that when we applied the operator section <code>(*2)</code> using <code>map</code> above. Note that <code>(*2)</code> is a function which doubles its single argument.) This simple recipe is surprisingly powerful. For instance, the prelude defines the function composition operator ‘<a href="purelib.html#."><code>.</code></a>’ as:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">(f.g) x = f (g x);</code></pre></div>
<p>The partial application <code>f.g</code> thus applies two given functions <code>f</code> and <code>g</code> in sequence (first <code>g</code>, then <code>f</code>). Functions of this kind, which create new functions by combining existing ones, are also known as <strong>combinators</strong>. For instance, using ‘<a href="purelib.html#."><code>.</code></a>’ we can easily create a function which “clamps” its argument between given bounds by just combining the <a href="purelib.html#min"><code>min</code></a> and <a href="purelib.html#max"><code>max</code></a> functions from the prelude as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clamp a b = max a . min b;
&gt; map (clamp (-<span class="dv">3</span>) <span class="dv">3</span>) (-<span class="dv">5</span>..<span class="dv">5</span>);
[-<span class="dv">3</span>,-<span class="dv">3</span>,-<span class="dv">3</span>,-<span class="dv">2</span>,-<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>]</code></pre></div>
<p>Note that partial application works with constructor symbols, too:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (<span class="dv">0</span>:) [<span class="dv">1</span>..<span class="dv">3</span>,<span class="dv">4</span>..<span class="dv">6</span>,<span class="dv">7</span>..<span class="dv">9</span>];
[[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>],[<span class="dv">0</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]]</code></pre></div>
<p>Another more direct way to define combinators is to make them return a local or anonymous function. For instance, the following equations lift the ‘<a href="purelib.html#+"><code>+</code></a>’ and ‘<a href="purelib.html#-"><code>-</code></a>’ operators to pointwise operations:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">f + g = \x -&gt; f x + g x <span class="kw">if</span> nargs f &gt; <span class="dv">0</span> &amp;&amp; nargs g &gt; <span class="dv">0</span>;
f - g = \x -&gt; f x - g x <span class="kw">if</span> nargs f &gt; <span class="dv">0</span> &amp;&amp; nargs g &gt; <span class="dv">0</span>;</code></pre></div>
<p>This employs the <a href="purelib.html#nargs"><code>nargs</code></a> function from the standard library which returns the argument count of a global or local function. We use this here to check that the operands are defined functions taking at least one argument. The result is a function which applies the function operands to the given argument and computes their sum and difference, respectively. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (f+g-h) (<span class="dv">1</span>..<span class="dv">10</span>) <span class="kw">with</span> f x = <span class="dv">2</span>*x+<span class="dv">1</span>; g x = x*x; h x = <span class="dv">3</span> <span class="kw">end</span>;
[<span class="dv">1</span>,<span class="dv">6</span>,<span class="dv">13</span>,<span class="dv">22</span>,<span class="dv">33</span>,<span class="dv">46</span>,<span class="dv">61</span>,<span class="dv">78</span>,<span class="dv">97</span>,<span class="dv">118</span>]</code></pre></div>
<p>These rules also handle functions taking multiple arguments, so that you can write, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (max-min) <span class="dv">2</span> <span class="dv">5</span>;
<span class="dv">3</span></code></pre></div>
<p>Constructors can be extended in exactly the same way:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; f,g = \x -&gt; f x, g x <span class="kw">if</span> nargs f &gt; <span class="dv">0</span> &amp;&amp; nargs g &gt; <span class="dv">0</span>;
&gt; (max,min,max-min) <span class="dv">2</span> <span class="dv">5</span>;
<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">3</span></code></pre></div>
<h3 id="list-processing">List Processing</h3>
<p>Pure’s list data structure provides you with a convenient way to represent sequences of arbitrary values. This is one of the few compound data structures which has built-in support by the compiler, so that some syntactic sugar is available which allows you to express certain list operations in a convenient way. But for the most part, lists are implemented in the prelude just like any other data structure.</p>
<p>The empty list is denoted <a href="purelib.html#%5B%5D"><code>[]</code></a>, and compound lists can be put together in a right-recursive fashion using the ‘<a href="purelib.html#:"><code>:</code></a>’ operator. The customary bracketed notation is provided as well, and this is also the syntax the interpreter normally uses to print list values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">1</span>:<span class="dv">2</span>:<span class="dv">3</span>:[];
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>Note that the bracketed notation is just syntactic sugar; internally all list values are represented as right-recursive applications of the ‘<a href="purelib.html#:"><code>:</code></a>’ operator. Thus it is possible to match the head and tail of a list using a pattern like <code>x:xs</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">case</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="kw">of</span> x:xs = x,xs <span class="kw">end</span>;
<span class="dv">1</span>,[<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>Lists can contain any combination of elements (also from different types) and they may also be nested:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [<span class="dv">1</span>,<span class="dv">2.0</span>,[x,y],<span class="st">&quot;a string&quot;</span>];
[<span class="dv">1</span>,<span class="dv">2.0</span>,[x,y],<span class="st">&quot;a string&quot;</span>]</code></pre></div>
<p>List concatenation is denoted <a href="purelib.html#+/list"><code>+</code></a>, and the <a href="purelib.html##"><code>#</code></a>, <a href="purelib.html#!"><code>!</code></a> and <a href="purelib.html#!!"><code>!!</code></a> operators can be used to compute the length of a list and extract elements and slices of a list using zero-based indexing:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [a,b,c]+[x,y,z];
[a,b,c,x,y,z]
&gt; #ans, ans!<span class="dv">5</span>, ans!![<span class="dv">2</span>,<span class="dv">3</span>];
<span class="dv">6</span>,z,[c,x]</code></pre></div>
<p>Note that lists are immutable in Pure (just like most of Pure’s built-in and predefined data structures), so there are no operations which modify lists in-place. E.g., concatenation works as if it was defined recursively by the following rules:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">[]+ys = ys;
(x:xs) + ys = x : (xs+ys);</code></pre></div>
<p>So a new list is created which replaces the empty list in the last component of the left operand with the right operand. This even works if the second operand is no list at all, in which case an improper list value is produced:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [a,b,c]+y;
a:b:c:y</code></pre></div>
<p>These can be useful, e.g., to represent symbolic list values. Note that a <strong>proper</strong> list value contains the empty list <code>[]</code> in its rightmost component; an <strong>improper</strong> list value is one which doesn’t. There are some list functions like <a href="purelib.html#reverse"><code>reverse</code></a> which really need proper lists to work and will throw an exception otherwise, but many predefined operations will deal with improper lists just fine:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map f (x:y:z);
f x:f y:map f z</code></pre></div>
<p>Lists can also be compared using the <a href="purelib.html#==/list"><code>==</code></a> and <a href="purelib.html#~=/list"><code>~=</code></a> operators:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] == [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>];
<span class="dv">0</span></code></pre></div>
<p>Arithmetic sequences are denoted with the <a href="purelib.html#.."><code>..</code></a> operator:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dv">1</span>..<span class="dv">10</span>; <span class="dv">10</span>:<span class="dv">9</span>..<span class="dv">1</span>; <span class="dv">0.0</span>:<span class="dv">0.1</span>..<span class="dv">1.0</span>;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]
[<span class="dv">0.0</span>,<span class="dv">0.1</span>,<span class="dv">0.2</span>,<span class="dv">0.3</span>,<span class="dv">0.4</span>,<span class="dv">0.5</span>,<span class="dv">0.6</span>,<span class="dv">0.7</span>,<span class="dv">0.8</span>,<span class="dv">0.9</span>,<span class="dv">1.0</span>]</code></pre></div>
<p>List comprehensions provide another way to construct (proper) list values using a convenient math-like notation:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [<span class="dv">2</span>^x | x = <span class="dv">1</span>..<span class="dv">10</span>];
[<span class="dv">2.0</span>,<span class="dv">4.0</span>,<span class="dv">8.0</span>,<span class="dv">16.0</span>,<span class="dv">32.0</span>,<span class="dv">64.0</span>,<span class="dv">128.0</span>,<span class="dv">256.0</span>,<span class="dv">512.0</span>,<span class="dv">1024.0</span>]</code></pre></div>
<p>We’ll discuss this construct in more detail later, see <a href="#list-comprehensions">List Comprehensions</a>.</p>
<p>The prelude provides a fairly comprehensive collection of useful list functions, including some powerful generic operations which let you do most common list manipulations with ease. For instance, we have already seen the <a href="purelib.html#map"><code>map</code></a> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (\x-&gt;<span class="dv">2</span>*x-<span class="dv">1</span>) (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</code></pre></div>
<p>There’s also a function <a href="purelib.html#do"><code>do</code></a> which works in the same fashion but throws away all the results and simply returns <code>()</code>. Of course this makes sense only if the applied function has some interesting side-effect. E.g., here’s a quick way to print all members of a list, one per line. This combines the <a href="purelib.html#str"><code>str</code></a> function (which converts any Pure expression to its printable representation, cf. <a href="#string-processing">String Processing</a> below) with the <a href="purelib.html#puts"><code>puts</code></a> function from the <a href="purelib.html#module-system">system</a> module (which is just the corresponding C function, so it prints a string on the terminal, followed by a newline).</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; do (puts.str) (<span class="dv">1</span>..<span class="dv">3</span>);
<span class="dv">1</span>
<span class="dv">2</span>
<span class="dv">3</span>
()</code></pre></div>
<p>Another useful list function is <a href="purelib.html#filter"><code>filter</code></a> which applies a predicate to each member of a list and collects all list elements which satisfy the predicate:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; odd x = x mod <span class="dv">2</span>; even x = ~odd x;
&gt; filter odd (<span class="dv">1</span>..<span class="dv">20</span>);
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]
&gt; filter even (<span class="dv">1</span>..<span class="dv">20</span>);
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>]</code></pre></div>
<p>In addition, the <a href="purelib.html#all"><code>all</code></a> and <a href="purelib.html#any"><code>any</code></a> functions can be used to check whether all or any list elements satisfy a given predicate:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; any even (<span class="dv">1</span>:<span class="dv">3</span>..<span class="dv">20</span>);
<span class="dv">0</span>
&gt; all odd (<span class="dv">1</span>:<span class="dv">3</span>..<span class="dv">20</span>);
<span class="dv">1</span></code></pre></div>
<p>There’s also a family of functions such as <a href="purelib.html#foldl"><code>foldl</code></a> which generalize the notion of aggregate functions such as list sums and products. Starting from a given initial value <code>a</code>, <code>foldl</code> iterates a binary function <code>f</code> over a list <code>xs</code> and returns the accumulated result. It’s defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foldl f a [] = a;
foldl f a (x:xs) = foldl f (f a x) xs;</code></pre></div>
<p>For instance, we can use <code>foldl</code> to compute list sums and products:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldl (+) <span class="dv">0</span> (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">55</span>
&gt; foldl (*) <span class="dv">1</span> (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">3628800</span></code></pre></div>
<p>Note that <a href="purelib.html#foldl"><code>foldl</code></a> (“fold-left”) accumulates results from left to right, so the result accumulated so far is passed as the <em>left</em> argument to the function <code>f</code>. There’s a <a href="purelib.html#foldr"><code>foldr</code></a> (“fold-right”) function which works analogously but collects results from right to left, and accordingly passes the accumulated result in the <em>right</em> argument. Usually this won’t make a difference if the iterated function is associative, but <code>foldl</code> and <code>foldr</code> have lots of applications beyond these simple use cases. For instance, we may use <code>foldl</code> to reverse a list as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldl (flip (:)) [] (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</code></pre></div>
<p>Note that we have to flip the arguments of the ‘<code>:</code>’ constructor here, since <code>foldl</code> passes the accumulated list in the left argument, but ‘<code>:</code>’ wants it on the right. Conversely, we have that:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldr (:) [] (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>This just returns the list unchanged. So the order in which we accumulate results does matter here.</p>
<p>In a similar fashion, we might use <code>foldl</code> (or <code>foldr</code>) to build any kind of compound data structure from a list of its members. For instance, recall our binary tree example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;
insert nil y         = bin y nil nil;
insert (bin x L R) y = bin x (insert L y) R <span class="kw">if</span> y&lt;x;
                     = bin x L (insert R y) <span class="kw">otherwise</span>;</code></pre></div>
<p>We can then use <code>foldl insert</code> to construct a binary tree from its member list as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldl insert nil [<span class="dv">7</span>,<span class="dv">12</span>,<span class="dv">9</span>,<span class="dv">5</span>];
bin <span class="dv">7</span> (bin <span class="dv">5</span> nil nil) (bin <span class="dv">12</span> (bin <span class="dv">9</span> nil nil) nil)</code></pre></div>
<p>Sometimes we’d like to know not just the final result of an aggregate function, but all the intermediate results as well. The <a href="purelib.html#scanl"><code>scanl</code></a> function does this. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; scanl (+) <span class="dv">0</span> (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">21</span>,<span class="dv">28</span>,<span class="dv">36</span>,<span class="dv">45</span>,<span class="dv">55</span>]</code></pre></div>
<p>Note that this computes the same list of partial sums as:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [foldl (+) <span class="dv">0</span> (<span class="dv">1</span>..n) | n = <span class="dv">0</span>..<span class="dv">10</span>];
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">21</span>,<span class="dv">28</span>,<span class="dv">36</span>,<span class="dv">45</span>,<span class="dv">55</span>]</code></pre></div>
<p>However, the former is more efficient since it does all the partial sums in one go.</p>
<p>Like <code>foldl</code>, <code>scanl</code> also has a sibling called <a href="purelib.html#scanr"><code>scanr</code></a> which collects results from right to left, starting at the end of the list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; scanr (+) <span class="dv">0</span> (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">55</span>,<span class="dv">54</span>,<span class="dv">52</span>,<span class="dv">49</span>,<span class="dv">45</span>,<span class="dv">40</span>,<span class="dv">34</span>,<span class="dv">27</span>,<span class="dv">19</span>,<span class="dv">10</span>,<span class="dv">0</span>]</code></pre></div>
<p>Another useful list generation function is <a href="purelib.html#iterwhile"><code>iterwhile</code></a> which keeps applying a function starting at a given initial value, as long as the current value satisfies the given predicate. So another way to generate the odd numbers up to 20 is:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; iterwhile (&lt;=<span class="dv">20</span>) (+<span class="dv">2</span>) <span class="dv">1</span>;
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</code></pre></div>
<p>Or we might collect all powers of 2 which fall into the 16 bit range:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; iterwhile (&lt;<span class="dv">0x10000</span>) (*<span class="dv">2</span>) <span class="dv">1</span>;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">16</span>,<span class="dv">32</span>,<span class="dv">64</span>,<span class="dv">128</span>,<span class="dv">256</span>,<span class="dv">512</span>,<span class="dv">1024</span>,<span class="dv">2048</span>,<span class="dv">4096</span>,<span class="dv">8192</span>,<span class="dv">16384</span>,<span class="dv">32768</span>]</code></pre></div>
<p>There are also various functions to partition a list into different parts according to various criteria. The simplest of these are the <a href="purelib.html#head"><code>head</code></a> and <a href="purelib.html#tail"><code>tail</code></a> functions:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> xs = <span class="dv">1</span>..<span class="dv">10</span>;
&gt; head xs; tail xs;
<span class="dv">1</span>
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>Conversely, the <a href="purelib.html#last"><code>last</code></a> and <a href="purelib.html#init"><code>init</code></a> functions give you the last element of a list, and all but the last element, respectively:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; last xs; init xs;
<span class="dv">10</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]</code></pre></div>
<p>The <a href="purelib.html#take"><code>take</code></a> and <a href="purelib.html#drop"><code>drop</code></a> functions take or remove a given number of initial elements, while <a href="purelib.html#takewhile"><code>takewhile</code></a> and <a href="purelib.html#dropwhile"><code>dropwhile</code></a> take or remove initial elements while a given predicate is satisfied:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; take <span class="dv">4</span> xs; drop <span class="dv">4</span> xs;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
[<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]
&gt; takewhile (&lt;=<span class="dv">4</span>) xs; dropwhile (&lt;=<span class="dv">4</span>) xs;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
[<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>Lists can be reversed with <a href="purelib.html#reverse"><code>reverse</code></a> and sorted using <a href="purelib.html#sort"><code>sort</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; reverse xs;
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]
&gt; sort (&lt;) (xs + ans);
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">10</span>]</code></pre></div>
<p>You can also concatenate a list of lists with the <a href="purelib.html#cat"><code>cat</code></a> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; cat [<span class="dv">1</span>..n | n = <span class="dv">1</span>..<span class="dv">5</span>];
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]</code></pre></div>
<p>Last but not least, there is the <code>zip</code> family of functions which let you combine members of two or more lists in different ways. The <a href="purelib.html#zip"><code>zip</code></a> function itself collects pairs of corresponding elements in two input lists:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; zip (<span class="dv">1</span>..<span class="dv">5</span>) (<span class="st">&quot;a&quot;</span>..<span class="st">&quot;e&quot;</span>);
[(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>),(<span class="dv">3</span>,<span class="st">&quot;c&quot;</span>),(<span class="dv">4</span>,<span class="st">&quot;d&quot;</span>),(<span class="dv">5</span>,<span class="st">&quot;e&quot;</span>)]</code></pre></div>
<p>The effect of <a href="purelib.html#zip"><code>zip</code></a> can be undone with <a href="purelib.html#unzip"><code>unzip</code></a> which returns a pair of lists:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; unzip ans;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],[<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;e&quot;</span>]</code></pre></div>
<p>The <a href="purelib.html#zipwith"><code>zipwith</code></a> function is a generic version of <a href="purelib.html#zip"><code>zip</code></a> which combines corresponding members from two lists using a given binary function <code>f</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; zipwith (*) (<span class="dv">1</span>..<span class="dv">10</span>) (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">9</span>,<span class="dv">16</span>,<span class="dv">25</span>,<span class="dv">36</span>,<span class="dv">49</span>,<span class="dv">64</span>,<span class="dv">81</span>,<span class="dv">100</span>]</code></pre></div>
<p>You might also consider <code>zipwith</code> a variant of <code>map</code> working with two lists at the same time (in fact this operation is also known as <code>map2</code> in some functional programming languages). There are also variations of these functions which work with three lists (<a href="purelib.html#zip3"><code>zip3</code></a>, <a href="purelib.html#unzip3"><code>unzip3</code></a>, <a href="purelib.html#zipwith3"><code>zipwith3</code></a>).</p>
<p>Note that <code>zip</code> itself is equivalent to <code>zipwith (,)</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; zipwith (,) (<span class="dv">1</span>..<span class="dv">5</span>) (<span class="st">&quot;a&quot;</span>..<span class="st">&quot;e&quot;</span>);
[(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>),(<span class="dv">3</span>,<span class="st">&quot;c&quot;</span>),(<span class="dv">4</span>,<span class="st">&quot;d&quot;</span>),(<span class="dv">5</span>,<span class="st">&quot;e&quot;</span>)]</code></pre></div>
<p>Also note that since tuples are formed by just applying the ‘<code>,</code>’ operator repeatedly, you can use multiple calls of <code>zip</code> to piece together tuples of any length:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; zip (<span class="dv">1</span>..<span class="dv">3</span>) (zip (<span class="st">&quot;a&quot;</span>..<span class="st">&quot;c&quot;</span>) [a,b,c]);
[(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>,a),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>,b),(<span class="dv">3</span>,<span class="st">&quot;c&quot;</span>,c)]</code></pre></div>
<p>This can be achieved even more easily by folding <code>zip</code> over a list of lists; here we employ a variation <a href="purelib.html#foldr1"><code>foldr1</code></a> of <a href="purelib.html#foldr"><code>foldr</code></a> which takes the initial value from the beginning of the list.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldr1 zip [<span class="dv">1</span>..<span class="dv">3</span>,<span class="st">&quot;a&quot;</span>..<span class="st">&quot;c&quot;</span>,[a,b,c]];
[(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>,a),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>,b),(<span class="dv">3</span>,<span class="st">&quot;c&quot;</span>,c)]</code></pre></div>
<p>Note that this method easily scales up to as many element lists as you want. Recovering the original element lists is a bit trickier, though, but it can be done using this little helper function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">unzipn n xs = xs <span class="kw">if</span> n&lt;=<span class="dv">1</span>;
            = xs,unzipn (n-<span class="dv">1</span>) ys <span class="kw">when</span> xs,ys = unzip xs <span class="kw">end</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldr1 zip [<span class="dv">1</span>..<span class="dv">3</span>,<span class="st">&quot;a&quot;</span>..<span class="st">&quot;c&quot;</span>,[a,b,c]];
[(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>,a),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>,b),(<span class="dv">3</span>,<span class="st">&quot;c&quot;</span>,c)]
&gt; unzipn <span class="dv">3</span> ans;
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>],[a,b,c]</code></pre></div>
<p>Also, the elements to be zipped don’t have to be singletons, they can themselves be tuples of any size:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldr1 zip [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[a,(),c],[x,y,(z,t)]];
[(<span class="dv">1</span>,a,x),(<span class="dv">2</span>,y),(<span class="dv">3</span>,c,z,t)]</code></pre></div>
<p>But note that in this case you loose the information which elements came from which sublists, so <code>unzip</code> won’t be able to recover the original lists any more. If you need to avoid that then it’s best to use other aggregates such as lists or vectors for the sublist elements.</p>
<p>There are other interesting list functions in the prelude, but we’ll leave it at that for now. Please check the <a href="purelib.html">Pure Library Manual</a> for a full account of the available operations.</p>
<h3 id="string-processing">String Processing</h3>
<p>Let’s take a short break from lists and look at strings. We postponed that until now since strings are in many ways just like lists of characters. In fact the similarities run so deep that in some languages, most notably Haskell, strings <em>are</em> in fact just lists. Pure doesn’t go quite that far; it still represents strings as null-terminated arrays of characters in the UTF-8 encoding, which is a much more compact representation and eases interoperability with C. However, most common list operations also work on strings in an analogous fashion. Thus you can concatenate strings, compute their length, and index, slice and compare them as usual:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="st">&quot;abc&quot;</span>+<span class="st">&quot;xyz&quot;</span>;
<span class="st">&quot;abcxyz&quot;</span>
&gt; #ans, ans!<span class="dv">5</span>, ans!![<span class="dv">2</span>,<span class="dv">3</span>];
<span class="dv">6</span>,<span class="st">&quot;z&quot;</span>,<span class="st">&quot;cx&quot;</span>
&gt; <span class="st">&quot;abc&quot;</span>==<span class="st">&quot;abd&quot;</span>;
<span class="dv">0</span></code></pre></div>
<p>In addition, strings can also be ordered lexicographically:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="st">&quot;abd&quot;</span>&lt;<span class="st">&quot;abcd&quot;</span>;
<span class="dv">0</span>
&gt; <span class="st">&quot;abd&quot;</span>&gt;<span class="st">&quot;abcd&quot;</span>;
<span class="dv">1</span>
&gt; sort (&lt;) [<span class="st">&quot;the&quot;</span>,<span class="st">&quot;little&quot;</span>,<span class="st">&quot;brown&quot;</span>,<span class="st">&quot;fox&quot;</span>];
[<span class="st">&quot;brown&quot;</span>,<span class="st">&quot;fox&quot;</span>,<span class="st">&quot;little&quot;</span>,<span class="st">&quot;the&quot;</span>]</code></pre></div>
<p>Where it makes sense, list operations on strings return again a string result:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; head <span class="st">&quot;abc&quot;</span>; tail <span class="st">&quot;abc&quot;</span>;
<span class="st">&quot;a&quot;</span>
<span class="st">&quot;bc&quot;</span>
&gt; take <span class="dv">4</span> <span class="st">&quot;abcdefg&quot;</span>; drop <span class="dv">4</span> <span class="st">&quot;abcdefg&quot;</span>;
<span class="st">&quot;abcd&quot;</span>
<span class="st">&quot;efg&quot;</span></code></pre></div>
<p>A slight complication arises with the <a href="purelib.html#map"><code>map</code></a> function, because in this case the result is not guaranteed to be a string in all cases. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map ord <span class="st">&quot;HAL&quot;</span>;
[<span class="dv">72</span>,<span class="dv">65</span>,<span class="dv">76</span>]</code></pre></div>
<p>To have <code>map</code> work consistently, it will thus yield a list even in cases where the result <em>could</em> again be represented as a string. If you want a string result instead, you’ll have to do the conversion explicitly, using the <a href="purelib.html#string"><code>string</code></a> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (+<span class="dv">1</span>) <span class="st">&quot;HAL&quot;</span>;
[<span class="st">&quot;I&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;M&quot;</span>]
&gt; <span class="dt">string</span> ans;
<span class="st">&quot;IBM&quot;</span></code></pre></div>
<p>Conversely, you can also convert a string to a list of its characters using either <a href="purelib.html#chars"><code>chars</code></a> or the generic <a href="purelib.html#list/string"><code>list</code></a> conversion function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; list ans;
[<span class="st">&quot;I&quot;</span>,<span class="st">&quot;B&quot;</span>,<span class="st">&quot;M&quot;</span>]</code></pre></div>
<p>As in the case of <a href="purelib.html#map"><code>map</code></a>, this conversion is usually done automatically if a list operation from the prelude is applied to a string. This also happens if a list comprehension draws values from a string:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [x-<span class="dv">1</span> | x = <span class="st">&quot;IBM&quot;</span>];
[<span class="st">&quot;H&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;L&quot;</span>]</code></pre></div>
<p>Talking about characters, these are simply single character strings, so Pure has no separate data type for them. However, there is a type tag <a href="purelib.html#char/type"><code>char</code></a> for the single character strings which can be used in pattern matching:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; isupper x::<span class="dt">char</span> = <span class="st">&quot;A&quot;</span>&lt;=x &amp;&amp; x&lt;= <span class="st">&quot;Z&quot;</span>;
&gt; filter isupper <span class="st">&quot;The Little Brown Fox&quot;</span>;
<span class="st">&quot;TLBF&quot;</span>
&gt; any isupper <span class="st">&quot;The Little Brown Fox&quot;</span>;
<span class="dv">1</span></code></pre></div>
<p>Maybe you wondered how that <code>&quot;HAL&quot; =&gt; &quot;IBM&quot;</code> transformation above came about? Well, the prelude also defines basic arithmetic on characters:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="st">&quot;a&quot;</span>+<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>+<span class="dv">2</span>, <span class="st">&quot;z&quot;</span>-<span class="dv">1</span>;
<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;y&quot;</span>
&gt; <span class="st">&quot;z&quot;</span>-<span class="st">&quot;a&quot;</span>;
<span class="dv">25</span></code></pre></div>
<p>This considers characters as an enumerated data type where each character corresponds to a numeric code point in Unicode. Hence, e.g., <code>&quot;a&quot;+1</code> gives <code>&quot;b&quot;</code> because <code>&quot;b&quot;</code> is the code point following <code>&quot;a&quot;</code> in Unicode, and <code>&quot;b&quot;-&quot;a&quot;</code> gives 1 for the same reason.</p>
<p>So here’s the rot13 encoding in Pure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">rot13 x::<span class="dt">string</span> = <span class="dt">string</span> (map rot13 x) <span class="kw">with</span>
  rot13 c = c+<span class="dv">13</span> <span class="kw">if</span> <span class="st">&quot;a&quot;</span> &lt;= lower c &amp;&amp; lower c &lt;= <span class="st">&quot;m&quot;</span>;
          = c-<span class="dv">13</span> <span class="kw">if</span> <span class="st">&quot;n&quot;</span> &lt;= lower c &amp;&amp; lower c &lt;= <span class="st">&quot;z&quot;</span>;
          = c <span class="kw">otherwise</span>;
  lower c = <span class="st">&quot;a&quot;</span>+(c-<span class="st">&quot;A&quot;</span>) <span class="kw">if</span> <span class="st">&quot;A&quot;</span>&lt;=c &amp;&amp; c&lt;=<span class="st">&quot;Z&quot;</span>;
          = c <span class="kw">otherwise</span>;
<span class="kw">end</span>;</code></pre></div>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rot13 <span class="st">&quot;The quick brown fox&quot;</span>;
<span class="st">&quot;Gur dhvpx oebja sbk&quot;</span>
&gt; rot13 ans;
<span class="st">&quot;The quick brown fox&quot;</span></code></pre></div>
<p>Character arithmetic also makes arithmetic sequences of characters work as expected:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="st">&quot;a&quot;</span>..<span class="st">&quot;k&quot;</span>; <span class="st">&quot;k&quot;</span>:<span class="st">&quot;j&quot;</span>..<span class="st">&quot;a&quot;</span>;
[<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;e&quot;</span>,<span class="st">&quot;f&quot;</span>,<span class="st">&quot;g&quot;</span>,<span class="st">&quot;h&quot;</span>,<span class="st">&quot;i&quot;</span>,<span class="st">&quot;j&quot;</span>,<span class="st">&quot;k&quot;</span>]
[<span class="st">&quot;k&quot;</span>,<span class="st">&quot;j&quot;</span>,<span class="st">&quot;i&quot;</span>,<span class="st">&quot;h&quot;</span>,<span class="st">&quot;g&quot;</span>,<span class="st">&quot;f&quot;</span>,<span class="st">&quot;e&quot;</span>,<span class="st">&quot;d&quot;</span>,<span class="st">&quot;c&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;a&quot;</span>]
&gt; <span class="dt">string</span> (<span class="st">&quot;a&quot;</span>:<span class="st">&quot;c&quot;</span>..<span class="st">&quot;z&quot;</span>);
<span class="st">&quot;acegikmoqsuwy&quot;</span></code></pre></div>
<p>You can also convert between characters and their ordinal numbers using the <a href="purelib.html#ord"><code>ord</code></a> and <a href="purelib.html#chr"><code>chr</code></a> functions:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ord <span class="st">&quot;a&quot;</span>;
<span class="dv">97</span>
&gt; chr (ans+<span class="dv">1</span>);
<span class="st">&quot;b&quot;</span></code></pre></div>
<p>Thus using Horner’s rule we might convert a string of decimal digits to its numeric representation as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foldl (\x c -&gt; <span class="dv">10</span>*x+ord c-ord <span class="st">&quot;0&quot;</span>) <span class="dv">0</span> <span class="st">&quot;123456&quot;</span>;
<span class="dv">123456</span></code></pre></div>
<p>However, there are much easier and more general ways to convert between strings and Pure expressions. Specifically, <a href="purelib.html#val"><code>val</code></a> and <a href="purelib.html#str"><code>str</code></a> can be used to convert between any Pure value and its string representation:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; val <span class="st">&quot;2*(3+4)&quot;</span>; str ans;
<span class="dv">2</span>*(<span class="dv">3</span>+<span class="dv">4</span>)
<span class="st">&quot;2*(3+4)&quot;</span></code></pre></div>
<p>If you also want to evaluate the string representation of a Pure expression then <a href="purelib.html#eval"><code>eval</code></a> is your friend:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; eval <span class="st">&quot;2*(3+4)&quot;</span>;
<span class="dv">14</span></code></pre></div>
<p>Two other convenient functions are <a href="purelib.html#split"><code>split</code></a> which breaks apart a string at a given delimiter string, and <a href="purelib.html#join"><code>join</code></a> which concatenates a list of strings, interpolating the delimiter string between successive list elements:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; split <span class="st">&quot; &quot;</span> <span class="st">&quot;The quick brown fox&quot;</span>;
[<span class="st">&quot;The&quot;</span>,<span class="st">&quot;quick&quot;</span>,<span class="st">&quot;brown&quot;</span>,<span class="st">&quot;fox&quot;</span>]
&gt; join <span class="st">&quot;:&quot;</span> ans;
<span class="st">&quot;The:quick:brown:fox&quot;</span></code></pre></div>
<p>If you don’t need the intervening delimiters then you can also concatenate string lists simply with <a href="purelib.html#strcat"><code>strcat</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; strcat [<span class="st">&quot;The&quot;</span>,<span class="st">&quot;quick&quot;</span>,<span class="st">&quot;brown&quot;</span>,<span class="st">&quot;fox&quot;</span>];
<span class="st">&quot;Thequickbrownfox&quot;</span></code></pre></div>
<p>These operations are all implemented in an efficient way so that they run in linear time. (Note that the <a href="purelib.html#string"><code>string</code></a> conversion function we mentioned above is in fact just <a href="purelib.html#strcat"><code>strcat</code></a> on lists of strings, but it also works with other aggregates such as vectors of strings.)</p>
<p>For more elaborate needs there’s also a suite of functions for doing regular expression matching in the <a href="purelib.html#module-regex">regex</a> module, and the <a href="purelib.html#module-system">system</a> module provides the usual facilities for reading and writing strings from/to text files and the terminal, as well as the <a href="purelib.html#printf"><code>printf</code></a> and <a href="purelib.html#scanf"><code>scanf</code></a> family of functions which are used to print and parse strings according to a given format string. These are all explained in detail in the <a href="purelib.html">Pure Library Manual</a>.</p>
<h3 id="list-comprehensions">List Comprehensions</h3>
<p>List comprehensions are Pure’s main workhorse for generating and processing all kinds of list values. You can think of them as a combination of <a href="purelib.html#map"><code>map</code></a> and <a href="purelib.html#filter"><code>filter</code></a> using a prettier syntax reminiscent of the way in which sets are commonly specified in mathematics. List comprehensions are in fact just syntactic sugar, so anything that can be done with them can also be accomplished with Pure’s generic list functions; but often they are much easier to write and understand.</p>
<p>In the simplest case, list comprehensions are just a shorthand for <a href="purelib.html#map"><code>map</code></a> with lambdas:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [<span class="dv">2</span>*x-<span class="dv">1</span> | x = <span class="dv">1</span>..<span class="dv">10</span>];
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</code></pre></div>
<p>This can be read aloud as “the list of all <code>2*x-1</code> for which <code>x</code> runs through the list <code>1..10</code>”. The part <code>x = 1..10</code> is called a <strong>generator clause</strong>. The comprehension binds <code>x</code> to each member of the list <code>1..10</code> in turn and evaluates the target expression <code>2*x+1</code> in the context of this binding. This is equivalent to the following <code>map</code> expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (\x-&gt;<span class="dv">2</span>*x-<span class="dv">1</span>) (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</code></pre></div>
<p>List comprehensions may also involve <strong>filter clauses</strong>: predicates which determine the elements that are to be included in the result list.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [<span class="dv">2</span>*x-<span class="dv">1</span> | x = <span class="dv">1</span>..<span class="dv">10</span>; x mod <span class="dv">3</span>];
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">19</span>]</code></pre></div>
<p>This can be read as “the list of all <code>2*x-1</code> for which <code>x</code> runs through <code>1..10</code> and for which <code>x mod 3</code> is non-zero” (which means that <code>x</code> is not a multiple of <code>3</code>). It is roughly equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; map (\x-&gt;<span class="dv">2</span>*x-<span class="dv">1</span>) (filter (\x-&gt;x mod <span class="dv">3</span>) (<span class="dv">1</span>..<span class="dv">10</span>));
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">19</span>]</code></pre></div>
<p>List comprehensions can also draw values from other kinds of aggregates such as strings and matrices, but the result is always a list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [x-<span class="dv">1</span> | x = <span class="st">&quot;IBM&quot;</span>];
[<span class="st">&quot;H&quot;</span>,<span class="st">&quot;A&quot;</span>,<span class="st">&quot;L&quot;</span>]
&gt; [<span class="dv">1</span>/x | x = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}; ~x mod <span class="dv">2</span>];
[<span class="dv">0.5</span>,<span class="dv">0.25</span>,<span class="dv">0.166666666666667</span>]</code></pre></div>
<p>List comprehensions can have as many generator and filter clauses as you want. The clauses are considered in left-to-right order so that later clauses may refer to any variables introduced in earlier generator clauses. E.g., here’s how you can generate the list of all pairs <code>(i,j)</code> with <code>1&lt;=i&lt;=j&lt;=5</code> such that <code>i+j</code> is even:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [i,j | i = <span class="dv">1</span>..<span class="dv">5</span>; j = i..<span class="dv">5</span>; ~(i+j) mod <span class="dv">2</span>];
[(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">5</span>),(<span class="dv">2</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">5</span>),(<span class="dv">4</span>,<span class="dv">4</span>),(<span class="dv">5</span>,<span class="dv">5</span>)]</code></pre></div>
<p>The left-hand side of a generator clause can be an arbitary pattern, which is useful if you need to peek at the list elements to see what’s inside. For instance, let’s take the previous result and check that the sums of the number pairs are in fact all even:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [i+j | i,j = ans];
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">10</span>]</code></pre></div>
<p>Generator clauses involving patterns also act as filters; unmatched elements are filtered out automatically:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [i+j | i,j = [<span class="st">&quot;to be ignored&quot;</span>,(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">2</span>),<span class="dv">3</span>]];
[<span class="dv">2</span>,<span class="dv">4</span>]</code></pre></div>
<p>List comprehensions can also be nested to an arbitrary depth. For instance, we may rewrite the “even sums” comprehension from above as follows, in order to group the pairs into sublists for each value of <code>i</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [[i,j | j = i..<span class="dv">5</span>; ~(i+j) mod <span class="dv">2</span>] | i = <span class="dv">1</span>..<span class="dv">5</span>];
[[(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">1</span>,<span class="dv">5</span>)],[(<span class="dv">2</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">4</span>)],[(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">5</span>)],[(<span class="dv">4</span>,<span class="dv">4</span>)],[(<span class="dv">5</span>,<span class="dv">5</span>)]]</code></pre></div>
<p>A notorious example is the following recursive algorithm which implements a variation of Erathosthenes’ classical prime sieve. (This method is actually rather slow and thus not suitable for computing large primes, but we’re not concerned with that here.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">primes n        = sieve (<span class="dv">2</span>..n) <span class="kw">with</span>
  sieve []      = [];
  sieve (p:qs)  = p : sieve [q | q = qs; q mod p];
<span class="kw">end</span>;</code></pre></div>
<p>Note that the sieve recursively filters out the multiples of the current front element <code>p</code> of the list, which, by virtue of the construction, is always a prime number. The result is the list of all primes up to <code>n</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; primes <span class="dv">100</span>;
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">17</span>,<span class="dv">19</span>,<span class="dv">23</span>,<span class="dv">29</span>,<span class="dv">31</span>,<span class="dv">37</span>,<span class="dv">41</span>,<span class="dv">43</span>,<span class="dv">47</span>,<span class="dv">53</span>,<span class="dv">59</span>,<span class="dv">61</span>,<span class="dv">67</span>,<span class="dv">71</span>,<span class="dv">73</span>,<span class="dv">79</span>,<span class="dv">83</span>,<span class="dv">89</span>,<span class="dv">97</span>]</code></pre></div>
<p>List comprehensions are also a useful device to organize backtracking searches. For instance, here’s an algorithm for the n queens problem, which returns the list of all placements of <code>n</code> queens on an <code>n</code> x <code>n</code> board (encoded as lists of <code>n</code> pairs <code>(i,j)</code> with <code>i = 1..n</code>), so that no two queens hold each other in check:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">queens n       = search n <span class="dv">1</span> [] <span class="kw">with</span>
  search n i p = [reverse p] <span class="kw">if</span> i&gt;n;
               = cat [search n (i+<span class="dv">1</span>) ((i,j):p) | j = <span class="dv">1</span>..n; safe (i,j) p];
  safe (i,j) p = ~any (check (i,j)) p;
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2;
<span class="kw">end</span>;</code></pre></div>
<p><a name="lazy-evaluation-and-streams"></a></p>
<h3 id="lazy-evaluation-and-streams">Lazy Evaluation and Streams</h3>
<p>As already mentioned, lists can also be evaluated in a “lazy” fashion, by just turning the tail of a list into a future. This special kind of list is also called a <strong>stream</strong>. Streams enable you to work with infinite lists (or finite lists which are so huge that you would never want to keep them in memory in their entirety). E.g., here’s one way to define the infinite stream of all Fibonacci numbers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> fibs = fibs 0L 1L <span class="kw">with</span> fibs a b = a : fibs b (a+b) &amp; <span class="kw">end</span>;
&gt; fibs;
0L:#&lt;thunk <span class="dv">0xb5d54320</span>&gt;</code></pre></div>
<p>Note the <a href="#&amp;"><code>&amp;</code></a> on the tail of the list in the definition of the local <code>fibs</code> function. This turns the result of <code>fibs</code> into a stream, which is required to prevent the function from recursing into samadhi. Also note that we work with bigints in this example because the Fibonacci numbers grow quite rapidly, so with machine integers the values would soon start wrapping around to negative integers.</p>
<p>Streams like these can be worked with in pretty much the same way as with lists. Of course, care must be taken not to invoke “eager” operations such as <a href="purelib.html##"><code>#</code></a> (which computes the size of a list) on infinite streams, to prevent infinite recursion. However, many list operations work with infinite streams just fine, and return the appropriate stream results. E.g., the <a href="purelib.html#take"><code>take</code></a> function (which retrieves a given number of elements from the front of a list) works with streams just as well as with “eager” lists:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; take <span class="dv">10</span> fibs;
0L:#&lt;thunk <span class="dv">0xb5d54350</span>&gt;</code></pre></div>
<p>Hmm, not much progress there, but that’s just how streams work (or rather they don’t, they’re lazy bums indeed!). Nevertheless, the stream computed with <a href="purelib.html#take"><code>take</code></a> is in fact finite and we can readily convert it to an ordinary list, forcing its evaluation:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; list (take <span class="dv">10</span> fibs);
[0L,1L,1L,2L,3L,5L,8L,13L,21L,34L]</code></pre></div>
<p>An alternative way to achieve this is to cut a “slice” from the stream:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fibs!!(<span class="dv">0</span>..<span class="dv">10</span>);
[0L,1L,1L,2L,3L,5L,8L,13L,21L,34L,55L]</code></pre></div>
<p>Note that since we bound the stream to a variable, the already computed prefix of the stream has been memoized, so that this portion of the stream is now readily available in case we need to have another look at it later. By these means, possibly costly reevaluations are avoided, trading memory for execution speed:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fibs;
0L:1L:1L:2L:3L:5L:8L:13L:21L:34L:55L:#&lt;thunk <span class="dv">0xb5d54590</span>&gt;</code></pre></div>
<p>The prelude also provides some convenience operations for generating stream values. Infinite arithmetic sequences are specified using <code>inf</code> or <code>-inf</code> to denote an upper (or lower) infinite bound for the sequence, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> u = <span class="dv">1</span>..inf; <span class="kw">let</span> v = -<span class="dv">1.0</span>:-<span class="dv">1.2</span>..-inf;
&gt; u!!(<span class="dv">0</span>..<span class="dv">10</span>); v!!(<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>]
[-<span class="dv">1.0</span>,-<span class="dv">1.2</span>,-<span class="dv">1.4</span>,-<span class="dv">1.6</span>,-<span class="dv">1.8</span>,-<span class="dv">2.0</span>,-<span class="dv">2.2</span>,-<span class="dv">2.4</span>,-<span class="dv">2.6</span>,-<span class="dv">2.8</span>,-<span class="dv">3.0</span>]</code></pre></div>
<p>Other useful stream generator functions are <a href="purelib.html#iterate"><code>iterate</code></a>, which keeps applying the same function over and over again, <a href="purelib.html#repeat"><code>repeat</code></a>, which just repeats its argument forever, and <a href="purelib.html#cycle"><code>cycle</code></a>, which cycles through the elements of the given list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; iterate (*<span class="dv">2</span>) <span class="dv">1</span>!!(<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">16</span>,<span class="dv">32</span>,<span class="dv">64</span>,<span class="dv">128</span>,<span class="dv">256</span>,<span class="dv">512</span>,<span class="dv">1024</span>]
&gt; repeat <span class="dv">1</span>!!(<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]
&gt; cycle [<span class="dv">0</span>,<span class="dv">1</span>]!!(<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</code></pre></div>
<p>Moreover, list comprehensions can draw values from streams and return the appropriate stream result:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> rats = [m,n-m | n=<span class="dv">2</span>..inf; m=<span class="dv">1</span>..n-<span class="dv">1</span>; gcd m (n-m) == <span class="dv">1</span>]; rats;
(<span class="dv">1</span>,<span class="dv">1</span>):#&lt;thunk <span class="dv">0xb5d54950</span>&gt;
&gt; rats!!(<span class="dv">0</span>..<span class="dv">10</span>);
[(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">2</span>),(<span class="dv">2</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">4</span>),(<span class="dv">2</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>),(<span class="dv">4</span>,<span class="dv">1</span>),(<span class="dv">1</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">1</span>)]</code></pre></div>
<p>We can also rewrite our prime sieve so that it generates the infinite stream of <em>all</em> prime numbers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">all_primes      = sieve (<span class="dv">2</span>..inf) <span class="kw">with</span>
  sieve (p:qs)  = p : sieve [q | q = qs; q mod p] &amp;;
<span class="kw">end</span>;</code></pre></div>
<p>Note that we can omit the empty list case of <code>sieve</code> here, since the sieve now never becomes empty. Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> P = all_primes;
&gt; P!!(<span class="dv">0</span>..<span class="dv">20</span>);
[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">17</span>,<span class="dv">19</span>,<span class="dv">23</span>,<span class="dv">29</span>,<span class="dv">31</span>,<span class="dv">37</span>,<span class="dv">41</span>,<span class="dv">43</span>,<span class="dv">47</span>,<span class="dv">53</span>,<span class="dv">59</span>,<span class="dv">61</span>,<span class="dv">67</span>,<span class="dv">71</span>,<span class="dv">73</span>]
&gt; P!<span class="dv">299</span>;
<span class="dv">1987</span></code></pre></div>
<p>You can also just print the entire stream. Note that this sieve algorithm isn’t tail-recursive, so the following will eventually result in a stack overflow. But this will take a while, so you may want to hit <code>Ctrl-c</code> when you get bored:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; do (printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>) all_primes;
<span class="dv">2</span>
<span class="dv">3</span>
<span class="dv">5</span>
  ...</code></pre></div>
<p>It’s also possible to convert an ordinary list to a stream:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; stream (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">1</span>:#&lt;thunk <span class="dv">0x7f2692a0f138</span>&gt;</code></pre></div>
<p>This may seem like a silly thing to do, because the original list is already fully known beforehand. But this transformation allows us to traverse the list in a lazy fashion, which can be useful if the list is employed in a list comprehension or processed by functions such as <a href="purelib.html#cat"><code>cat</code></a> and <a href="purelib.html#map"><code>map</code></a>. For instance, we can use this to rewrite the <code>fringe</code> function from <a href="#the-same-fringe-problem">The Same-Fringe Problem</a> so that it calculates the fringe in a lazy fashion:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">lazyfringe t = <span class="kw">if</span> listp t <span class="kw">then</span> catmap lazyfringe (stream t) <span class="kw">else</span> [t];</code></pre></div>
<p>Recall that the fringe of a tree is the list of its leaves in left-to-right order. The tree itself is represented as a nested list, to which <code>lazyfringe</code> applies <a href="purelib.html#stream"><code>stream</code></a> recursively so that the fringe becomes a stream whose elements are only produced on demand:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; lazyfringe [[a,b],c,[[d]],e,[f,[[g,h]]]];
a:#&lt;thunk <span class="dv">0x7f127fc1f090</span>&gt;
&gt; list ans;
[a,b,c,d,e,f,g,h]</code></pre></div>
<p>Hence a simple syntactic equality check now suffices to solve the same-fringe problem in an efficient way. For instance, consider the following sample trees from <a href="#the-same-fringe-problem">The Same-Fringe Problem</a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> t1 = [[a,b],c,[[d]],e,[f,[[g,h]]]];
<span class="kw">let</span> t2 = [a,b,c,[[d],[],e],[f,[g,[h]]]];
<span class="kw">let</span> t3 = [[a,b],d,[[c]],e,[f,[[g,h]]]];</code></pre></div>
<p>Let’s also bind the fringes to some variables so that we can check which parts actually get evaluated:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> l1 = lazyfringe t1;
<span class="kw">let</span> l2 = lazyfringe t2;
<span class="kw">let</span> l3 = lazyfringe t3;</code></pre></div>
<p>Now comparing <code>l3</code> and <code>l2</code> we get:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; l3 === l2; l3; l2;
<span class="dv">0</span>
a:b:d:#&lt;thunk <span class="dv">0x7fd308116178</span>&gt;
a:b:c:#&lt;thunk <span class="dv">0x7fd308116060</span>&gt;</code></pre></div>
<p>As you can see, the two fringes were only constructed as far as needed to decide that they differ. Of course, if we compare <code>l1</code> and <code>l2</code> then the fringes will still be fully constructed before we find that they’re equal:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; l1 === l2; l1; l2;
<span class="dv">1</span>
[a,b,c,d,e,f,g,h]
[a,b,c,d,e,f,g,h]</code></pre></div>
<p>But this doesn’t really matter if we construct the fringes as temporary values, as in:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fringe t1 === fringe t2;</code></pre></div>
<p>Now only the parts of the fringes are in memory which are currently under scrutiny as the ‘<a href="purelib.html#==="><code>===</code></a>’ operator passes over them; the prefixes which have already been found to be equal can be garbage-collected immediately. Moreover, the ‘<a href="purelib.html#==="><code>===</code></a>’ operator is tail-recursive so that the entire equality test can be executed in constant stack space. This gives us an easier way to solve the same-fringe problem which has pretty much the same benefits as our earlier solution using continuations. The latter might still be considered more elegant, because it works without actually constructing the fringes at all. But the solution using lazy evaluation is certainly much simpler.</p>
<p><a name="matrices-and-vectors"></a></p>
<h3 id="matrices-and-vectors">Matrices and Vectors</h3>
<p>Pure has a versatile matrix data structure offering compact storage and efficient random access to its members. Pure matrices work pretty much like in MATLAB or Octave, except that indexes are zero-based and elements are stored in C’s row-major rather than Fortran’s column-major format. They are also binary-compatible with the GNU Scientific Library (<a href="">GSL</a>) so that they can readily be passed to GSL functions for doing numeric calculations.</p>
<p>Pure offers a number of basic matrix operations, such as matrix construction, pattern matching, indexing, slicing, as well as getting the size and dimensions of a matrix. It does <em>not</em> supply built-in support for matrix arithmetic and other linear algebra algorithms, but it’s easy to roll your own if desired, as we’ll see below. (Usually this won’t offer the same performance as the GSL and other carefully optimized C and Fortran routines, however. So if you need to do some heavy-duty number crunching then you might want to take a look at the pure-gsl module available at the Pure website, which is an ongoing project to make the GSL functions available in Pure.)</p>
<p>Matrices are denoted using curly braces in Pure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}; x;
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}</code></pre></div>
<p>Note that the semicolon is used to separate different rows, while the elements inside each row are separated with commas. Thus the above denotes a 2x3 matrix (2 rows, 3 columns). The <a href="purelib.html#dim"><code>dim</code></a> function lets you check the dimensions, while the ‘<a href="purelib.html##"><code>#</code></a>’ operator gives the total number of elements:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; dim x; #x;
<span class="dv">2</span>,<span class="dv">3</span>
<span class="dv">6</span></code></pre></div>
<p>There’s no separate data type for vectors; row and column vectors are simply represented as 1 x n and n x 1 matrices, respectively:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; dim {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>}; dim {<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>};
<span class="dv">1</span>,<span class="dv">3</span>
<span class="dv">3</span>,<span class="dv">1</span></code></pre></div>
<p>Singleton and empty matrices can be denoted as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; dim {<span class="dv">1</span>}; dim {};
<span class="dv">1</span>,<span class="dv">1</span>
<span class="dv">0</span>,<span class="dv">0</span></code></pre></div>
<p>The <a href="#transpose"><code>transpose</code></a> function turns columns into rows and vice versa; in particular, you can also use this to convert between row and column vectors:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; transpose x;
{<span class="dv">1</span>,<span class="dv">4</span>;<span class="dv">2</span>,<span class="dv">5</span>;<span class="dv">3</span>,<span class="dv">6</span>}
&gt; transpose {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>}; transpose {<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>};
{<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>}
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>}</code></pre></div>
<p>Note that matrices are immutable in Pure, so matrix functions like <a href="#transpose"><code>transpose</code></a> always return a <em>new</em> matrix, leaving the original matrix unchanged. (If you need to modify matrices in-place for efficiency, then you can use the GSL or other C or Fortran functions.)</p>
<p>You can change the dimensions of a matrix with the <a href="purelib.html#redim"><code>redim</code></a> function, provided that the size stays the same. So, for instance, we can turn the matrix <code>x</code> into a row vector as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; redim (<span class="dv">1</span>,<span class="dv">6</span>) x;
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}</code></pre></div>
<p>Again, this doesn’t change the original matrix, but returns a new matrix with the same contents and the requested dimensions. This operation also allows you to change the dimensions of an empty matrix which, as we’ve seen above, has dimensions <code>0,0</code> by default. Of course, this requires that either the number of rows or columns is still zero. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; redim (<span class="dv">3</span>,<span class="dv">0</span>) {};
{}
&gt; dim ans;
<span class="dv">3</span>,<span class="dv">0</span></code></pre></div>
<p>Another way to do this is to just construct a zero matrix with zero rows or columns directly, see below. (Note that these different kinds of empty matrices are needed to represent the corner cases. E.g., a linear mapping from 3-dimensional vectors to the zero vector space corresponds to a 0x3 matrix which yields a 3x0 matrix when transposed.)</p>
<p>A number of other specific conversion operations are available, such as <a href="purelib.html#rowvector"><code>rowvector</code></a> and <a href="purelib.html#colvector"><code>colvector</code></a> which convert a matrix to a row or column vector, respectively, or <a href="purelib.html#diag"><code>diag</code></a> which extracts the main diagonal of a matrix:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rowvector x;
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}
&gt; colvector x;
{<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>}
&gt; diag x;
{<span class="dv">1</span>,<span class="dv">5</span>}</code></pre></div>
<p>You can also extract the rows and columns of a matrix, which yields a list of the corresponding row and column vectors, respectively:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rows x; cols x;
[{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>},{<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}]
[{<span class="dv">1</span>;<span class="dv">4</span>},{<span class="dv">2</span>;<span class="dv">5</span>},{<span class="dv">3</span>;<span class="dv">6</span>}]</code></pre></div>
<p>There are a number of other operations which convert between matrices and different kinds of aggregates; please check the <a href="purelib.html#matrix-functions">Matrix Functions</a> section in the <a href="purelib.html">Pure Library Manual</a> for details.</p>
<p>Element access uses the index operator ‘<a href="purelib.html#!/matrix"><code>!</code></a>’. You can either specify a pair <code>(i,j)</code> of row and column indices, or a single index <code>i</code> which treats the entire matrix as a single vector in row-major order:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x!(<span class="dv">0</span>,<span class="dv">2</span>);
<span class="dv">3</span>
&gt; x!<span class="dv">3</span>;
<span class="dv">4</span></code></pre></div>
<p>Slicing is done with the ‘<a href="purelib.html#!!/matrix"><code>!!</code></a>’ operator. The index range can be specified in different ways. First, a pair of lists of row and column indices cuts a rectangular slice from the matrix:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x!!(<span class="dv">0</span>..<span class="dv">1</span>,<span class="dv">1</span>..<span class="dv">2</span>);
{<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">5</span>,<span class="dv">6</span>}</code></pre></div>
<p>Second, a pair of a list and a row or column index cuts slices from individual rows or columns:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x!!(<span class="dv">0</span>,<span class="dv">1</span>..<span class="dv">2</span>); x!!(<span class="dv">0</span>..<span class="dv">1</span>,<span class="dv">2</span>);
{<span class="dv">2</span>,<span class="dv">3</span>}
{<span class="dv">3</span>;<span class="dv">6</span>}</code></pre></div>
<p>Third, a list of pairs of row and column indices, or a list of element indices gives a row vector with all the corresponding elements:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x!![(<span class="dv">0</span>,<span class="dv">2</span>),(<span class="dv">1</span>,<span class="dv">2</span>)];
{<span class="dv">3</span>,<span class="dv">6</span>}
&gt; x!!(<span class="dv">2</span>..<span class="dv">3</span>);
{<span class="dv">3</span>,<span class="dv">4</span>}</code></pre></div>
<p>While most of the slices above are contiguous (a case which the prelude optimizes for), you can also specify indices in any order, possibly with duplicates. So we may not only cut submatrix slices, but also permute and/or copy rows and columns of a matrix along the way:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x!!([<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">0</span>..<span class="dv">2</span>);
{<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>;<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}</code></pre></div>
<p>Matrices can also be constructed from submatrices by arranging the submatrices in rows or columns. In fact, the curly braces accept any combination of submatrices and scalars, provided that all dimensions match up:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {<span class="dv">1</span>,{<span class="dv">2</span>,<span class="dv">3</span>};{<span class="dv">4</span>,<span class="dv">5</span>},<span class="dv">6</span>};
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}
&gt; {{<span class="dv">1</span>;<span class="dv">4</span>},{<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">5</span>,<span class="dv">6</span>}};
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}
&gt; {{<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>},{<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>}};
{<span class="dv">1</span>,<span class="dv">4</span>;<span class="dv">2</span>,<span class="dv">5</span>;<span class="dv">3</span>,<span class="dv">6</span>}</code></pre></div>
<p>The end result <em>must</em> be a rectangular matrix, however, otherwise you’ll get an exception indicating a submatrix whose dimensions don’t match:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {<span class="dv">1</span>,{<span class="dv">2</span>,<span class="dv">3</span>};{<span class="dv">4</span>,<span class="dv">5</span>}};
&lt;stdin&gt;, line <span class="dv">24</span>: unhandled exception &#39;bad_matrix_value {<span class="dv">4</span>,<span class="dv">5</span>}&#39;
while evaluating &#39;{<span class="dv">1</span>,{<span class="dv">2</span>,<span class="dv">3</span>};{<span class="dv">4</span>,<span class="dv">5</span>}}&#39;</code></pre></div>
<p>This “splicing” of submatrices is especially useful when doing linear algebra, where matrices are often composed from smaller “block matrices” or vectors; we’ll see an example of this later. (Sometimes this behaviour also gets in the way, and thus there are ways to disable it; see <a href="#symbolic-matrices">Symbolic Matrices</a> below.)</p>
<p>Pure actually provides several different types of <strong>numeric matrices</strong>, which correspond to the different GSL matrix types for integer, floating point and complex numbers. (Note that complex numbers aren’t a built-in data type in Pure, but there are ways to specify this kind of numbers and perform calculations with them; see the <a href="purelib.html#module-math">math</a> module for details.) Which type of matrix is created by the curly braces depends on the element types. Homogeneous matrices which contain only <a href="#int/type"><code>int</code></a>, <a href="#double/type"><code>double</code></a> or <a href="purelib.html#complex/type"><code>complex</code></a> values yield the corresponding type of GSL matrix. Matrices can also hold any other type of Pure value or an arbitrary mix of values, in which case they become <strong>symbolic matrices</strong>; we’ll discuss these later.</p>
<p>The functions <a href="purelib.html#imatrix"><code>imatrix</code></a>, <a href="purelib.html#dmatrix"><code>dmatrix</code></a> and <a href="purelib.html#cmatrix"><code>cmatrix</code></a> can be used to convert between the different kinds of numeric matrices. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dt">dmatrix</span> {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>};
{<span class="dv">1.0</span>,<span class="dv">2.0</span>,<span class="dv">3.0</span>;<span class="dv">4.0</span>,<span class="dv">5.0</span>,<span class="dv">6.0</span>}
&gt; <span class="dt">imatrix</span> ans;
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}
&gt; <span class="dt">cmatrix</span> ans;
{<span class="dv">1.0</span>+:<span class="dv">0.0</span>,<span class="dv">2.0</span>+:<span class="dv">0.0</span>,<span class="dv">3.0</span>+:<span class="dv">0.0</span>;<span class="dv">4.0</span>+:<span class="dv">0.0</span>,<span class="dv">5.0</span>+:<span class="dv">0.0</span>,<span class="dv">6.0</span>+:<span class="dv">0.0</span>}
&gt; <span class="dt">dmatrix</span> ans;
{<span class="dv">1.0</span>,<span class="dv">0.0</span>,<span class="dv">2.0</span>,<span class="dv">0.0</span>,<span class="dv">3.0</span>,<span class="dv">0.0</span>;<span class="dv">4.0</span>,<span class="dv">0.0</span>,<span class="dv">5.0</span>,<span class="dv">0.0</span>,<span class="dv">6.0</span>,<span class="dv">0.0</span>}</code></pre></div>
<p>(Note that the latter conversion turns a complex into a double matrix, interleaving the real and imaginary parts of the original matrix.)</p>
<p>The same functions can also be used to construct zero matrices with given dimensions:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dt">imatrix</span> (<span class="dv">2</span>,<span class="dv">3</span>);
{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>;<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}
&gt; <span class="dt">dmatrix</span> (<span class="dv">2</span>,<span class="dv">2</span>);
{<span class="dv">0.0</span>,<span class="dv">0.0</span>;<span class="dv">0.0</span>,<span class="dv">0.0</span>}
&gt; <span class="dt">cmatrix</span> (<span class="dv">1</span>,<span class="dv">1</span>);
{<span class="dv">0.0</span>+:<span class="dv">0.0</span>}</code></pre></div>
<p>As already mentioned, this also gives you a direct way to create empty matrices with different dimensions. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dt">imatrix</span> (<span class="dv">0</span>,<span class="dv">3</span>); dim ans;
{}
<span class="dv">0</span>,<span class="dv">3</span></code></pre></div>
<p>The prelude offers matrix versions of the common list operations like <a href="purelib.html#map"><code>map</code></a>, <a href="purelib.html#foldl"><code>foldl</code></a>, <a href="purelib.html#zip"><code>zip</code></a> etc., which provide a way to implement common matrix operations. E.g., multiplying a matrix <code>x</code> with a scalar <code>a</code> amounts to mapping the function <code>(a*)</code> to x, which can be done as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">type</span> scalar x = ~matrixp x;
&gt; a::scalar * x::<span class="dt">matrix</span> = map (a*) x;
&gt; <span class="dv">2</span>*{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>};
{<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>;<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>}</code></pre></div>
<p>Note that the <a href="#matrix/type"><code>matrix</code></a> type tag or the <a href="purelib.html#matrixp"><code>matrixp</code></a> predicate can be used to restrict a variable to matrix values. (The prelude provides a few other types and corresponding predicates for various specific kinds of matrices, see the <a href="purelib.html">Pure Library Manual</a> for details.) In addition, we also introduced a convenience type <code>scalar</code> for non-matrix values here, so that we can distinguish scalar from matrix multiplication which will be discussed below.</p>
<p>Matrix addition and other element-wise operations can be realized using <a href="purelib.html#zipwith"><code>zipwith</code></a>, which combines corresponding elements of two matrices using a given binary function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; x::<span class="dt">matrix</span> + y::<span class="dt">matrix</span> = zipwith (+) x y <span class="kw">if</span> dim x == dim y;
&gt; {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}+{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>;<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>};
{<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>;<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">9</span>}</code></pre></div>
<p>Another way to define matrix functions in Pure is to employ a <strong>matrix pattern</strong>. The Pure language has built-in support for these, so that they work like the other kinds of patterns we’ve already encountered. For instance, to compute the dot product of two 2D vectors, you may write something like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {x1,y1}*{x2,y2} = x1*x2+y1*y2;
&gt; {<span class="dv">2</span>,<span class="dv">3</span>}*{<span class="dv">1</span>,<span class="dv">4</span>};
<span class="dv">14</span></code></pre></div>
<p>Or, to compute the determinant of a 2x2 matrix:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; det {a,b;c,d} = a*d-b*c;
&gt; det {<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>};
-<span class="dv">2</span></code></pre></div>
<p>These patterns are convenient if the dimensions of the involved matrices are small and known beforehand. If this isn’t the case then it’s better to use <strong>matrix comprehensions</strong> instead, which work with arbitrary dimensions and make it easy to express many simple kinds of algorithms which would typically be done using <code>for</code> loops in conventional programming languages.</p>
<p>Matrix comprehensions work pretty much like list comprehensions, but with a special twist: if values are drawn from lists then the generator clauses alternate between row and column generation. (More precisely, the last generator, which varies most quickly, yields a row, the next-to-last one a column of these row vectors, and so on.) This makes matrix comprehensions resemble customary mathematical notation very closely. For instance, here is how we can define an operation to create a square identity matrix of a given dimension (note that the <code>i==j</code> term is just a Pure idiom for the Kronecker symbol):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; eye n = {i==j | i = <span class="dv">1</span>..n; j = <span class="dv">1</span>..n};
&gt; eye <span class="dv">3</span>;
{<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>;<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>;<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>}</code></pre></div>
<p>Of course, matrix comprehensions can also draw values from other matrices instead of lists. In this case the block layout of the component matrices is preserved. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {x,y | x = {<span class="dv">1</span>,<span class="dv">2</span>}; y = {a,b;c,d}};
{(<span class="dv">1</span>,a),(<span class="dv">1</span>,b),(<span class="dv">2</span>,a),(<span class="dv">2</span>,b);(<span class="dv">1</span>,c),(<span class="dv">1</span>,d),(<span class="dv">2</span>,c),(<span class="dv">2</span>,d)}</code></pre></div>
<p>Note that a matrix comprehension involving filters may fail because the filtered result isn’t a rectangular matrix any more. E.g., <code>{2*x|x={1,2,3,-4};x&gt;0}</code> works, as does <code>{2*x|x={-1,2;3,-4};x&gt;0}</code>, but <code>{2*x|x={1,2;3,-4};x&gt;0}</code> doesn’t because the rows of the result matrix have different lengths.</p>
<p>As a slightly more comprehensive example (no pun intended!), here is a definition of matrix multiplication in Pure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">x::<span class="dt">matrix</span> * y::<span class="dt">matrix</span> = {dot u v | u = rows x; v = cols y} <span class="kw">with</span>
  dot u v = foldl (+) <span class="dv">0</span> $ zipwith (*) u (rowvector v);
<span class="kw">end</span> <span class="kw">if</span> m==n <span class="kw">when</span> _,m = dim x; n,_ = dim y <span class="kw">end</span>;</code></pre></div>
<p>The basic building block in this example is the dot product of two vectors, which is defined as a local function. The matrix product is obtained by simply calculating the dot product of all the rows of <code>x</code> with all the columns of <code>y</code>. To make this work, the rows of <code>x</code> should be the same length as the columns of <code>y</code>, we check this condition in the guard of the rule. Let’s give it a try:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {<span class="dv">1</span>,<span class="dv">0</span>;<span class="dv">0</span>,<span class="dv">1</span>}*{<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>};
{<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>}
&gt; {<span class="dv">0</span>,<span class="dv">1</span>;<span class="dv">1</span>,<span class="dv">0</span>}*{<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>};
{<span class="dv">3</span>,<span class="dv">4</span>;<span class="dv">1</span>,<span class="dv">2</span>}
&gt; {<span class="dv">0</span>,<span class="dv">1</span>;<span class="dv">1</span>,<span class="dv">0</span>;<span class="dv">1</span>,<span class="dv">1</span>}*{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>};
{<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>;<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>;<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>}
&gt; {<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>}*{<span class="dv">1</span>;<span class="dv">1</span>};
{<span class="dv">3</span>;<span class="dv">7</span>}</code></pre></div>
<p>Well, that was easy. So let’s take a look at a more challenging example, Gaussian elimination, which can be used to solve systems of linear equations. The algorithm brings a matrix into “row echelon” form, a generalization of triangular matrices. The resulting system can then be solved quite easily using back substitution.</p>
<p>Here is a Pure implementation of the algorithm. Note that the real meat is in the pivoting and elimination step (<code>step</code> function) which is iterated over all columns of the input matrix. In each step, <code>x</code> is the current matrix, <code>i</code> the current row index, <code>j</code> the current column index, and <code>p</code> keeps track of the current permutation of the row indices performed during pivoting. The algorithm returns the updated matrix <code>x</code>, row index <code>i</code> and row permutation <code>p</code>.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">gauss_elimination x::<span class="dt">matrix</span> = p,x
<span class="kw">when</span> n,m = dim x; p,_,x = foldl step (<span class="dv">0</span>..n-<span class="dv">1</span>,<span class="dv">0</span>,x) (<span class="dv">0</span>..m-<span class="dv">1</span>) <span class="kw">end</span>;

<span class="co">// One pivoting and elimination step in column j of the matrix:</span>
step (p,i,x) j
= <span class="kw">if</span> max_x==<span class="dv">0</span> <span class="kw">then</span> p,i,x
  <span class="kw">else</span>
    <span class="co">// updated row permutation and index:</span>
    transp i max_i p, i+<span class="dv">1</span>,
    {<span class="co">// the top rows of the matrix remain unchanged:</span>
     x!!(<span class="dv">0</span>..i-<span class="dv">1</span>,<span class="dv">0</span>..m-<span class="dv">1</span>);
     <span class="co">// the pivot row, divided by the pivot element:</span>
     {x!(i,l)/x!(i,j)                 | l=<span class="dv">0</span>..m-<span class="dv">1</span>};
     <span class="co">// subtract suitable multiples of the pivot row:</span>
     {x!(k,l)-x!(k,j)*x!(i,l)/x!(i,j) | k=i+<span class="dv">1</span>..n-<span class="dv">1</span>; l=<span class="dv">0</span>..m-<span class="dv">1</span>}}
<span class="kw">when</span>
  n,m = dim x; max_i, max_x = pivot i (col x j);
  x = <span class="kw">if</span> max_x&gt;<span class="dv">0</span> <span class="kw">then</span> swap x i max_i <span class="kw">else</span> x;
<span class="kw">end</span> <span class="kw">with</span>
  pivot i x       = foldl max (<span class="dv">0</span>,<span class="dv">0</span>) [j,abs (x!j)|j=i..#x-<span class="dv">1</span>];
  max (i,x) (j,y) = <span class="kw">if</span> x&lt;y <span class="kw">then</span> j,y <span class="kw">else</span> i,x;
<span class="kw">end</span>;</code></pre></div>
<p>Please refer to any good textbook on numerical mathematics for a closer description of the algorithm. But here is a brief rundown of what happens in each elimination step: First we find the pivot element in column <code>j</code> of the matrix. (We’re doing partial pivoting here, i.e., we only look for the element with the largest absolute value in column <code>j</code>, starting at row <code>i</code>. That’s usually good enough to achieve numerical stability.) If the pivot is zero then we’re done (the rest of the pivot column is already zeroed out). Otherwise, we bring it into the pivot position (swapping row <code>i</code> and the pivot row), divide the pivot row by the pivot, and subtract suitable multiples of the pivot row to eliminate the elements of the pivot column in all subsequent rows. Finally we update <code>i</code> and <code>p</code> accordingly and return the result.</p>
<p>In order to complete the implementation, we still need the following little helper functions to swap two rows of a matrix (this is used in the pivoting step) and to apply a transposition to a permutation (represented as a list):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">swap x i j = x!!(transp i j (<span class="dv">0</span>..n-<span class="dv">1</span>),<span class="dv">0</span>..m-<span class="dv">1</span>) <span class="kw">when</span> n,m = dim x <span class="kw">end</span>;
transp i j p = [p!tr k | k=<span class="dv">0</span>..#p-<span class="dv">1</span>]
<span class="kw">with</span> tr k = <span class="kw">if</span> k==i <span class="kw">then</span> j <span class="kw">else</span> <span class="kw">if</span> k==j <span class="kw">then</span> i <span class="kw">else</span> k <span class="kw">end</span>;</code></pre></div>
<p>Finally, let us define a convenient print representation of double matrices a la <a href="#octave">Octave</a> (the meaning of the <a href="#__show__"><code>__show__</code></a> function is explained in <a href="#pretty-printing">Pretty-Printing</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;
__show__ x::<span class="dt">matrix</span>
= strcat [printd j (x!(i,j))|i=<span class="dv">0</span>..n-<span class="dv">1</span>; j=<span class="dv">0</span>..m-<span class="dv">1</span>] + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
<span class="kw">with</span> printd <span class="dv">0</span> = sprintf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">%10.5f&quot;</span>; printd _ = sprintf <span class="st">&quot;%10.5f&quot;</span> <span class="kw">end</span>
<span class="kw">when</span> n,m = dim x <span class="kw">end</span> <span class="kw">if</span> dmatrixp x;</code></pre></div>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = <span class="dt">dmatrix</span> {<span class="dv">2</span>,<span class="dv">1</span>,-<span class="dv">1</span>,<span class="dv">8</span>; -<span class="dv">3</span>,-<span class="dv">1</span>,<span class="dv">2</span>,-<span class="dv">11</span>; -<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,-<span class="dv">3</span>};
&gt; x; gauss_elimination x;
   <span class="dv">2.00000</span>   <span class="dv">1.00000</span>  -<span class="dv">1.00000</span>   <span class="dv">8.00000</span>
  -<span class="dv">3.00000</span>  -<span class="dv">1.00000</span>   <span class="dv">2.00000</span> -<span class="dv">11.00000</span>
  -<span class="dv">2.00000</span>   <span class="dv">1.00000</span>   <span class="dv">2.00000</span>  -<span class="dv">3.00000</span>
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>],
   <span class="dv">1.00000</span>   <span class="dv">0.33333</span>  -<span class="dv">0.66667</span>   <span class="dv">3.66667</span>
   <span class="dv">0.00000</span>   <span class="dv">1.00000</span>   <span class="dv">0.40000</span>   <span class="dv">2.60000</span>
   <span class="dv">0.00000</span>   <span class="dv">0.00000</span>   <span class="dv">1.00000</span>  -<span class="dv">1.00000</span></code></pre></div>
<h3 id="symbolic-matrices">Symbolic Matrices</h3>
<p>As already mentioned, matrices may contain not just numbers but any kind of Pure values, in which case they become <em>symbolic</em> matrices. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {<span class="dv">1</span>,<span class="dv">2.0</span>,3L;a,b,c};
{<span class="dv">1</span>,<span class="dv">2.0</span>,3L;a,b,c}</code></pre></div>
<p>The <a href="purelib.html#smatrixp"><code>smatrixp</code></a> predicate gives you a quick way to check whether a matrix is a symbolic one:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; smatrixp ans;
<span class="dv">1</span></code></pre></div>
<p>Note that this may not always be obvious. For instance, you can use the <a href="purelib.html#smatrix"><code>smatrix</code></a> function to explicitly convert a numeric matrix:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dt">smatrix</span> {<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>};
{<span class="dv">1</span>,<span class="dv">2</span>;<span class="dv">3</span>,<span class="dv">4</span>}</code></pre></div>
<p>This still looks the same as the original matrix, but <code>smatrixp</code> reveals that it’s in fact a symbolic matrix:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; smatrixp ans;
<span class="dv">1</span></code></pre></div>
<p>Also note that the empty matrix is by default a symbolic matrix, as are matrices containing bigints:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; smatrixp {};
<span class="dv">1</span>
&gt; smatrixp {1L,2L;3L,4L};
<span class="dv">1</span></code></pre></div>
<p>However, you can easily convert these to a numeric type if needed, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="dt">dmatrix</span> {1L,2L;3L,4L};
{<span class="dv">1.0</span>,<span class="dv">2.0</span>;<span class="dv">3.0</span>,<span class="dv">4.0</span>}</code></pre></div>
<p>Symbolic matrices are a convenient data structure for storing arbitrary collections of values which provides fast random access to its members. In particular, they can also be nested, and thus multidimensional tensors or arrays of arbitrary dimension can be realized as nested symbolic vectors. However, you have to be careful when constructing such values, because the <code>{...}</code> construct normally combines submatrices to larger matrices. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}};
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>}</code></pre></div>
<p>One way to inhibit this splicing of the submatrices in a larger matrix is to use the quote operator (cf. <a href="#the-quote">The Quote</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;{{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}};
{{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}}</code></pre></div>
<p>Note that this result is really different from <code>{1,2;3,4}</code>. The latter is a 2x2 integer matrix, while the former is a symbolic vector a.k.a. 1x2 matrix whose elements happen to be two integer vectors. So a double index will be required to access the subvector elements:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ans!<span class="dv">0</span>!<span class="dv">1</span>;
<span class="dv">2</span></code></pre></div>
<p>You can also match these values with a nested matrix pattern, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> {{a,b},{c,d}} = &#39;{{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}};
&gt; a,b,c,d;
<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span></code></pre></div>
<p>Unfortunately, the quote operator in fact inhibits evaluation of <em>all</em> embedded subterms which may be undesirable if the matrix expression contains arithmetic (as in <code>'{{1+1,2*3}}</code>), so this method works best for constant matrices. A more general way to create a symbolic vector of matrices is provided by the <a href="purelib.html#vector"><code>vector</code></a> function from the prelude, which is applied to a list of the vector elements as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; vector [{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}];
{{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}}</code></pre></div>
<p>Calls to the <a href="purelib.html#vector"><code>vector</code></a> function can be nested to an arbitrary depth to obtain higher-dimensional “arrays”:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; vector [vector [{<span class="dv">1</span>,<span class="dv">2</span>}],vector [{<span class="dv">3</span>,<span class="dv">4</span>}]];
{{{<span class="dv">1</span>,<span class="dv">2</span>}},{{<span class="dv">3</span>,<span class="dv">4</span>}}}</code></pre></div>
<p>This obviously becomes a bit unwieldy for higher dimensions, but Pure 0.56 and later provide the following shorthand notation:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {|{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}|};
{{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">3</span>,<span class="dv">4</span>}}
&gt; {|{|{<span class="dv">1</span>,<span class="dv">2</span>}|},{|{<span class="dv">3</span>,<span class="dv">4</span>}|}|};
{{{<span class="dv">1</span>,<span class="dv">2</span>}},{{<span class="dv">3</span>,<span class="dv">4</span>}}}</code></pre></div>
<p>This makes it much more convenient to denote nested vector values. Note that the <code>{| |}</code> construct doesn’t use any special magic, it’s just a standard outfix operator implemented as a Pure macro. For more details please check the description of the <a href="purelib.html#non-splicing">non-splicing vector brackets</a> in the <a href="purelib.html">Pure Library Manual</a>.</p>
<p><a name="record-data"></a></p>
<h3 id="record-data">Record Data</h3>
<p>Symbolic matrices also provide a means to represent simple record-like data, by encoding records as symbolic vectors consisting of “hash pairs” of the form <code>key =&gt; value</code>. This kind of data structure is very convenient to represent aggregates with lots of different components. Since the components of records can be accessed by indexing with key values, you don’t have to remember which components are stored in which order, just knowing the keys of the required members is enough. In contrast, tuples, lists and other kinds of constructor terms quickly become unwieldy for such purposes.</p>
<p>The keys used for indexing the record data must be either symbols or strings, while the corresponding values may be arbitrary Pure values. The prelude provides some operations on these special kinds of matrices, which let you retrieve vector elements by indexing and perform non-destructive updates, see the <a href="purelib.html#record-functions">Record Functions</a> section in the <a href="purelib.html">Pure Library Manual</a> for details. Here are a few examples which illustrate how to create records and work with them:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> r = {x=&gt;<span class="dv">5</span>, y=&gt;<span class="dv">12</span>};
&gt; recordp r, member r x;
<span class="dv">1</span>,<span class="dv">1</span>
&gt; r!y; r!![y,x];
<span class="dv">12</span>
{<span class="dv">12</span>,<span class="dv">5</span>}
&gt; insert r (x=&gt;<span class="dv">99</span>);
{x=&gt;<span class="dv">99</span>,y=&gt;<span class="dv">12</span>}
&gt; insert ans (z=&gt;<span class="dv">77</span>);
{x=&gt;<span class="dv">99</span>,y=&gt;<span class="dv">12</span>,z=&gt;<span class="dv">77</span>}
&gt; delete ans z;
{x=&gt;<span class="dv">99</span>,y=&gt;<span class="dv">12</span>}</code></pre></div>
<p>Records can also be nested:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> r = {a =&gt; {b=&gt;<span class="dv">1</span>,c=&gt;<span class="dv">2</span>}, b =&gt; <span class="dv">2</span>};
&gt; r!a, r!b, r!a!b;
{b=&gt;<span class="dv">1</span>,c=&gt;<span class="dv">2</span>},<span class="dv">2</span>,<span class="dv">1</span></code></pre></div>
<p>Note the use of the “hash rocket” <a href="purelib.html#=%3E"><code>=&gt;</code></a> which denotes the <code>key=&gt;value</code> associations in a record. The hash rocket is a constructor declared as an infix operator in the prelude, see the <a href="purelib.html#hash-pairs">Hash Pairs</a> section in the <a href="purelib.html">Pure Library Manual</a> for details. There’s one caveat here, however. Since neither ‘<code>=&gt;</code>’ nor ‘<code>!</code>’ treat their key operand in a special way, you’ll have to take care that the key symbols do not evaluate to something else, as might be the case if they are bound to a global or local variable or parameterless function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> u = <span class="dv">99</span>;
&gt; {u=&gt;u};
{<span class="dv">99</span>=&gt;<span class="dv">99</span>}</code></pre></div>
<p>In the case of global variables and function symbols, you might protect the symbol with a quote (see <a href="#the-quote">The Quote</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {&#39;u=&gt;u};
{u=&gt;<span class="dv">99</span>}
&gt; ans!&#39;u;
<span class="dv">99</span></code></pre></div>
<p>However, even the quote doesn’t save you from local variable substitution:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {&#39;u=&gt;u} <span class="kw">when</span> u = <span class="dv">99</span> <span class="kw">end</span>;
{<span class="dv">99</span>=&gt;<span class="dv">99</span>}</code></pre></div>
<p>In such cases you’ll either have to rename the local variable, or use the prelude function <a href="purelib.html#val"><code>val</code></a> to quote the symbol:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {&#39;u=&gt;v} <span class="kw">when</span> v = <span class="dv">99</span> <span class="kw">end</span>;
{u=&gt;<span class="dv">99</span>}
&gt; {val <span class="st">&quot;u&quot;</span>=&gt;u} <span class="kw">when</span> u = <span class="dv">99</span> <span class="kw">end</span>;
{u=&gt;<span class="dv">99</span>}</code></pre></div>
<p>It’s also possible to directly use strings as keys instead, which may actually be more convenient in some cases:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> r = {<span class="st">&quot;x&quot;</span>=&gt;<span class="dv">5</span>, <span class="st">&quot;y&quot;</span>=&gt;<span class="dv">12</span>};
&gt; keys r; vals r;
{<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>}
{<span class="dv">5</span>,<span class="dv">12</span>}
&gt; update r <span class="st">&quot;y&quot;</span> (r!<span class="st">&quot;y&quot;</span>+<span class="dv">1</span>);
{<span class="st">&quot;x&quot;</span>=&gt;<span class="dv">5</span>,<span class="st">&quot;y&quot;</span>=&gt;<span class="dv">13</span>}</code></pre></div>
<p>You can also mix strings and symbols as keys in the same record (but note that strings and symbols are always distinct, so <code>y</code> and <code>&quot;y&quot;</code> are really two different keys here):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; insert r (y=&gt;<span class="dv">99</span>);
{<span class="st">&quot;x&quot;</span>=&gt;<span class="dv">5</span>,<span class="st">&quot;y&quot;</span>=&gt;<span class="dv">12</span>,y=&gt;<span class="dv">99</span>}</code></pre></div>
<p>As records are in fact just special kinds of matrices, the standard matrix operations can be used on record values as well. For instance, the matrix constructor provides an alternative way to quickly augment a record with a collection of new <code>key=&gt;value</code> associations:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> r = {x=&gt;<span class="dv">5</span>, y=&gt;<span class="dv">12</span>};
&gt; <span class="kw">let</span> r = {r, x=&gt;<span class="dv">7</span>, z=&gt;<span class="dv">3</span>}; r;
{x=&gt;<span class="dv">5</span>,y=&gt;<span class="dv">12</span>,x=&gt;<span class="dv">7</span>,z=&gt;<span class="dv">3</span>}
&gt; r!x, r!z;
<span class="dv">7</span>,<span class="dv">3</span>
&gt; delete r x;
{x=&gt;<span class="dv">5</span>,y=&gt;<span class="dv">12</span>,z=&gt;<span class="dv">3</span>}
&gt; ans!x;
<span class="dv">5</span></code></pre></div>
<p>As the example shows, this may produce duplicate keys, but these are handled gracefully; indexing and updates will always work with the <em>last</em> association for a given key in the record. If necessary, you can remove duplicate entries from a record as follows; this will only keep the last association for each key:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; record r;
{x=&gt;<span class="dv">7</span>,y=&gt;<span class="dv">12</span>,z=&gt;<span class="dv">3</span>}</code></pre></div>
<p>In fact, the <a href="purelib.html#record"><code>record</code></a> operation not only removes duplicates, but also orders the record entries by keys. This produces a kind of normalized representation which is useful if you want to compare or combine two record values irrespective of the ordering of the fields. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; record {x=&gt;<span class="dv">5</span>, y=&gt;<span class="dv">12</span>} === record {y=&gt;<span class="dv">12</span>, x=&gt;<span class="dv">5</span>};
<span class="dv">1</span></code></pre></div>
<p>The <a href="purelib.html#record"><code>record</code></a> function can also be used to construct a normalized record directly from a list or tuple of hash pairs:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; record [x=&gt;<span class="dv">5</span>, x=&gt;<span class="dv">7</span>, y=&gt;<span class="dv">12</span>];
{x=&gt;<span class="dv">7</span>,y=&gt;<span class="dv">12</span>}</code></pre></div>
<p>Other matrix operations such as <a href="purelib.html#map"><code>map</code></a>, <a href="purelib.html#foldl"><code>foldl</code></a>, etc., and matrix comprehensions can be applied to records just as easily. This enables you to perform bulk updates of record data in a straightforward way. For instance, here’s how you can define a function <code>maprec</code> which applies a function to all values stored in a record:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; maprec f = map (\(u=&gt;v) -&gt; u=&gt;f v);
&gt; maprec (*<span class="dv">2</span>) {x=&gt;<span class="dv">5</span>,y=&gt;<span class="dv">12</span>};
{x=&gt;<span class="dv">10</span>,y=&gt;<span class="dv">24</span>}</code></pre></div>
<p>Another example: The following <code>ziprec</code> function collects pairs of values stored under common keys in two records (we also normalize the result here so that duplicate keys are always removed):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ziprec x y = record {u=&gt;(x!u,y!u) | u = keys x; member y u};
&gt; ziprec {a=&gt;<span class="dv">3</span>,x=&gt;<span class="dv">5</span>,y=&gt;<span class="dv">12</span>} {x=&gt;<span class="dv">10</span>,y=&gt;<span class="dv">24</span>,z=&gt;<span class="dv">7</span>};
{x=&gt;(<span class="dv">5</span>,<span class="dv">10</span>),y=&gt;(<span class="dv">12</span>,<span class="dv">24</span>)}</code></pre></div>
<p>Thus the full power of generic matrix operations is available for records, which turns them into a much more versatile data structure than records in conventional programming languages, which are usually limited to constructing records and accessing or modifying their components.</p>
<p>Note that since the values stored in records can be arbitrary Pure values, you can also have records with mutable components by making use of Pure’s <a href="purelib.html#expression-references">expression references</a>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> r = {x=&gt;ref <span class="dv">1</span>,y=&gt;ref <span class="dv">2</span>}; maprec get r;
{x=&gt;<span class="dv">1</span>,y=&gt;<span class="dv">2</span>}
&gt; put (r!x) <span class="dv">99</span>; maprec get r;
<span class="dv">99</span>
{x=&gt;<span class="dv">99</span>,y=&gt;<span class="dv">2</span>}</code></pre></div>
<p>Another interesting application of records are the “virtual method tables” used in object-oriented programming. Pure has a built-in <a href="purelib.html#__locals__"><code>__locals__</code></a> macro which captures the environment of local functions at the point of the call and returns it as a list of hash pairs of function symbols and the corresponding closures. We can readily convert this into a record data structure which can be used as a virtual method table. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; record __locals__ <span class="kw">with</span> f x = x+<span class="dv">1</span> <span class="kw">end</span>;
{f=&gt;f}
&gt; (ans!f) <span class="dv">99</span>;
<span class="dv">100</span></code></pre></div>
<p>Here is a little helper macro that we can use to turn the virtual method table into an anonymous function which, when applied to a symbol, returns the appropriate closure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">def</span> obj = (\x -&gt; vt!x) <span class="kw">when</span>
  vt = record __locals__;
<span class="kw">end</span>;</code></pre></div>
<p>Continuing our example from <a href="#local-functions-and-variables">Local Functions and Variables</a>, we can now implement the <code>point</code> object as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">point (x,y) = obj <span class="kw">with</span>
  coords () = get x,get y;
  move (dx,dy) = put x (get x+dx), put y (get y+dy);
<span class="kw">end</span> <span class="kw">when</span>
  x,y = ref x,ref y;
<span class="kw">end</span>;</code></pre></div>
<p>Note that <code>obj</code> really needs to be implemented as a macro so that its body is inserted into the <code>point</code> function and the <code>_locals__</code> call is executed in the context of the local function environment there. (A macro is like a function which gets evaluated at compile time; see the <a href="#macros">Macros</a> section for details.) Also note that we changed the <code>coords</code> “method” so that it takes a dummy parameter <code>()</code> now; this prevents premature evaluation of the closure. If <code>coords</code> was a parameterless function then its value would be fixed at the time we construct the virtual method table, which is not what we want here.</p>
<p>Now we can write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> p = point (<span class="dv">1</span>,<span class="dv">2</span>);
&gt; p coords ();
<span class="dv">1</span>,<span class="dv">2</span>
&gt; p move (<span class="dv">2</span>,<span class="dv">3</span>);
<span class="dv">3</span>,<span class="dv">5</span>
&gt; p coords ();
<span class="dv">3</span>,<span class="dv">5</span></code></pre></div>
<p>This provides us with an interesting way to represent stateful objects which works very much like object-oriented programming. What’s still missing here is the inheritance of methods from other objects, but this can now be done by just combining virtual method tables using the record operations we’ve already discussed above; we leave this as an exercise for the interested reader.</p>
<h3 id="the-quote">The Quote</h3>
<p>We’ve already seen some uses of the quote in previous examples, so let’s have a closer look at it now. As described in <a href="#special-forms">Special Forms</a>, the <a href="#quote"><code>quote</code></a> operation quotes an expression, so that it can be passed around and manipulated freely until its value is needed, in which case you can pass it to the <a href="purelib.html#eval"><code>eval</code></a> function to obtain its value. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> x = &#39;(<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span>); x;
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span>
&gt; eval x;
<span class="dv">4180.0</span></code></pre></div>
<p>Lisp programmers will be well familiar with this operation which enables some powerful metaprogramming techniques. However, there are some notable differences to Lisp’s quote. In particular, <a href="#quote"><code>quote</code></a> only inhibits the evaluation of global variables, <em>local</em> variables are substituted as usual:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (\x -&gt; &#39;(<span class="dv">2</span>*x+<span class="dv">1</span>)) <span class="dv">99</span>;
<span class="dv">2</span>*<span class="dv">99</span>+<span class="dv">1</span>
&gt; foo x = &#39;(<span class="dv">2</span>*x+<span class="dv">1</span>);
&gt; foo <span class="dv">99</span>; foo $ &#39;(<span class="dv">7</span>/y);
<span class="dv">2</span>*<span class="dv">99</span>+<span class="dv">1</span>
<span class="dv">2</span>*(<span class="dv">7</span>/y)+<span class="dv">1</span>
&gt; &#39;(x+<span class="dv">1</span>) <span class="kw">when</span> x = &#39;(<span class="dv">2</span>*<span class="dv">3</span>) <span class="kw">end</span>;
<span class="dv">2</span>*<span class="dv">3</span>+<span class="dv">1</span>
&gt; &#39;(<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^n) <span class="kw">when</span> n = <span class="dv">12</span> <span class="kw">end</span>;
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span></code></pre></div>
<p>Local parameterless functions are treated in the same fashion:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;(<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^n) <span class="kw">with</span> n = <span class="dv">12</span> <span class="kw">end</span>;
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span></code></pre></div>
<p>Note that, in contrast, for global variables (and functions) we have:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> n = <span class="dv">12</span>;
&gt; &#39;(<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^n);
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^n</code></pre></div>
<p>This discrepancy may come as a surprise (or even annoyance) to real Lisp weenies, but it does have its advantages. As illustrated in the examples above, local variable substitution makes it easy to fill in the variable parts in a quoted “template” expression, without any need for an arguably complex tool like Lisp’s “quasiquote”. (But note that it is quite easy to define the quasiquote in Pure if you want it. See the <a href="#recursive-macros">Recursive Macros</a> section for a simplified version; a full implementation can be found in the Pure library.)</p>
<p>If you do need to quote a symbol which is already being used as a local variable or function in the current context, you can do this by supplying the symbol as a string to the prelude function <a href="purelib.html#val"><code>val</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; val <span class="st">&quot;x&quot;</span>+x <span class="kw">when</span> x = <span class="dv">99</span> <span class="kw">end</span>;
x+<span class="dv">99</span></code></pre></div>
<p>Also note that while local functions are always substituted in a quoted expression, <em>applications</em> involving local functions can still be quoted:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;foo <span class="dv">99</span> <span class="kw">with</span> foo x = <span class="dv">2</span>*x+<span class="dv">1</span> <span class="kw">end</span>;
foo <span class="dv">99</span>
&gt; eval ans;
<span class="dv">199</span></code></pre></div>
<p>The quote also inhibits evaluation inside matrix expressions, including the “splicing” of embedded submatrices:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;{<span class="dv">1</span>,<span class="dv">2</span>+<span class="dv">3</span>,<span class="dv">2</span>*<span class="dv">3</span>};
{<span class="dv">1</span>,<span class="dv">2</span>+<span class="dv">3</span>,<span class="dv">2</span>*<span class="dv">3</span>}
&gt; &#39;{<span class="dv">1</span>,{<span class="dv">2</span>,<span class="dv">3</span>},<span class="dv">4</span>};
{<span class="dv">1</span>,{<span class="dv">2</span>,<span class="dv">3</span>},<span class="dv">4</span>}</code></pre></div>
<p><a href="#special-expressions">Special expressions</a> (conditionals, lambda and the <a href="#case"><code>case</code></a>, <a href="#when"><code>when</code></a> and <a href="#with"><code>with</code></a> constructs) can be quoted as well. But since these constructs cannot be directly represented at runtime, the quote actually produces some ordinary “placeholder” terms for these:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;(x+<span class="dv">1</span> <span class="kw">when</span> x = &#39;(<span class="dv">2</span>*<span class="dv">3</span>) <span class="kw">end</span>);
x+<span class="dv">1</span> __when__ [x--&gt;&#39;(<span class="dv">2</span>*<span class="dv">3</span>)]
&gt; eval ans;
<span class="dv">2</span>*<span class="dv">3</span>+<span class="dv">1</span>
&gt; &#39;(<span class="dv">2</span>*<span class="dv">42</span>+(f <span class="dv">6</span> <span class="kw">with</span> f n = <span class="dv">2</span>^(<span class="dv">2</span>*n) <span class="kw">end</span>));
<span class="dv">2</span>*<span class="dv">42</span>+(f <span class="dv">6</span> __with__ [f n--&gt;<span class="dv">2</span>^(<span class="dv">2</span>*n)])
&gt; eval ans;
<span class="dv">4180.0</span></code></pre></div>
<p>Note that these placeholders are in fact special built-in macros which reconstruct the special expression when evaluated. Moreover, special expressions are implicitly quoted when they occur on the left-hand side of an equation or as an argument of a “<a href="#cmdoption-pure-pragma--quoteargs"><code>quoteargs</code></a>” macro call. This is often used to implement macros which manipulate these constructs as literals. For instance, the following macro swaps the arguments in a lambda:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --quoteargs bar
&gt; <span class="kw">def</span> bar (\x y -&gt; z) = __eval__ (&#39;(\y x -&gt; z));
&gt; show bar
<span class="kw">def</span> bar (__lambda__ [x,y] z) = __eval__ (&#39;__lambda__ [y,x] z);
&gt; baz = bar (\a b -&gt; a-b);
&gt; show baz
baz = \b a -&gt; a-b;
&gt; baz <span class="dv">2</span> <span class="dv">3</span>;
<span class="dv">1</span></code></pre></div>
<p>The <a href="#macros">Macros</a> section explains in detail how this meta programming works.</p>
<h2 id="declarations">Declarations</h2>
<p>Pure is a very terse language by design. Usually you don’t declare much stuff, you just define it and be done with it. However, there are a few constructs which let you declare symbols with special attributes and manage programs consisting of several source modules:</p>
<ul>
<li>symbol declarations determine “scope” and “fixity” of a symbol;</li>
<li><a href="#interface"><code>interface</code></a> declarations specify abstract data types;</li>
<li><a href="#extern"><code>extern</code></a> declarations specify external C functions;</li>
<li><a href="#using"><code>using</code></a> clauses let you include other scripts in a Pure script;</li>
<li><a href="#namespace"><code>namespace</code></a> declarations let you avoid name clashes and thereby make it easier to manage large programs consisting of many separate modules.</li>
</ul>
<p>These are toplevel elements (cf. <a href="#toplevel">Toplevel</a>):</p>
<pre class="sourceCode bnf"><code>item : symbol_decl | interface_decl | extern_decl
    | using_decl | namespace_decl</code></pre>
<p>We defer the discussion of <a href="#extern"><code>extern</code></a> declarations to the <a href="#c-interface">C Interface</a> section. The other kinds of declarations are described in the following subsections.</p>
<p><a name="public"></a></p>
<p><a name="private"></a></p>
<p><a name="infix"></a></p>
<p><a name="infixl"></a></p>
<p><a name="infixr"></a></p>
<p><a name="prefix"></a></p>
<p><a name="postfix"></a></p>
<p><a name="outfix"></a></p>
<p><a name="nonfix"></a></p>
<h3 id="symbol-declarations">Symbol Declarations</h3>
<p>Symbol declarations declare special attributes of a symbol, such as their scope (whether they are “public” or “private”) and their fixity (for operator symbols). The syntax of these declarations is as follows:</p>
<pre class="sourceCode bnf"><code>symbol_decl : scope qualified_symbol+ &quot;;&quot;
    | [scope] fixity qualified_symbol+ &quot;;&quot;
scope : &quot;public&quot; | &quot;private&quot;
fixity : &quot;nonfix&quot; | &quot;outfix&quot;
    | (&quot;infix&quot;|&quot;infixl&quot;|&quot;infixr&quot;|&quot;prefix&quot;|&quot;postfix&quot;) precedence
precedence : integer | &quot;(&quot; op &quot;)&quot;</code></pre>
<p>Scope declarations take the following form:</p>
<dl>
<dt><code>public symbol ...;</code></dt>
<dd>
</dd>
<dt><code>private symbol ...;</code></dt>
<dd><!-- -->
</dd>
</dl>
<p>This declares the listed symbols as public or private, respectively. Each symbol must either be an identifier or a sequence of punctuation characters. The latter kind of symbols <em>must</em> always be declared before use, whereas ordinary identifiers can be used without a prior declaration in which case they are declared implicitly and default to public scope, meaning that they are visible everywhere in a program. An explicit public declaration of ordinary identifiers is thus rarely needed (unless you want to declare symbols as members of a specific namespace, see <a href="#namespaces">Namespaces</a> below). Symbols can also be declared private, meaning that the symbol is visible only in the namespace it belongs to. This is explained in more detail under <a href="#private-symbols">Private Symbols</a> in the <a href="#namespaces">Namespaces</a> section below.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> The declared symbols may optionally be qualified with a namespace prefix, but since new symbols can only be created in the current namespace, the namespace prefix must match the current namespace (see <a href="#namespaces">Namespaces</a>). Thus the namespace prefix isn’t really needed, unless you want to declare a symbol which happens to be a reserved Pure keyword (cf. <a href="#lexical-matters">Lexical Matters</a>). In this specific case, it will be necessary to use a qualified name so that the symbol isn’t mistaken for a keyword.</p>
</blockquote>
<hr />
<p>Note that to declare several symbols in a single declaration, you can list them all with whitespace in between. The same syntax applies to the other types of symbol declarations discussed below. (Commas are <em>not</em> allowed as delimiters here, as they may occur as legal symbol constituents in the list of symbols.) The <a href="#public"><code>public</code></a> and <a href="#private"><code>private</code></a> keywords can also be used as a prefix in any of the special symbol declarations discussed below, to specify the scope of the declared symbols (if the scope prefix is omitted, it defaults to <a href="#public"><code>public</code></a>).</p>
<p>The following “fixity” declarations are available for introducing special operator symbols. This changes the way that these symbols are parsed and thus provides you with a limited means to extend the Pure language at the lexical and syntactical level.</p>
<dl>
<dt><code>infix level symbol ...;</code></dt>
<dd>
</dd>
<dt><code>infixl level symbol ...;</code></dt>
<dd>
</dd>
<dt><code>infixr level symbol ...;</code></dt>
<dd>
</dd>
<dt><code>prefix level symbol ...;</code></dt>
<dd>
</dd>
<dt><code>postfix level symbol ...;</code></dt>
<dd><!-- -->
</dd>
</dl>
<p>Pure provides you with a theoretically unlimited number of different precedence levels for user-defined infix, prefix and postfix operators. Precedence levels are numbered starting at 0; larger numbers indicate higher precedence. (For practical reasons, the current implementation does require that precedence numbers can be encoded as 24 bit unsigned machine integers, giving you a range from 0 to 16777215, but this should be large enough to incur no real limitations on applications. Also, the operator declarations in the prelude have been set up to leave enough “space” between the “standard” levels so that you can easily sneak in new operator symbols at low, high or intermediate precedences.)</p>
<p>On each precedence level, you can declare (in order of increasing precedence) <a href="#infix"><code>infix</code></a> (binary non-associative), <a href="#infixl"><code>infixl</code></a> (binary left-associative), <a href="#infixr"><code>infixr</code></a> (binary right-associative), <a href="#prefix"><code>prefix</code></a> (unary prefix) and <a href="#postfix"><code>postfix</code></a> (unary postfix) operators. For instance, here is a typical excerpt from the prelude (the full table can be found in the <a href="purelib.html#prelude">Prelude</a> section of the <a href="purelib.html">Pure Library Manual</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">infix</span>  <span class="dv">1800</span> &lt; &gt; &lt;= &gt;= == ~= ;
<span class="kw">infixl</span> <span class="dv">2200</span> + - ;
<span class="kw">infixl</span> <span class="dv">2300</span> * / div mod ;
<span class="kw">infixr</span> <span class="dv">2500</span> ^ ;
<span class="kw">prefix</span> <span class="dv">2600</span> # ;</code></pre></div>
<hr />
<blockquote>
<p><strong>Note:</strong> Unary minus plays a special role in the syntax. Like in Haskell and following mathematical tradition, unary minus is the only prefix operator symbol which is also used as an infix operator, and is always on the same precedence level as binary minus, whose precedence may be chosen freely in the prelude. (The minus operator is the only symbol which gets that special treatment; all other operators must have distinct lexical representations.) Thus, with the standard prelude, <code>-x+y</code> will be parsed as <code>(-x)+y</code>, whereas <code>-x*y</code> is the same as <code>-(x*y)</code>. Also note that the notation <code>(-)</code> always denotes the binary minus operator; the unary minus operation can be denoted using the built-in <code>neg</code> function.</p>
</blockquote>
<hr />
<p>Instead of denoting the precedence by an explicit integer value, you can also specify an existing operator symbol enclosed in parentheses. Thus the following declaration gives the <code>++</code> operator the same precedence as <code>+</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">infixl</span> (+) ++ ;</code></pre></div>
<p>The given symbol may be of a different fixity than the declaration, but it must have a proper precedence level (i.e., it must be an infix, prefix or postfix symbol). E.g., the following declaration gives <code>^^</code> the same precedence level as the infix <code>^</code> symbol, but turns it into a postfix operator:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">postfix</span> (^) ^^ ;</code></pre></div>
<p>Pure also provides unary outfix operators, which work like in Wm Leler’s constraint programming language <a href="#bertrand">Bertrand</a>. These can be declared as follows:</p>
<dl>
<dt><code>outfix left right ...;</code></dt>
<dd><!-- -->
</dd>
</dl>
<p>Outfix operators let you define your own bracket structures. The operators must be given as pairs of matching left and right symbols (which must be distinct). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">outfix</span> |: :| BEGIN END;</code></pre></div>
<p>After this declaration you can write bracketed expressions like <code>|:x:|</code> or <code>BEGIN foo, bar END</code>. These are always at the highest precedence level (i.e., syntactically they work like parenthesized expressions). Just like other operators, you can turn outfix symbols into ordinary functions by enclosing them in parentheses, but you have to specify the symbols in matching pairs, such as <code>(BEGIN END)</code>.</p>
<p>Pure also has a notation for “nullary” operators, that is, “operators without operands”. These are used to denote special literals which simply stand for themselves. They are introduced using a <a href="#nonfix"><code>nonfix</code></a> declaration:</p>
<dl>
<dt><code>nonfix symbol ...;</code></dt>
<dd><!-- -->
</dd>
</dl>
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> red green blue;</code></pre></div>
<p>Semantically, nonfix symbols are a kind of “symbolic constants”. However, it is important to note the difference to <em>defined</em> constants, which are symbols bound to a constant value by means of a <a href="#const"><code>const</code></a> definition. In fact, there are some use cases where a symbol may be <em>both</em> a defined constant and a nonfix symbol, see <a href="#constant-definitions">Constant Definitions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for details.</p>
<p>Syntactically, nonfix symbols work just like ordinary identifiers, so they may stand whereever an identifier is allowed (no parentheses are required to “escape” them). However, just like other kinds of operators, they may also consist of punctuation (which isn’t allowed in ordinary identifiers). The other difference to ordinary identifiers is that nonfix symbols are always interpreted as literals, even if they occur in a variable position on the left-hand side of a rule. So, with the above declaration, you can write something like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = <span class="kw">case</span> x <span class="kw">of</span> red = green; green = blue; blue = red <span class="kw">end</span>;
&gt; map foo [red,green,blue];
[green,blue,red]</code></pre></div>
<p>Thus nonfix symbols are pretty much like nullary constructor symbols in languages like Haskell. Non-fixity is just a syntactic attribute, however. Pure doesn’t enforce that such values are irreducible, so you can still write a “constructor equation” like the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; red = blue;
&gt; map foo [red,green,blue];
[blue,blue,blue]</code></pre></div>
<p>Examples for all types of symbol declarations can be found in the <a href="purelib.html#prelude">prelude</a> which declares a bunch of standard (arithmetic, relational, logical) operator symbols as well as the list and pair constructors ‘<code>:</code>’ and ‘<code>,</code>’, and a few nonfix symbols (<a href="purelib.html#true"><code>true</code></a> and <a href="purelib.html#false"><code>false</code></a>, as well as different kinds of exceptions).</p>
<p><a name="interface"></a></p>
<p><a name="interface-types"></a></p>
<h3 id="interface-types">Interface Types</h3>
<p>Besides the “concrete” types already described in the <a href="#type-rules">Type Rules</a> section, Pure provides another, more abstract way to characterize a type through the collection of operations it supports. These <strong>interface types</strong> work pretty much like in Google’s <a href="#go">Go</a> programming language. They provide a safe form of <a href="http://en.wikipedia.org/wiki/Duck_typing">Duck typing</a> in which the operations available on a type are stated explicitly, and hence members of the type are always known to provide all of the listed operations.</p>
<p>An interface declaration gives the type name along with a collection of patterns, the so-called <strong>signature</strong> which specifies the manifest operations of the type:</p>
<pre class="sourceCode bnf"><code>interface_decl : &quot;interface&quot; qualified_identifier
       &quot;with&quot; interface_item* &quot;end&quot; &quot;;&quot;
interface_item : pattern &quot;;&quot;
    | &quot;interface&quot; qualified_identifier &quot;;&quot;</code></pre>
<p>Interfaces thus consist of two kinds of items:</p>
<ul>
<li>The patterns, which indicate which operations are supported by the type, and which arguments they expect. This may be anything that can occur as the left-hand side of an ordinary function definition, cf. <a href="#general-rules">General Rules</a>.</li>
<li>The name of another interface type. This causes the signature of the named interface type to be included in the interface type being defined, which effectively turns the new interface type into a subtype of the existing one.</li>
</ul>
<p>The gist of an interface is in its patterns, more precisely: in the pattern variables which have the name of the interface as a type tag. The precise meaning of the patterns is as follows:</p>
<ul>
<li>The patterns are matched against the left-hand sides of ordinary function definitions. If a left-hand side matches, any argument pattern substituted for a variable tagged with the interface type becomes a “candidate pattern” of the type.</li>
<li>The type consists of all candidate patterns which can be matched by some candidate pattern of <em>each</em> interface function. That is, candidate patterns which are only supported by some but not all of the interface functions, are eliminated.</li>
<li>Finally, all trivial candidate patterns (<code>x</code> where <code>x</code> is just a variable without any type tag, which thus matches <em>any</em> value) are eliminated as well.</li>
</ul>
<p>Interface patterns often take a simple form like the following,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> foo <span class="kw">with</span> foo x::foo y z; <span class="kw">end</span>;</code></pre></div>
<p>specifying the number of arguments of the interface function along with the position of the interface type argument. However, general patterns are permitted, in order to further restrict the left-hand sides of the function definitions to be taken into consideration. Specifically, note that type tags other than the interface type must always be matched <em>literally</em> on the left-hand sides of equations. Thus,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> foo <span class="kw">with</span> foo x::foo y::<span class="dt">int</span>; <span class="kw">end</span>;</code></pre></div>
<p>matches any rule of the form</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x y::<span class="dt">int</span> = ...;</code></pre></div>
<p>but <em>not</em>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x <span class="dv">0</span> = ...;
foo x y::bar = ...;</code></pre></div>
<p>(unless <code>bar</code> happens to be an alias of the <code>int</code> type, of course). In such cases it is necessary to explicitly add these patterns to the interface if you want them to be included.</p>
<p>Interface patterns may contain the interface type tag any number of times, yielding candidate patterns for each occurrence of the interface type tag in the pattern. For instance, here is a quick way to determine the type of all “addable” data structures in the prelude (this uses the interactive <code>show interface</code> command to list the patterns actually matched by an interface type, cf. <a href="#the-show-command">The show Command</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">interface</span> addable <span class="kw">with</span> x::addable + y::addable; <span class="kw">end</span>;
&gt; show <span class="kw">interface</span> addable
<span class="kw">type</span> addable x::<span class="dt">int</span>;
<span class="kw">type</span> addable x::<span class="dt">double</span>;
<span class="kw">type</span> addable x::<span class="dt">bigint</span>;
<span class="kw">type</span> addable s::<span class="dt">string</span>;
<span class="kw">type</span> addable [];
<span class="kw">type</span> addable xs@(_:_);</code></pre></div>
<p>On the other hand, interfaces may also contain “static” patterns which do not include the interface type as a tag at all, such as:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> foo <span class="kw">with</span> bar x::bar y; <span class="kw">end</span>;</code></pre></div>
<p>These do not contribute anything to the candidate patterns of the type, but do restrict the type just like the other patterns, in that the type will be empty unless the static patterns are all “implemented”. In the example above, this means that the <code>foo</code> type will be empty unless the <code>bar</code> function is defined and takes an element of the <code>bar</code> type as its first argument.</p>
<p>An interface may also be empty, in which case it matches <em>any</em> value. Thus,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> any <span class="kw">with</span> <span class="kw">end</span>;</code></pre></div>
<p>is just a fancy way to define the type:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> any _;</code></pre></div>
<p>Interfaces can be composed in a piecemeal fashion, by adding more interface patterns. Thus,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> foo <span class="kw">with</span> foo x::foo; <span class="kw">end</span>;
<span class="kw">interface</span> foo <span class="kw">with</span> bar x::foo; <span class="kw">end</span>;</code></pre></div>
<p>is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> foo <span class="kw">with</span> foo x::foo; bar x::foo; <span class="kw">end</span>;</code></pre></div>
<p>It is also possible to include one interface in another, which effectively establishes a subtype relationship. For instance, here’s yet another way to define the <code>foo</code> interface above:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> bar <span class="kw">with</span>
  bar x::bar;
<span class="kw">end</span>;

<span class="kw">interface</span> foo <span class="kw">with</span>
  foo x::foo;
  <span class="kw">interface</span> bar;
<span class="kw">end</span>;</code></pre></div>
<p>This has the effect of including the signature of <code>bar</code> in <code>foo</code> (while renaming the interface type tags in the <code>bar</code> signature accordingly):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show foo
<span class="kw">interface</span> foo <span class="kw">with</span>
  foo x::foo;
  bar x::foo;
<span class="kw">end</span>;</code></pre></div>
<hr />
<blockquote>
<p><strong>Note:</strong> Including interfaces is a static operation. Only the interface patterns known at the point of inclusion become part of the including interface; refining the included interface later has no effect on the set of included patterns. In particular, this also prevents circular interface definitions.</p>
<p>When composing interfaces in this fashion, it is easy to end up with duplicate interface patterns from various sources. The compiler removes such duplicates, even if they only match up to the renaming of variables. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show bar foo
<span class="kw">interface</span> bar <span class="kw">with</span>
  bar x::bar;
<span class="kw">end</span>;
<span class="kw">interface</span> foo <span class="kw">with</span>
  foo x::foo;
  bar x::foo;
<span class="kw">end</span>;
&gt; <span class="kw">interface</span> baz <span class="kw">with</span>
&gt;   <span class="kw">interface</span> foo; <span class="kw">interface</span> bar;
&gt;   foo y::baz;
&gt; <span class="kw">end</span>;
&gt; show baz
<span class="kw">interface</span> baz <span class="kw">with</span>
  foo x::baz;
  bar x::baz;
<span class="kw">end</span>;</code></pre></div>
<p>Also note that, despite the obvious similarities between interfaces and classes in object-oriented programming, they are really different things. The former are essentially just signatures of functions living elsewhere, whereas the latter also include data layouts and method implementations. More on the similarities and differences of interfaces and classes can be found in the <a href="http://golang.org/doc/go_faq.html#types">Go FAQ</a>.</p>
</blockquote>
<hr />
<p>Let’s now take a look at the example of a stack data structure to see how this all works in practice:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> stack <span class="kw">with</span>
  push s::stack x;
  pop s::stack;
  top s::stack;
<span class="kw">end</span>;</code></pre></div>
<p>Note the use of the type tag <code>stack</code> in the operation patterns, which marks the positions of <code>stack</code> arguments of the interface operations. The interface tells us that a stack provides three operations <code>push</code>, <code>pop</code> and <code>top</code> which each take a stack as their first argument; also, <code>push</code> takes two arguments, while <code>pop</code> and <code>top</code> just take a single (stack) argument.</p>
<p>This information is all that the compiler needs to figure out which terms are members of the <code>stack</code> data type. To these ends, the compiler looks at existing definitions of <code>push</code>, <code>pop</code> and <code>top</code> and extracts the patterns for arguments marked with the <code>stack</code> tag in the interface. The <code>stack</code> patterns implemented by <em>all</em> of the interface operations make up the <code>stack</code> type; i.e., the members of the type are all the instances of these patterns.</p>
<p>Right now our <code>stack</code> type doesn’t have any members, because we didn’t implement the interface operations yet, so let’s do this now. For instance, to implement stacks as lists, we might define:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">push xs@[] x | push xs@(_:_) x = x:xs;
pop (x:xs) = xs;
top (x:xs) = x;</code></pre></div>
<p>This is also known as “instantiating” the type. In addition, we will need an operation to create an initial stack value. The following will do for our purposes:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">stack xs::list = xs;</code></pre></div>
<p>This yields a stack with the given initial contents. Let’s give it a go:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; top (push (stack []) <span class="dv">99</span>);
<span class="dv">99</span></code></pre></div>
<p>Looks good so far. We can also check the actual definition of the type in terms of its <a href="#type"><code>type</code></a> rules using the <code>show interface</code> command:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show <span class="kw">interface</span> stack
<span class="kw">type</span> stack xs@(_:_);</code></pre></div>
<p>Wait, something seems to be wrong there. The empty list pattern of the <code>push</code> function is missing, where did it go? Let’s restart the interpreter with warnings enabled (<a href="#cmdoption-pure-w"><code>-w</code></a>) and retype the above definitions. The compiler then tells us:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show <span class="kw">interface</span> stack
warning: <span class="kw">interface</span> &#39;stack&#39; may be incomplete
warning: function &#39;pop&#39; might lack a rule for &#39;xs@[]&#39;
warning: function &#39;top&#39; might lack a rule for &#39;xs@[]&#39;
<span class="kw">type</span> stack xs@(_:_);</code></pre></div>
<p>See? A pattern is only considered part of the type if it is supported by <em>all</em> the interface operations. Since the <code>pop</code> and <code>top</code> operations don’t have any rules for empty list arguments, empty lists are excluded from the type. We can fix this quite easily by adding the following “error rules” which handle this case:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; pop [] = <span class="fu">throw</span> <span class="st">&quot;empty stack&quot;</span>;
&gt; top [] = <span class="fu">throw</span> <span class="st">&quot;empty stack&quot;</span>;
&gt; show <span class="kw">interface</span> stack
<span class="kw">type</span> stack xs@[];
<span class="kw">type</span> stack xs@(_:_);</code></pre></div>
<p>This looks fine now, so let’s see how we can put our new stack data structure to good use. Operations on the type are defined as usual, employing <code>stack</code> as a type tag for stack arguments so that we can be sure that the <code>push</code>, <code>pop</code> and <code>top</code> operations are all supported. For instance, let’s implement a little RPN (“Reverse Polish Notation”) calculator:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">rpn xs::stack ops::list = foldl (call []) xs ops <span class="kw">with</span>
  call ys xs op = push xs (foldl ($) op ys) <span class="kw">if</span> nargs op&lt;=#ys;
                = call (top xs:ys) (pop xs) op <span class="kw">otherwise</span>;
<span class="kw">end</span>;</code></pre></div>
<p>This takes an initial stack <code>xs</code> and a list <code>ops</code> of operands and operations as inputs and returns the resulting stack after processing <code>ops</code>. Examples:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rpn (stack []) [<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">3</span>,(+),<span class="dv">2</span>,(*),(-)];
[-<span class="dv">4</span>]
&gt; <span class="kw">using</span> math;
&gt; rpn (stack []) [<span class="dv">1</span>,<span class="dv">2</span>,ln,(/)];
[<span class="dv">1.44269504088896</span>]
&gt; rpn (stack []) [<span class="dv">4</span>,<span class="dv">1</span>,atan,(*)];
[<span class="dv">3.14159265358979</span>]
&gt; rpn (stack []) [<span class="dv">2</span>,(*)];
&lt;stdin&gt;, line <span class="dv">5</span>: unhandled exception &#39;<span class="st">&quot;empty stack&quot;</span>&#39; while evaluating
&#39;rpn (stack []) [<span class="dv">2</span>,(*)]&#39;</code></pre></div>
<p>Ok, this is all very nice, but it seems that so far we haven’t done much more than we could have achieved just as easily with plain lists instead. So what are the benefits of having an interface type?</p>
<p>First, an interface provides a fair amount of <strong>safety</strong>. As long as we stick to the interface functions, we can be sure that the data is capable of carrying out the requested operations. At the same time, the interface also serves as a valuable piece of documentation, since it tells us at a glance exactly which operations are supported by the type.</p>
<p>Second, an interface provides <strong>data abstraction</strong>. We don’t need to know how the interface operations are implemented, and in fact functions coded against the interface will work with <em>any</em> implementation of the interface. For instance, suppose that we’d like to provide a “bounded stacks” data structure, i.e., stacks which don’t grow beyond a certain limit. These can be implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">push (n,xs@[]) x | push (n,xs@(_:_)) x =
  <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> (n-<span class="dv">1</span>,x:xs) <span class="kw">else</span> <span class="fu">throw</span> <span class="st">&quot;full stack&quot;</span>;
pop (n,x:xs) = n+<span class="dv">1</span>,xs;
top (n,x:xs) = x;
pop (n,[]) = <span class="fu">throw</span> <span class="st">&quot;empty stack&quot;</span>;
top (n,[]) = <span class="fu">throw</span> <span class="st">&quot;empty stack&quot;</span>;</code></pre></div>
<p>Note that we represent a bounded stack by a pair <code>(n,xs)</code> here, where <code>xs</code> is the list of elements and <code>n</code> is the “free space” (number of elements we still allow to be pushed). We also add a function to construct such values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">bstack n::<span class="dt">int</span> xs::list = (n-#xs,xs);</code></pre></div>
<p>Without any further ado, our little RPN calculator works just fine with the new variation of the data structure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; rpn (bstack <span class="dv">3</span> []) [<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">3</span>,(+),<span class="dv">2</span>,(*),(-)];
<span class="dv">2</span>,[-<span class="dv">4</span>]
&gt; rpn (bstack <span class="dv">2</span> []) [<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">3</span>,(+),<span class="dv">2</span>,(*),(-)];
&lt;stdin&gt;, line <span class="dv">7</span>: unhandled exception &#39;<span class="st">&quot;full stack&quot;</span>&#39; while evaluating
&#39;rpn (bstack <span class="dv">2</span> []) [<span class="dv">10</span>,<span class="dv">4</span>,<span class="dv">3</span>,(+),<span class="dv">2</span>,(*),(-)]&#39;</code></pre></div>
<p>While they’re quite useful in general, Pure’s interface types also have their limitations. In particular, the guarantees provided by an interface are of a purely syntactic nature; the signature doesn’t tell us anything about the actual meaning of the provided operations, so unit testing is still needed to ensure certain semantic properties of the implementation. Some further issues due to Pure’s dynamically typed nature are discussed under <a href="#interfaces">Interfaces</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section.</p>
<p><a name="using"></a></p>
<p><a name="modules-and-imports"></a></p>
<h3 id="modules-and-imports">Modules and Imports</h3>
<p>Pure doesn’t offer separate compilation, but the following type of declaration provides a simple but effective way to assemble a Pure program from several source modules.</p>
<pre class="sourceCode bnf"><code>using_decl : &quot;using&quot; name (&quot;,&quot; name)* &quot;;&quot;
name : qualified_identifier | string</code></pre>
<p>The <a href="#using"><code>using</code></a> declaration takes the following form (note that in contrast to symbol declarations, the comma is used as a delimiter symbol here):</p>
<dl>
<dt><code>using name, ...;</code></dt>
<dd><!-- -->
</dd>
</dl>
<p>This causes each given script to be included in the Pure program at the given point (if it wasn’t already included before), which makes available all the definitions of the included script in your program. Note that each included script is loaded only <em>once</em>, when the first <a href="#using"><code>using</code></a> clause for the script is encountered. Nested imports are allowed, i.e., an imported module may itself import other modules, etc. A Pure program then basically is the concatenation of all the source modules given as command line arguments, with other modules listed in <a href="#using"><code>using</code></a> clauses inserted at the corresponding source locations.</p>
<p>(The <a href="#using"><code>using</code></a> clause also has an alternative form which allows dynamic libraries and LLVM bitcode modules to be loaded, this will be discussed in the <a href="#c-interface">C Interface</a> section.)</p>
<p>For instance, the following declaration causes the math.pure script from the standard library to be included in your program:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> math;</code></pre></div>
<p>You can also import multiple scripts in one go:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> array, dict, set;</code></pre></div>
<p>Moreover, Pure provides a notation for qualified module names which can be used to denote scripts located in specific package directories, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> examples::libor::bits;</code></pre></div>
<p>In fact this is equivalent to the following <a href="#using"><code>using</code></a> clause which spells out the real filename of the script between double quotes (the <code>.pure</code> suffix can also be omitted in which case it is added automatically):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="st">&quot;examples/libor/bits.pure&quot;</span>;</code></pre></div>
<p>Both notations can be used interchangeably; the former is usually more convenient, but the latter allows you to denote scripts whose names aren’t valid Pure identifiers.</p>
<p>Script identifiers are translated to the corresponding filenames by replacing the ‘<code>::</code>’ symbol with the pathname separator ‘<code>/</code>’ and tacking on the ‘<code>.pure</code>’ suffix. The following table illustrates this with a few examples.</p>
<table>
<thead>
<tr class="header">
<th align="left">Script identifier</th>
<th align="left">Filename</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>math</code></td>
<td align="left"><code>&quot;math.pure&quot;</code></td>
</tr>
<tr class="even">
<td align="left"><code>examples::libor::bits</code></td>
<td align="left"><code>&quot;examples/libor/bits.pure&quot;</code></td>
</tr>
<tr class="odd">
<td align="left"><code>::pure::examples::hello</code></td>
<td align="left"><code>&quot;/pure/examples/hello.pure&quot;</code></td>
</tr>
</tbody>
</table>
<p>Note the last example, which shows how an absolute pathname can be denoted using a qualifier starting with ‘<code>::</code>’.</p>
<p>Unless an absolute pathname is given, the interpreter performs a search to locate the script. The search algorithm considers the following directories in the given order:</p>
<ul>
<li>the directory of the current script, which is the directory of the script containing the <a href="#using"><code>using</code></a> clause, or the current working directory if the clause was read from standard input (as is the case, e.g., in an interactive session);</li>
<li>the directories named in <a href="#cmdoption-pure-I"><code>-I</code></a> options on the command line (in the given order);</li>
<li>the colon-separated list of directories in the <a href="#envvar-PURE_INCLUDE"><code>PURE_INCLUDE</code></a> environment variable (in the given order);</li>
<li>finally the directory named by the <a href="#envvar-PURELIB"><code>PURELIB</code></a> environment variable.</li>
</ul>
<p>Note that the current working directory is not searched by default (unless the <a href="#using"><code>using</code></a> clause is read from standard input), but of course you can force this by adding the option <a href="#cmdoption-pure-I"><code>-I</code></a>. to the command line, or by including ‘.’ in the <a href="#envvar-PURE_INCLUDE"><code>PURE_INCLUDE</code></a> variable.</p>
<p>The directory of the current script (the first item above) can be skipped by specifying the script to be loaded as a filename in double quotes, prefixed with the special <code>sys:</code> tag. The search then starts with the “system” directories (<a href="#cmdoption-pure-I"><code>-I</code></a>, <a href="#envvar-PURE_INCLUDE"><code>PURE_INCLUDE</code></a> and <a href="#envvar-PURELIB"><code>PURELIB</code></a>) instead. This is useful, e.g., if you want to provide your own custom version of a standard library script which in turn imports that library script. For instance, a custom version of math.pure might employ the following <a href="#using"><code>using</code></a> clause to load the math.pure script from the Pure library:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="st">&quot;sys:math&quot;</span>;
<span class="co">// custom definitions go here</span>
log2 x = ln x/ln <span class="dv">2</span>;</code></pre></div>
<p>The interpreter compares script names (to determine whether two scripts are actually the same) by using the <em>canonicalized</em> full pathname of the script, following symbolic links to the destination file (albeit only one level). Thus different scripts with the same basename, such as foo/utils.pure and bar/utils.pure can both be included in the same program (unless they link to the same file).</p>
<p>More precisely, canonicalizing a pathname involves the following steps:</p>
<ul>
<li>relative pathnames are expanded to absolute ones, using the search rules discussed above;</li>
<li>the directory part of the pathname is normalized to the form returned by the <code>getcwd</code> system call;</li>
<li>the “.pure” suffix is added if needed;</li>
<li>if the resulting script name is actually a symbolic link, the interpreter follows that link to its destination, albeit only one level. (This is only done on Unix-like systems.)</li>
</ul>
<p>The directory of the canonicalized pathname is also used when searching other scripts included in a script. This makes it possible to have an executable script with a shebang line in its own directory, which is then executed via a symbolic link placed on the system <a href="#envvar-PATH"><code>PATH</code></a>. In this case the script search performed in <a href="#using"><code>using</code></a> clauses will use the real script directory and thus other required scripts can be located there. This is the recommended practice for installing standalone Pure applications in source form which are to be run directly from the shell.</p>
<p><a name="namespace"></a></p>
<h3 id="namespaces">Namespaces</h3>
<p>To facilitate modular development, Pure also provides namespaces as a means to avoid name clashes between symbols, and to keep the global namespace tidy and clean. Namespaces serve as containers holding groups of related identifiers and other symbols. Inside each namespace, symbols must be unique, but the same symbol may be used to denote different objects (variables, functions, etc.) in different namespaces. (Pure’s namespace system was heavily inspired by C++ and works in a very similar fashion. So if you know C++ you should feel right at home and skimming this section to pick up Pure’s syntax of the namespace constructs should be enough to start using it.)</p>
<p>The global namespace is always available. By default, new symbols are created in this namespace, which is also called the <strong>default namespace</strong>. Additional namespaces can be created with the <a href="#namespace"><code>namespace</code></a> declaration, which also switches to the given namespace (makes it the <em>current</em> namespace), so that new symbols are then created in that namespace rather than the default one. The current namespace also applies to all kinds of symbol declarations, including operator and nonfix symbol declarations, as well as <a href="#extern"><code>extern</code></a> declarations (the latter are described in the <a href="#c-interface">C Interface</a> section).</p>
<p>The syntax of namespace declarations is captured by the following grammar rules:</p>
<pre class="sourceCode bnf"><code>namespace_decl : &quot;namespace&quot; [name] [brackets] &quot;;&quot;
    | &quot;namespace&quot; name [brackets] &quot;with&quot; item+ &quot;end&quot; &quot;;&quot;
    | &quot;using&quot; &quot;namespace&quot; [name_spec (&quot;,&quot; name_spec)*] &quot;;&quot;
brackets : &quot;(&quot; left_op right_op &quot;)&quot;
name_spec : name [&quot;(&quot; qualified_symbol+ &quot;)&quot;]</code></pre>
<p>The basic form of the <a href="#namespace"><code>namespace</code></a> declaration looks as follows (there’s also a “scoped” form of the <a href="#namespace"><code>namespace</code></a> declaration which will be discussed in <a href="#scoped-namespaces">Scoped Namespaces</a> at the end of this section):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> name;
<span class="co">// declarations and definitions in namespace &#39;name&#39;</span>
<span class="kw">namespace</span>;</code></pre></div>
<p>The second form switches back to the default namespace. For instance, in order to define two symbols with the same print name <code>foo</code> in two different namespaces <code>foo</code> and <code>bar</code>, you can write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo;
foo x = x+<span class="dv">1</span>;
<span class="kw">namespace</span> bar;
foo x = x-<span class="dv">1</span>;
<span class="kw">namespace</span>;</code></pre></div>
<p>We can now refer to the symbols we just defined using <strong>qualified symbols</strong> of the form <code>namespace::symbol</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo::foo <span class="dv">99</span>;
<span class="dv">100</span>
&gt; bar::foo <span class="dv">99</span>;
<span class="dv">98</span></code></pre></div>
<p>This avoids any potential name clashes, since the qualified identifier notation always makes it clear which namespace the given identifier belongs to.</p>
<p>A namespace can be “reopened” at any time to add new symbols and definitions to it. This allows namespaces to be created that span several source modules. You can also create several different namespaces in the same module.</p>
<p>Similar to the <a href="#using"><code>using</code></a> declaration, a <a href="#namespace"><code>namespace</code></a> declaration accepts either identifiers or double-quoted strings as namespace names. E.g., the following two declarations are equivalent:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo;
<span class="kw">namespace</span> <span class="st">&quot;foo&quot;</span>;</code></pre></div>
<p>The latter form also allows more descriptive labels which aren’t identifiers, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> <span class="st">&quot;Private stuff, keep out!&quot;</span>;</code></pre></div>
<p>Note that the namespace prefix in a qualified identifier must be a legal identifier, so it isn’t possible to access symbols in namespaces with such descriptive labels in a direct fashion. The only way to get at the symbols in this case is with <a href="#namespace-brackets">namespace brackets</a> or by using a <a href="#namespace"><code>namespace</code></a> or <a href="#using%20namespace"><code>using namespace</code></a> declaration (for the latter see <a href="#using-namespaces">Using Namespaces</a> below).</p>
<p><a name="using-namespace"></a></p>
<h4 id="using-namespaces">Using Namespaces</h4>
<p>Since it is rather inconvenient if you always have to write identifiers in their qualified form outside of their “home” namespace, Pure allows you to specify a list of <em>search</em> namespaces which are used to look up symbols not in the default or the current namespace. This is done with the <a href="#using%20namespace"><code>using namespace</code></a> declaration, which takes the following form:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="kw">namespace</span> name1, name2, ...;
<span class="co">// ...</span>
<span class="kw">using</span> <span class="kw">namespace</span>;</code></pre></div>
<p>As with <a href="#namespace"><code>namespace</code></a> declarations, the second form without any namespace arguments gets you back to the default empty list of search namespaces.</p>
<p>For instance, consider this example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo;
foo x = x+<span class="dv">1</span>;
<span class="kw">namespace</span> bar;
foo x = x-<span class="dv">1</span>;
bar x = x+<span class="dv">1</span>;
<span class="kw">namespace</span>;</code></pre></div>
<p>The symbols in these namespaces can be accessed unqualified as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="kw">namespace</span> foo;
&gt; foo <span class="dv">99</span>;
<span class="dv">100</span>
&gt; <span class="kw">using</span> <span class="kw">namespace</span> bar;
&gt; foo <span class="dv">99</span>;
<span class="dv">98</span>
&gt; bar <span class="dv">99</span>;
<span class="dv">100</span></code></pre></div>
<p>This method is often to be preferred over opening a namespace with the <a href="#namespace"><code>namespace</code></a> declaration, since <a href="#using%20namespace"><code>using namespace</code></a> only gives you “read access” to the imported symbols, so you can’t accidentally mess up the definitions of the namespace you’re using. Another advantage is that the <a href="#using%20namespace"><code>using namespace</code></a> declaration also lets you search multiple namespaces at once:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="kw">namespace</span> foo, bar;</code></pre></div>
<p>Be warned, however, that this brings up the very same issue of name clashes again:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="kw">namespace</span> foo, bar;
&gt; foo <span class="dv">99</span>;
&lt;stdin&gt;, line <span class="dv">15</span>: symbol &#39;foo&#39; is ambiguous here</code></pre></div>
<p>In such a case you’ll have to resort to using namespace qualifiers again, in order to resolve the name clash:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo::foo <span class="dv">99</span>;
<span class="dv">100</span></code></pre></div>
<p>To avoid this kind of mishap, you can also selectively import just a few symbols from a namespace instead. This can be done with a declaration of the following form:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="kw">namespace</span> name1 ( sym1 sym2 ... ), name2 ... ;</code></pre></div>
<p>As indicated, the symbols to be imported can optionally be placed as a whitespace-delimited list inside parentheses, following the corresponding namespace name. (As with symbol declarations, the symbols may optionally be qualified with a namespace prefix, which must match the imported namespace here.) For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="kw">namespace</span> foo, bar (bar);
&gt; foo <span class="dv">99</span>;
<span class="dv">100</span>
&gt; bar <span class="dv">99</span>;
<span class="dv">100</span>
&gt; bar::foo <span class="dv">99</span>;
<span class="dv">98</span></code></pre></div>
<p>Note that now we have no clash on the <code>foo</code> symbol any more, because we restricted the import from the <code>bar</code> namespace to the <code>bar</code> symbol, so that <code>bar::foo</code> has to be denoted with a qualified symbol now.</p>
<p><a name="symbol-lookup-and-creation"></a></p>
<h4 id="symbol-lookup-and-creation">Symbol Lookup and Creation</h4>
<p>Pure’s rules for looking up and creating symbols are fairly straightforward and akin to those in other languages featuring namespaces. However, there are some intricacies involved, because the rewriting rule format of definitions allows “referential” use of symbols not only in the “body” (right-hand side) of a definition, but also in the left-hand side patterns. We discuss this in detail below.</p>
<p>The compiler searches for symbols first in the current namespace (if any), then in the currently active search namespaces (if any), and finally in the default (i.e., the global) namespace, in that order. This automatic lookup can be bypassed by using an <em>absolute</em> namespace qualifier of the form <code>::foo::bar</code>. In particular, <code>::bar</code> always denotes the symbol <code>bar</code> in the default namespace, while <code>::foo::bar</code> denotes the symbol <code>bar</code> in the <code>foo</code> namespace. (Normally, the latter kind of notation is only needed if you have to deal with nested namespaces, see <a href="#hierarchical-namespaces">Hierarchical Namespaces</a> below.)</p>
<p>If no existing symbol is found, a new symbol is created automatically, by implicitly declaring a public symbol with default attributes. New <em>unqualified</em> symbols are always created in the current namespace, while new <em>qualified</em> symbols are created in the namespace given by the namespace prefix of the symbol.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> Pure’s implicit symbol declarations are a mixed blessing. They are convenient, especially in interactive usage, but they also let missing or mistyped symbols go unnoticed much too easily. As a remedy, in the case of qualified symbols the compiler checks that the given namespace prefix matches the current namespace, in order to catch typos and other silly mistakes and prevent you from accidentally clobbering the contents of other namespaces. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> foo;
&gt; <span class="kw">namespace</span>;
&gt; foo::bar x = <span class="dv">1</span>/x;
&lt;stdin&gt;, line <span class="dv">3</span>: undeclared symbol &#39;foo::bar&#39;</code></pre></div>
<p>To make these errors go away it’s enough to just declare the symbols in their proper namespaces.</p>
<p>In addition, you can run the interpreter with the <a href="#cmdoption-pure-w"><code>-w</code></a> option (see <a href="#invoking-pure">Invoking Pure</a>) to check your scripts for (non-defining) uses of undeclared unqualified function symbols. This is highly recommended. For instance, in the following example we forgot to import the <a href="purelib.html#module-system">system</a> module which defines the <a href="purelib.html#puts"><code>puts</code></a> function. Running the interpreter with <a href="#cmdoption-pure-w"><code>-w</code></a> highlights such potential errors:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -w
&gt; puts <span class="st">&quot;bla&quot;</span>; <span class="co">// missing import of system module</span>
&lt;stdin&gt;, line <span class="dv">1</span>: warning: implicit declaration <span class="kw">of</span> &#39;puts&#39;
puts <span class="st">&quot;bla&quot;</span></code></pre></div>
<p>For legitimate uses (such as forward uses of a symbol which is defined later), you can make these warnings go away by declaring the symbol before using it.</p>
</blockquote>
<hr />
<p>New symbols are also created if a global unqualified (and yet undeclared) symbol is being “defined” in a rewriting rule or <a href="#let"><code>let</code></a>/<a href="#const"><code>const</code></a> definition, even if a symbol with the same print name from another namespace is already visible in the current scope. To distinguish “defining” from “referring” uses of a global symbol, Pure uses the following (purely syntactic) notions:</p>
<ul>
<li>A <strong>defining occurrence</strong> of a global <em>function</em>, <em>macro</em> or <em>type symbol</em> is any occurrence of the symbol as the (leftmost) <em>head symbol</em> on the left-hand side of a rewriting rule.</li>
<li>A <strong>defining occurrence</strong> of a global <em>variable</em> or <em>constant symbol</em> is any occurrence of the symbol in a <em>variable position</em> (as given by the “head = function” rule, cf. <a href="#variables-in-equations">Variables in Equations</a>) on the left-hand side of a <a href="#let"><code>let</code></a> or <a href="#const"><code>const</code></a> definition.</li>
<li>All other occurrences of global symbols on the left-hand side, as well as <em>all</em> symbol occurrences on the right-hand side of a definition are <strong>referring occurrences</strong>. (Note that this also subsumes all occurrences of <em>type tags</em> on the left-hand side of an equation.)</li>
</ul>
<p>The following example illustrates these notions:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo;
bar (bar x) = bar x;
<span class="kw">let</span> x,y = <span class="dv">1</span>,<span class="dv">2</span>;
<span class="kw">namespace</span>;</code></pre></div>
<p>Here, the first occurrence of <code>bar</code> on the left-hand side <code>bar (bar x)</code> of the first rule is a <em>defining</em> occurrence, as are the occurrences of <code>x</code> and <code>y</code> on the left-hand side of the <a href="#let"><code>let</code></a> definition. Hence these symbols are created as new symbols in the namespace <code>foo</code>. On the other hand, the other occurrences of <code>bar</code> in the first rule, as well as the ‘<code>,</code>’ symbol on the left-hand side of the <a href="#let"><code>let</code></a> definition are <em>referring</em> occurrences. In the former case, <code>bar</code> refers to the <code>bar</code> symbol defined by the rule, while in the latter case the ‘<code>,</code>’ operator is actually declared in the prelude and thus imported from the global namespace.</p>
<p>The same rules of lookup also apply to type tags on the left-hand side of an equation, but in this case the interpreter will look specifically for type symbols, avoiding any other kinds of symbols which might be visible in the same context. Thus, in the following example, the type tag <code>bar</code> is correctly resolved to <code>bar::bar</code>, even though the (function) symbol <code>foo::bar</code> is visible at this point:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> bar;
&gt; <span class="kw">type</span> bar;
&gt; <span class="kw">namespace</span> foo;
&gt; <span class="kw">public</span> bar;
&gt; <span class="kw">using</span> <span class="kw">namespace</span> bar;
&gt; foo x::bar = bar x;
&gt; show foo::foo
foo::foo x :: bar::bar = foo::bar x;</code></pre></div>
<p>Note that special operator (and nonfix) symbols <em>always</em> require an explicit declaration. This works as already discussed in the <a href="#symbol-declarations">Symbol Declarations</a> section, except that you first switch to the appropriate namespace before declaring the symbols. For instance, here is how you can create a new <code>+</code> operation which multiplies its operands rather than adding them:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> my;
&gt; <span class="kw">infixl</span> <span class="dv">2200</span> +;
&gt; x+y = x*y;
&gt; <span class="dv">5</span>+<span class="dv">7</span>;
<span class="dv">35</span></code></pre></div>
<p>Note that the new <code>+</code> operation really belongs to the namespace we created. The <code>+</code> operation in the default namespace works as before, and in fact you can use qualified symbols to pick the version that you need:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span>;
&gt; <span class="dv">5</span>+<span class="dv">7</span>;
<span class="dv">12</span>
&gt; <span class="dv">5</span> ::+ <span class="dv">7</span>;
<span class="dv">12</span>
&gt; <span class="dv">5</span> my::+ <span class="dv">7</span>;
<span class="dv">35</span></code></pre></div>
<p>Here’s what you get if you happen to forget the declaration of the <code>+</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> my;
&gt; x+y = x*y;
&lt;stdin&gt;, line <span class="dv">2</span>: <span class="kw">infixl</span> symbol &#39;+&#39; was not declared in this <span class="kw">namespace</span></code></pre></div>
<p>Thus the compiler will never create a new instance of an operator symbol on the fly, an explicit declaration is always needed in such cases.</p>
<p>Note that if you <em>really</em> wanted to redefine the global <code>+</code> operator, you can do this even while the <code>my</code> namespace is current. You just have to use a qualified identifier in this case, as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> my;
&gt; x ::+ y = x*y;
&gt; a+b;
a*b</code></pre></div>
<p>This should rarely be necessary (in the above example you might just as well enter this rule while in the global namespace), but it can be useful in some circumstances. Specifically, you might want to “overload” a global function or operator with a definition that makes use of private symbols of a namespace (which are only visible inside that namespace; see <a href="#private-symbols">Private Symbols</a> below). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> my;
&gt; <span class="kw">private</span> bar;
&gt; bar x y = x*y;
&gt; x ::+ y = bar x y;
&gt; a+b;
a*b</code></pre></div>
<p>(The above is a rather contrived example, since the very same functionality can be accomplished much easier, but there are some situations where this method is needed.)</p>
<h4 id="private-symbols">Private Symbols</h4>
<p>Pure also allows you to have private symbols, as a means to hide away internal operations which shouldn’t be accessed directly outside the namespace in which they are declared. The scope of a private symbol is confined to its namespace, i.e., the symbol is only visible when its “home” namespace is current. Symbols are declared private by using the <a href="#private"><code>private</code></a> keyword in the symbol declaration:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> secret;
&gt; <span class="kw">private</span> baz;
&gt; <span class="co">// &#39;baz&#39; is a private symbol in namespace &#39;secret&#39; here</span>
&gt; baz x = <span class="dv">2</span>*x;
&gt; <span class="co">// you can use &#39;baz&#39; just like any other symbol here</span>
&gt; baz <span class="dv">99</span>;
<span class="dv">198</span>
&gt; <span class="kw">namespace</span>;</code></pre></div>
<p>Note that, at this point, <code>secret::baz</code> is now invisible, even if you have <code>secret</code> in the search namespace list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="kw">namespace</span> secret;
&gt; <span class="co">// this actually creates a &#39;baz&#39; symbol in the default namespace:</span>
&gt; baz <span class="dv">99</span>;
baz <span class="dv">99</span>
&gt; secret::baz <span class="dv">99</span>;
&lt;stdin&gt;, line <span class="dv">27</span>: symbol &#39;secret::baz&#39; is <span class="kw">private</span> here</code></pre></div>
<p>The only way to bring the symbol back into scope is to make the <code>secret</code> namespace current again:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> secret;
&gt; baz <span class="dv">99</span>;
<span class="dv">198</span>
&gt; secret::baz <span class="dv">99</span>;
<span class="dv">198</span></code></pre></div>
<h4 id="namespace-brackets">Namespace Brackets</h4>
<p>All the namespace-related constructs we discussed so far only provide a means to switch namespaces on a per-rule basis. Sometimes it is convenient if you can switch namespaces on the fly inside an expression. This is especially useful if you want to embed a domain-specific sublanguage (DSL) in Pure. DSLs typically provide their own system of operators which differ from the standard Pure operators and thus need to be declared in their own namespace.</p>
<p>To make this possible, Pure allows you to associate a namespace with a corresponding pair of outfix symbols. This turns the outfix symbols into special <strong>namespace brackets</strong> which can then be used to quickly switch namespaces in an expression by just enclosing a subexpression in the namespace brackets.</p>
<p>To these ends, the syntax of <a href="#namespace"><code>namespace</code></a> declarations allows you to optionally specify a pair of outfix symbols inside parentheses after the namespace name. The outfix symbols to be used as namespace brackets must have been declared beforehand. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">outfix</span> « »;
<span class="kw">namespace</span> foo (« »);
<span class="kw">infixr</span> (::^) ^;
x^y = <span class="dv">2</span>*x+y;
<span class="kw">namespace</span>;</code></pre></div>
<p>The code above introduces a <code>foo</code> namespace which defines a special variation of the <code>(^)</code> operator. It also associates the namespace with the <code>« »</code> brackets so that you can write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (a+b)^c+<span class="dv">10</span>;
(a+b)^c+<span class="dv">10</span>
&gt; «(a+b)^c»+<span class="dv">10</span>;
<span class="dv">2</span>*(a+b)+c+<span class="dv">10</span></code></pre></div>
<p>Note the use of the namespace brackets in the second input line. This changes the meaning of the <code>^</code> operator, which now refers to <code>foo::^</code> instead. Also note that the namespace brackets themselves are removed from the resulting expression; they are only used to temporarily switch the namespace to <code>foo</code> inside the bracketed subexpression. This works pretty much like a <a href="#namespace"><code>namespace</code></a> declaration (so any active search namespaces remain in effect), but is limited in scope to the bracketed subexpression and only gives access to the public symbols of the namespace (like a <a href="#using%20namespace"><code>using namespace</code></a> declaration would do).</p>
<p>The rules of visibility for the namespace bracket symbols themselves are the same as for any other symbols. So they need to be in scope if you want to denote them in unqualified form (which is always the case if they are declared in the default namespace, as in the example above). If necessary, you can also specify them in their qualified form as usual.</p>
<p>Namespace brackets can be used anywhere inside an expression, even on the left-hand side of a rule. So, for instance, we might also have written the example above as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">outfix</span> « »;
<span class="kw">namespace</span> foo (« »);
<span class="kw">infixr</span> (::^) ^;
<span class="kw">namespace</span>;

«x^y» = <span class="dv">2</span>*x+y;</code></pre></div>
<p>Note the use of the namespace brackets on the last line. This rule actually expands to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">x foo::^ y  = <span class="dv">2</span>*x+y;</code></pre></div>
<p>The special meaning of namespace brackets can be turned off and back on again at any time with a corresponding <a href="#namespace"><code>namespace</code></a> declaration. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> (« »); <span class="co">// turn off the special meaning of « »</span>
&gt; «(a+b)^c»+<span class="dv">10</span>;
« (a+b)^c »+<span class="dv">10</span>
&gt; <span class="kw">namespace</span> foo (« »); <span class="co">// turn it on again</span>
&gt; <span class="kw">namespace</span>;
&gt; «(a+b)^c»+<span class="dv">10</span>;
<span class="dv">2</span>*(a+b)+c+<span class="dv">10</span></code></pre></div>
<p>(Note that as a side effect these declarations also change the current namespace, so that we use the <code>namespace;</code> declaration in the second last line to change back to the default namespace.)</p>
<p>As shown in the first line of the example above, a namespace brackets declaration without a namespace just turns off the special processing of the brackets. In order to define a namespace bracket for the <em>default</em> namespace, you need to explicitly specify an empty namespace instead, as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">outfix</span> «: :»;
&gt; <span class="kw">namespace</span> <span class="st">&quot;&quot;</span> («: :»);
&gt; «(a+b)^«:x^y:»»;
<span class="dv">2</span>*(a+b)+x^y</code></pre></div>
<p>As this example illustrates, namespace brackets can also be nested, which is useful, e.g., if you need to combine subexpressions from several DSLs in a single expression. In this example we employ the <code>«:x^y:»</code> subexpression to temporarily switch back to the default namespace inside the <code>« »</code>-bracketed expression which is parsed in the <code>foo</code> namespace.</p>
<h4 id="hierarchical-namespaces">Hierarchical Namespaces</h4>
<p>Namespace identifiers can themselves be qualified identifiers in Pure, which enables you to introduce a hierarchy of namespaces. This is useful, e.g., to group related namespaces together under a common “umbrella” namespace:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> my;
<span class="kw">namespace</span> my::old;
foo x = x+<span class="dv">1</span>;
<span class="kw">namespace</span> my::new;
foo x = x-<span class="dv">1</span>;</code></pre></div>
<p>Note that the namespace <code>my</code>, which serves as the parent namespace, must be created before the <code>my::old</code> and <code>my::new</code> namespaces, even if it does not contain any symbols of its own. After these declarations, the <code>my::old</code> and <code>my::new</code> namespaces are part of the <code>my</code> namespace and will be considered in name lookup accordingly, so that you can write:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="kw">namespace</span> my;
&gt; old::foo <span class="dv">99</span>;
<span class="dv">100</span>
&gt; new::foo <span class="dv">99</span>;
<span class="dv">98</span></code></pre></div>
<p>This works pretty much like a hierarchy of directories and files, where the namespaces play the role of the directories (with the default namespace as the root directory), the symbols in each namespace correspond to the files in a directory, and the <a href="#using%20namespace"><code>using namespace</code></a> declaration functions similar to the shell’s <a href="#envvar-PATH"><code>PATH</code></a> variable.</p>
<p>Sometimes it is necessary to tell the compiler to use a symbol in a specific namespace, bypassing the usual symbol lookup mechanism. For instance, suppose that we introduce another <em>global</em> <code>old</code> namespace and define yet another version of <code>foo</code> in that namespace:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> old;
foo x = <span class="dv">2</span>*x;
<span class="kw">namespace</span>;</code></pre></div>
<p>Now, if we want to access that function, with <code>my</code> still active as the search namespace, we cannot simply refer to the new function as <code>old::foo</code>, since this name will resolve to <code>my::old::foo</code> instead. As a remedy, the compiler accepts an <strong>absolute</strong> qualified identifier of the form <code>::old::foo</code>. This bypasses name lookup and thus always yields exactly the symbol in the given namespace (if it exists; as mentioned previously, the compiler will complain about an undeclared symbol otherwise):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; old::foo <span class="dv">99</span>;
<span class="dv">100</span>
&gt; ::old::foo <span class="dv">99</span>;
<span class="dv">198</span></code></pre></div>
<p>Also note that, as a special case of the absolute qualifier notation, <code>::foo</code> always denotes the symbol <code>foo</code> in the default namespace.</p>
<h4 id="scoped-namespaces">Scoped Namespaces</h4>
<p>Pure also provides an alternative scoped <a href="#namespace"><code>namespace</code></a> construct which makes nested namespace definitions more convenient. This construct takes the following form:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> name <span class="kw">with</span> ... <span class="kw">end</span>;</code></pre></div>
<p>The part between <a href="#with"><code>with</code></a> and <a href="#end"><code>end</code></a> may contain arbitrary declarations and definitions, using the same syntax as the toplevel. These are processed in the context of the given namespace, as if you had written:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> name;
...
<span class="kw">namespace</span>;</code></pre></div>
<p>However, the scoped namespace construct always returns you to the namespace which was active before, and thus these declarations may be nested:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo <span class="kw">with</span>
  <span class="co">// declarations and definitions in namespace foo</span>
  <span class="kw">namespace</span> bar <span class="kw">with</span>
    <span class="co">// declarations and definitions in namespace bar</span>
  <span class="kw">end</span>;
  <span class="co">// more declarations and definitions in namespace foo</span>
<span class="kw">end</span>;</code></pre></div>
<p>Note that this kind of nesting does not necessarily imply a namespace hierarchy as discussed in <a href="#hierarchical-namespaces">Hierarchical Namespaces</a>. However, you can achieve this by using the appropriate qualified namespace names:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo <span class="kw">with</span>
  <span class="co">// ...</span>
  <span class="kw">namespace</span> foo::bar <span class="kw">with</span>
    <span class="co">// ...</span>
  <span class="kw">end</span>;
  <span class="co">// ...</span>
<span class="kw">end</span>;</code></pre></div>
<p>Another special feature of the scoped namespace construct is that <a href="#using%20namespace"><code>using namespace</code></a> declarations are always local to the current namespace scope (and other nested namespace scopes inside it). Thus the previous setting is restored at the end of each scope:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="kw">namespace</span> foo;
<span class="kw">namespace</span> foo <span class="kw">with</span>
  <span class="co">// still using namespace foo here</span>
  <span class="kw">using</span> <span class="kw">namespace</span> bar;
  <span class="co">// now using namespace bar</span>
  <span class="kw">namespace</span> bar <span class="kw">with</span>
    <span class="co">// still using namespace bar here</span>
    <span class="kw">using</span> <span class="kw">namespace</span> foo;
    <span class="co">// now using namespace foo</span>
  <span class="kw">end</span>;
  <span class="co">// back to using namespace bar</span>
<span class="kw">end</span>;
<span class="co">// back to using namespace foo at toplevel</span></code></pre></div>
<p>Finally, here’s a more concrete example which shows how scoped namespaces might be used to declare two namespaces and populate them with various functions and operators:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo <span class="kw">with</span>
  <span class="kw">infixr</span> (::^) ^;
  foo x = x+<span class="dv">1</span>;
  bar x = x-<span class="dv">1</span>;
  x^y = <span class="dv">2</span>*x+y;
<span class="kw">end</span>;

<span class="kw">namespace</span> bar <span class="kw">with</span>
  <span class="kw">outfix</span> &lt;: :&gt;;
  foo x = x+<span class="dv">2</span>;
  bar x = x-<span class="dv">2</span>;
<span class="kw">end</span>;

<span class="kw">using</span> <span class="kw">namespace</span> foo(^ foo), bar(bar &lt;: :&gt;);

<span class="co">// namespace foo</span>
foo x;
x^y;

<span class="co">// namespace bar</span>
bar x;
&lt;: x,y :&gt;;</code></pre></div>
<p>Pure’s namespaces can thus be used pretty much like “packages” or “modules” in languages like Ada or Modula-2. They provide a structured way to describe program components offering collections of related data and operations, which can be brought into scope in a controlled way by making judicious use of <a href="#using%20namespace"><code>using namespace</code></a> declarations. They also provide an abstraction barrier, since internal operations and data structures can be hidden away employing private symbols.</p>
<p>Please note that these facilities are not Pure’s main focus and thus they are somewhat limited compared to programming languages specifically designed for big projects and large teams of developers. Nevertheless they should be useful if your programs grow beyond a small collection of simple source modules, and enable you to manage most Pure projects with ease.</p>
<p><a name="macros"></a></p>
<h2 id="macros">Macros</h2>
<p>Macros are a special type of functions to be executed as a kind of “preprocessing stage” at compile time. In Pure these are typically used to define custom special forms and to perform inlining of function calls and other kinds of source-level optimizations.</p>
<p>Whereas the macro facilities of most programming languages simply provide a kind of textual substitution mechanism, Pure macros operate on symbolic expressions and are implemented by the same kind of rewriting rules that are also used to define ordinary functions in Pure. This makes them robust and easy to use for most common preprocessing purposes.</p>
<p>Syntactically, a macro definition looks just like a function definition with the <a href="#def"><code>def</code></a> keyword in front of it. Only unconditional rewriting rules are permitted here, i.e., rules without guards and multiple right-hand sides. However, multiple left-hand sides can be employed as usual to abbreviate a collection of rules with the same left-hand side, as described in the <a href="#general-rules">General Rules</a> section.</p>
<p>The major difference between function and macro definitions is that the latter are processed at compile time rather than run time. To these ends, macro calls on the right-hand sides of function, constant and variable definitions are evaluated by reducing them to normal form using the available macro rules. The resulting expressions are then substituted for the macro calls. All macro substitution happens before constant substitutions and the actual compilation step. Macros can be defined in terms of other macros (also recursively), and are normally evaluated using call by value (i.e., macro calls in macro arguments are expanded before the macro gets applied to its parameters).</p>
<p>In the first half of this section we start out with some common uses of macros which should cover most aspects of macro programming that the average Pure programmer will need. The remainder of this section then discusses some more advanced features of Pure’s macro system intended for power users.</p>
<p><a name="optimization-rules"></a></p>
<h3 id="optimization-rules">Optimization Rules</h3>
<p>Let’s begin with a simple example of an optimization rule from the prelude, which eliminates saturated instances of the right-associative function application operator (you can find this near the beginning of prelude.pure):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">def</span> f $ x = f x;</code></pre></div>
<p>Like in Haskell, ‘<a href="purelib.html#$"><code>$</code></a>’ in fact just denotes function application, but it is a low-priority operator which is handy to write cascading function calls. With the above macro rule, these will be “inlined” as ordinary function applications automatically. Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = bar $ bar $ <span class="dv">2</span>*x;
&gt; show foo
foo x = bar (bar (<span class="dv">2</span>*x));</code></pre></div>
<p>Note that a macro may have the same name as an ordinary Pure function, which is essential if you want to inline calls to an existing function. (Just like ordinary functions, the number of parameters in each rule for a given macro must be the same, but a macro may have a different number of arguments than the corresponding function.)</p>
<p>When running interactively, you can follow the reduction steps the compiler performs during macro evaluation. To these ends, you have to set “tracepoints” on the relevant macros, using the <code>trace</code> command with the <code>-m</code> option; see <a href="#interactive-commands">Interactive Commands</a>. (This works even if the interpreter is run in non-debugging mode.) Note that since macro expansion is performed at compile time, you’ll have to do this <em>before</em> entering the definitions in which the macro is used. However, in many cases you can also just enter the right-hand side of the equation at the interpreter prompt to see how it gets expanded. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; trace -m $
&gt; bar $ bar $ <span class="dv">2</span>*x;
-- macro ($): bar$<span class="dv">2</span>*x --&gt; bar (<span class="dv">2</span>*x)
-- macro ($): bar$bar (<span class="dv">2</span>*x) --&gt; bar (bar (<span class="dv">2</span>*x))
bar (bar (<span class="dv">2</span>*x))</code></pre></div>
<p>Now let’s see how we can add our own optimization rules. Suppose we’d like to expand saturated calls of the <a href="purelib.html#succ"><code>succ</code></a> function. This function is defined in the prelude; it just adds 1 to its single argument. We can inline such calls as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">def</span> succ (x+y) = x+(y+<span class="dv">1</span>);
&gt; <span class="kw">def</span> succ x = x+<span class="dv">1</span>;
&gt; foo x = succ (succ (succ x));
&gt; show foo
foo x = x+<span class="dv">3</span>;</code></pre></div>
<p>Again, let’s see exactly what’s going on there:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; trace -m succ
&gt; succ (succ (succ x));
-- macro succ: succ x --&gt; x+<span class="dv">1</span>
-- macro succ: succ (x+<span class="dv">1</span>) --&gt; x+(<span class="dv">1</span>+<span class="dv">1</span>)
-- macro succ: succ (x+(<span class="dv">1</span>+<span class="dv">1</span>)) --&gt; x+(<span class="dv">1</span>+<span class="dv">1</span>+<span class="dv">1</span>)
x+<span class="dv">3</span></code></pre></div>
<p>Note that the contraction of the subterm <code>1+1+1</code> to the integer constant <code>3</code> is actually done by the compiler after macro expansion has been performed. This is also called “constant folding”, see <a href="#constant-definitions">Constant Definitions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for details. It is also the reason that we added the first rule for <code>succ</code>. This rule may seem superflous at first sight, but actually it is needed to massage the sum into a form which enables constant folding.</p>
<p>Rules like these can help the compiler generate better code. Of course, the above examples are still rather elementary. Pure macros can do much more elaborate optimizations, but for this we first need to discuss how to write recursive macros, as well as macros which take apart special terms like lambdas. After that we’ll return to the subject of optimization rules in <a href="#advanced-optimization">Advanced Optimization</a> below.</p>
<h3 id="recursive-macros">Recursive Macros</h3>
<p>Macros can also be recursive, in which case they usually consist of multiple rules and make use of pattern-matching just like ordinary function definitions.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> Pure macros are just as powerful as (unconditional) term rewriting systems and thus they are Turing-complete. This implies that a badly written macro may well send the Pure compiler into an infinite recursion, which results in a stack overflow at compile time.</p>
</blockquote>
<hr />
<p>As a simple example, let’s see how we can inline invocations of the <a href="purelib.html##"><code>#</code></a> size operator on list constants:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">def</span> #[] = <span class="dv">0</span>;
<span class="kw">def</span> #(x:xs) = #xs+<span class="dv">1</span>;</code></pre></div>
<p>As you can see, the definition is pretty straightforward; exactly the same rules might also be used for an ordinary function definition, although the standard library actually implements <a href="purelib.html##"><code>#</code></a> a bit differently to make good use of tail recursion. Let’s check that this actually works:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo = #[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>];
&gt; show foo
foo = <span class="dv">4</span>;</code></pre></div>
<p>Note that the result of macro expansion is actually <code>0+1+1+1+1</code> here, you can check that by running the macro with <code>trace -m #</code>. Constant folding contracts this to <code>4</code> after macro expansion, as explained in the previous subsection.</p>
<p>This was rather easy. So let’s implement a more elaborate example: a basic Pure version of Lisp’s quasiquote which allows you to create a quoted expression from a “template” while substituting variable parts of the template. (For the sake of brevity, we present a somewhat abridged version here which does not cover all corner cases. The full version of this macro can be found as lib/quasiquote.pure in the Pure distribution.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">def</span> quasiquote (unquote x)      = x;
<span class="kw">def</span> quasiquote (f@_ (splice x)) = foldl ($) (quasiquote f) x;
<span class="kw">def</span> quasiquote (f@_ x)          = quasiquote f (quasiquote x);
<span class="kw">def</span> quasiquote x                = quote x;</code></pre></div>
<p>(Note the <code>f@_</code>, which is an anonymous “as” pattern forcing the compiler to recognize <code>f</code> as a function variable, rather than a literal function symbol. See <a href="#as-patterns">“As” Patterns</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for an explanation of this trick.)</p>
<p>The first rule above takes care of “unquoting” embedded subterms. The second rule “splices” an argument list into an enclosing function application. The third rule recurses into subterms of a function application, and the fourth and last rule takes care of quoting the “atomic” subterms. Note that <code>unquote</code> and <code>splice</code> themselves are just passive constructor symbols, the real work is done by <code>quasiquote</code>, using <a href="purelib.html#foldl"><code>foldl</code></a> at runtime to actually perform the splicing. (Putting off the splicing until runtime makes it possible to splice argument lists computed at runtime.)</p>
<p>If we want, we can also add some syntactic sugar for Lisp weenies. (Note that we cannot have ‘<code>,</code>’ for unquoting, so we use ‘<code>,$</code>’ instead.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">prefix</span> <span class="dv">9</span> ` ,$ ,@ ;
<span class="kw">def</span> `x = quasiquote x; <span class="kw">def</span> ,$x = unquote x; <span class="kw">def</span> ,@x = splice x;</code></pre></div>
<p>Examples:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; `(<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span>);
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">2</span>^<span class="dv">12</span>
&gt; `(<span class="dv">2</span>*<span class="dv">42</span>+,$(<span class="dv">2</span>^<span class="dv">12</span>));
<span class="dv">2</span>*<span class="dv">42</span>+<span class="dv">4096.0</span>
&gt; `foo <span class="dv">1</span> <span class="dv">2</span> (,@&#39;[<span class="dv">2</span>/<span class="dv">3</span>,<span class="dv">3</span>/<span class="dv">4</span>]) (<span class="dv">5</span>/<span class="dv">6</span>);
foo <span class="dv">1</span> <span class="dv">2</span> (<span class="dv">2</span>/<span class="dv">3</span>) (<span class="dv">3</span>/<span class="dv">4</span>) (<span class="dv">5</span>/<span class="dv">6</span>)
&gt; `foo <span class="dv">1</span> <span class="dv">2</span> (,@args) (<span class="dv">5</span>/<span class="dv">6</span>) <span class="kw">when</span> args = &#39;[<span class="dv">2</span>/<span class="dv">3</span>,<span class="dv">3</span>/<span class="dv">4</span>] <span class="kw">end</span>;
foo <span class="dv">1</span> <span class="dv">2</span> (<span class="dv">2</span>/<span class="dv">3</span>) (<span class="dv">3</span>/<span class="dv">4</span>) (<span class="dv">5</span>/<span class="dv">6</span>)</code></pre></div>
<h3 id="user-defined-special-forms">User-Defined Special Forms</h3>
<p>The <code>quasiquote</code> macro in the preceding subsection also provides an example of how you can use macros to define your own special forms. This works because the actual evaluation of macro arguments is put off until runtime, and thus we can safely pass them to built-in special forms and other constructs which defer their evaluation <em>at runtime</em>. In fact, the right-hand side of a macro rule may be an arbitrary Pure expression involving conditional expressions, lambdas, binding clauses, etc. These are never evaluated during macro substitution, they just become part of the macro expansion (after substituting the macro parameters).</p>
<p>Here is another useful example of a user-defined special form, the macro <code>timex</code> which employs the system function <code>clock</code> to report the cpu time in seconds needed to evaluate a given expression, along with the computed result:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; <span class="kw">def</span> timex x = (clock-t0)/CLOCKS_PER_SEC,y <span class="kw">when</span> t0 = clock; y = x <span class="kw">end</span>;
&gt; sum = foldl (+) 0L;
&gt; timex $ sum (1L..100000L);
<span class="dv">0.43</span>,5000050000L</code></pre></div>
<p>Note that the above definition of <code>timex</code> wouldn’t work as an ordinary function definition, since by virtue of Pure’s basic eager evaluation strategy the <code>x</code> parameter would have been evaluated already before it is passed to <code>timex</code>, making <code>timex</code> always return a zero time value. Try it!</p>
<h3 id="macro-hygiene">Macro Hygiene</h3>
<p>Pure macros are lexically scoped, i.e., the binding of symbols in the right-hand-side of a macro definition is determined statically by the text of the definition, and macro parameter substitution also takes into account binding constructs, such as <a href="#with"><code>with</code></a> and <a href="#when"><code>when</code></a> clauses, in the right-hand side of the definition. Macro facilities with these pleasant properties are also known as <strong>hygienic macros</strong>. They are not susceptible to so-called “name capture,” which makes macros in less sophisticated languages bug-ridden and hard to use.</p>
<p>Macro hygiene is a somewhat esoteric topic for most programmers, so let us take a brief look at what it’s all about. The problem avoided by hygienic macros is that of <em>name capture</em>. There are actually two kinds of name capture which may occur in unhygienic macro systems:</p>
<ul>
<li>A free symbol in the macro <em>body</em> inadvertently becomes bound to the value of a local symbol in the context in which the macro is called.</li>
<li>A free symbol in the macro <em>call</em> inadvertently becomes bound to the value of a local symbol in the macro body.</li>
</ul>
<p>Pure’s hygienic macros avoid both pitfalls. Here is an example for the first form of name capture:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">def</span> G x = x+y;
&gt; G <span class="dv">10</span> <span class="kw">when</span> y = <span class="dv">99</span> <span class="kw">end</span>;
<span class="dv">10</span>+y</code></pre></div>
<p>Note that the expansion of the <code>G</code> macro correctly uses the global instance of <code>y</code>, even though <code>y</code> is locally defined in the context of the macro call. (In some languages this form of name capture is sometimes used deliberately in order to make the macro use the binding of the symbol which is active at the point of the macro call. Normally, this won’t work in Pure, although there is a way to force this behaviour in Pure as well, see <a href="#name-capture">Name Capture</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section.)</p>
<p>In contrast, the second form of name capture is usually not intended, and is therefore more dangerous. Consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">def</span> F x = x+y <span class="kw">when</span> y = x+<span class="dv">1</span> <span class="kw">end</span>;
&gt; F y;
y+(y+<span class="dv">1</span>)</code></pre></div>
<p>Pure again gives the correct result here. You’d have to be worried if you got <code>(y+1)+(y+1)</code> instead, which would result from the literal expansion <code>y+y when y = y+1 end</code>, where the (free) variable <code>y</code> passed to <code>F</code> gets captured by the local binding of <code>y</code>. In fact, that’s exactly what you get with C macros:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#define F(x) { int y = x+1; return x+y; }</span></code></pre></div>
<p>Here <code>F(y)</code> expands to <code>{ int y = y+1; return y+y; }</code> which is usually <em>not</em> what you want.</p>
<p>This completes our little introduction to Pure’s macro facilities. The above material should in fact cover all the common uses of macros in Pure. However, if you want to become a real Pure macro wizard then read on. In the following subsections we’re going to discover some more advanced features of Pure’s macro system which let you write macros for manipulating special forms and give you access to Pure’s reflection capabilities.</p>
<h3 id="built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</h3>
<p>As already mentioned in <a href="#the-quote">The Quote</a>, <a href="#special-expressions">special expressions</a> such as conditionals and lambdas cannot be directly represented as runtime data in Pure. But they can be <em>quoted</em> in which case they are replaced by corresponding “placeholder terms”. These placeholder terms are in fact implemented as built-in macros which, when evaluated, construct the corresponding specials.</p>
<dl>
<dt><a name="__ifelse__"></a><em>macro</em> <code>__ifelse__ x y z</code></dt>
<dd>This macro expands to the conditional expression <code>if x then y else z</code> during macro evaluation.
</dd>
<dt><a name="__lambda__"></a><em>macro</em> <code>__lambda__ [x1,...,xn] y</code></dt>
<dd>Expands to the lambda expression <code>\x1 ... xn -&gt; y</code>.
</dd>
<dt><a name="__case__"></a><em>macro</em> <code>__case__ x [(x1 --&gt; y1),...,(xn --&gt; yn)]</code></dt>
<dd>Expands to the <a href="#case"><code>case</code></a> expression <code>case x of x1 = y1; ...; xn = yn end</code>. Note that the <a href="#--%3E"><code>--&gt;</code></a> symbol is used to separate the left-hand side and the right-hand side of each rule (see below).
</dd>
<dt><a name="__when__"></a><em>macro</em> <code>x __when__ [(x1 --&gt; y1),...,(xn --&gt; yn)]</code></dt>
<dd>Expands to the <a href="#when"><code>when</code></a> expression <code>x when x1 = y1; ...; xn = yn end</code>. Here the left-hand side of a rule may be omitted if it is just the anonymous variable; i.e., <code>x __when__ [foo y]</code> is the same as <code>x __when__ [_ --&gt; foo y]</code>.
</dd>
<dt><a name="__with__"></a><em>macro</em> <code>x __with__ [(x1 --&gt; y1),...,(xn --&gt; yn)]</code></dt>
<dd>Expands to the <a href="#with"><code>with</code></a> expression <code>x with x1 = y1; ...; xn = yn end</code>.
</dd>
</dl>
<!-- -->
<p>Note that the following low-priority infix operators are used to denote equations in the <a href="#__case__"><code>__case__</code></a>, <a href="#__when__"><code>__when__</code></a> and <a href="#__with__"><code>__with__</code></a> macros:</p>
<dl>
<dt><a name="--&gt;"></a><code>x --&gt; y</code></dt>
<dd>Denotes an equation <code>x = y</code>.
</dd>
<dt><a name="__if__"></a><code>x __if__ y</code></dt>
<dd>Attaches a guard to the right-hand side of an equation. That is, <code>x --&gt; y __if__ z</code> denotes the conditional equation <code>x = y if z</code>. This symbol is only recognized in <a href="#__case__"><code>__case__</code></a> and <a href="#__with__"><code>__with__</code></a> calls.
</dd>
</dl>
<!-- -->
<p>In addition, patterns on the left-hand side of equations or in lambda arguments may be decorated with the following constructor terms to indicate “as” patterns and type tags (these are infix operators with a very high priority):</p>
<dl>
<dt><a name="__as__"></a><code>x __as__ y</code></dt>
<dd>Denotes an “as” pattern <code>x @ y</code>.
</dd>
<dt><a name="__type__"></a><code>x __type__ y</code></dt>
<dd>Denotes a type tag <code>x :: y</code>.
</dd>
</dl>
<!-- -->
<p>Note that all these symbols are in fact just constructors which are only interpreted in the context of the built-in macros listed above; they aren’t macros themselves.</p>
<p>It’s good to remember the above when you’re doing macro programming. However, to see the placeholder term of a special, you can also just type a quoted expression in the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;(\x-&gt;x+<span class="dv">1</span>);
__lambda__ [x] (x+<span class="dv">1</span>)
&gt; &#39;(f <span class="kw">with</span> f x = y <span class="kw">when</span> y = x+<span class="dv">1</span> <span class="kw">end</span> <span class="kw">end</span>);
f __with__ [f x--&gt;y __when__ [y--&gt;x+<span class="dv">1</span>]]</code></pre></div>
<p>List and matrix comprehensions can also be quoted. These are basically syntactic sugar for lambda applications, cf. <a href="#primary-expressions">Primary Expressions</a>. The compiler expands them to their “unsugared” form already before macro substitution, so no special kinds of built-in macros are needed to represent them. When quoted, comprehensions are thus denoted in their unsugared form, which consists of a pile of lambda expressions and list or matrix construction functions for the generation clauses, and possibly some conditionals for the filter clauses of the comprehension. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;[<span class="dv">2</span>*x | x = <span class="dv">1</span>..<span class="dv">3</span>];
listmap (__lambda__ [x] (<span class="dv">2</span>*x)) (<span class="dv">1</span>..<span class="dv">3</span>)</code></pre></div>
<p>Here’s how type tags and “as” patterns in quoted specials look like:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;(\x::<span class="dt">int</span>-&gt;x+<span class="dv">1</span>);
__lambda__ [x __type__ <span class="dt">int</span>] (x+<span class="dv">1</span>)
&gt; &#39;(dup (<span class="dv">1</span>..<span class="dv">3</span>) <span class="kw">with</span> dup xs@(x:_) = x:xs <span class="kw">end</span>);
dup (<span class="dv">1</span>..<span class="dv">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]</code></pre></div>
<p>Note that the placeholder terms for the specials are quoted here, and hence they are not evaluated (quoting inhibits macro expansion, just like it prevents the evaluation of ordinary function calls). Evaluating the placeholder terms executes the corresponding specials:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; &#39;(dup (<span class="dv">1</span>..<span class="dv">3</span>) <span class="kw">with</span> dup xs@(x:_) = x:xs <span class="kw">end</span>);
dup (<span class="dv">1</span>..<span class="dv">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]
&gt; eval ans;
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</code></pre></div>
<p>Of course, you can also just enter the macros directly (without quoting) to have them evaluated:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; dup (<span class="dv">1</span>..<span class="dv">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs];
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
&gt; __lambda__ [x __type__ <span class="dt">int</span>] (x+<span class="dv">1</span>);
#&lt;closure <span class="dv">0x7f1934158dc8</span>&gt;
&gt; ans <span class="dv">99</span>;
<span class="dv">100</span></code></pre></div>
<p>The <a href="purelib.html#__str__"><code>__str__</code></a> function can be used to pretty-print quoted specials:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; __str__ (&#39;__lambda__ [x __type__ <span class="dt">int</span>] (x+<span class="dv">1</span>));
<span class="st">&quot;</span><span class="ch">\\</span><span class="st">x::int -&gt; x+1&quot;</span>
&gt; __str__ (&#39;(dup (<span class="dv">1</span>..<span class="dv">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]));
<span class="st">&quot;dup (1..3) with dup xs@(x:_) = x:xs end&quot;</span></code></pre></div>
<p>This is useful to see which expression a quoted special will expand to. Note that <a href="purelib.html#__str__"><code>__str__</code></a> can also be used to define print representations for quoted specials with <a href="#__show__"><code>__show__</code></a> (described in <a href="#pretty-printing">Pretty-Printing</a>) if you always want to have them printed that way by the interpreter.</p>
<p>As quoted specials are just ordinary Pure expressions, they can be manipulated by functions just like any other term. For instance, here’s how you can define a function which takes a quoted lambda and swaps its two arguments:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; swap (__lambda__ [x,y] z) = &#39;(__lambda__ [y,x] z);
&gt; swap (&#39;(\a b-&gt;a-b));
__lambda__ [b,a] (a-b)
&gt; eval ans <span class="dv">2</span> <span class="dv">3</span>; <span class="co">// same as (\b a-&gt;a-b) 2 3</span>
<span class="dv">1</span></code></pre></div>
<p>For convenience, a literal special expression can also be used on the left-hand side of an equation, in which case it actually denotes the corresponding placeholder term. So the <code>swap</code> function can also be defined like this (note that we first scratch the previous definition of <code>swap</code> with the <code>clear</code> command, see <a href="#interactive-commands">Interactive Commands</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear swap
&gt; swap (\x y -&gt; z) = &#39;(\y x -&gt; z);
&gt; swap (&#39;(\a b-&gt;a-b));
__lambda__ [b,a] (a-b)</code></pre></div>
<p>This is usually easier to write and improves readability. However, there are cases in which you want to work with the built-in macros in a direct fashion. In particular, this becomes necessary when writing more generic rules which deal, e.g., with lambdas involving a variable number of arguments, or if you need real (i.e., unquoted) type tags or “as” patterns in a placeholder pattern. We’ll see examples of these later.</p>
<p>Quoted specials can be manipulated with macros just as well as with functions. In fact, this is quite common and thus the macro evaluator has some special support to make this more convenient. Specifically, it is possible to make a macro quote its arguments in an automatic fashion, by means of the <a href="#cmdoption-pure-pragma--quoteargs"><code>--quoteargs</code></a> pragma. To illustrate this, let’s redefine <code>swap</code> as a macro:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear swap
&gt; #! --quoteargs swap
&gt; <span class="kw">def</span> swap (\x y -&gt; z) = &#39;(\y x -&gt; z);
&gt; swap (\a b-&gt;a-b);
__lambda__ [b,a] (a-b)</code></pre></div>
<p>The <a href="#cmdoption-pure-pragma--quoteargs"><code>--quoteargs</code></a> pragma makes the <code>swap</code> macro receive its argument unevaluated, as if it was quoted (but without a literal quote around it). Therefore the quote on the lambda argument of <code>swap</code> can now be omitted. However, the result is still a quoted lambda. It’s tempting to just omit the quote on the right-hand side of the macro definition as well, in order to get a real lambda instead:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear swap
&gt; <span class="kw">def</span> swap (\x y -&gt; z) = \y x -&gt; z;
&gt; swap (\a b-&gt;a-b);
#&lt;closure <span class="dv">0x7f1934156f00</span>&gt;
&gt; ans <span class="dv">2</span> <span class="dv">3</span>;
a-b</code></pre></div>
<p>We got a closure all right, but apparently it’s not the right one. Let’s use <code>trace -m</code> to figure out what went wrong:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; trace -m swap
&gt; swap (\a b-&gt;a-b);
-- macro swap: swap (\a b -&gt; a-b) --&gt; \y x -&gt; a-b
#&lt;closure <span class="dv">0x7f1934157248</span>&gt;</code></pre></div>
<p>Ok, so the result is the lambda <code>\y x -&gt; a-b</code>, not <code>\b a -&gt; a-b</code> as we expected. This happens because we used a literal (unquoted) lambda on the right-hand side, which does its own variable binding; consequently, the variables <code>x</code> and <code>y</code> are bound by the lambda in this context, not by the left-hand side of the macro rule.</p>
<p>So just putting an unquoted lambda on the right-hand side doesn’t do the job. One way to deal with the situation is to just employ the <code>__lambda__</code> macro in a direct way, as we’ve seen before:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear swap
&gt; <span class="kw">def</span> swap (__lambda__ [x,y] z) = __lambda__ [y,x] z;
&gt; swap (\a b-&gt;a-b);
-- macro swap: swap (\a b -&gt; a-b) --&gt; __lambda__ [b,a] (a-b)
-- macro __lambda__: __lambda__ [b,a] (a-b) --&gt; \b a -&gt; a-b
#&lt;closure <span class="dv">0x7f1934156f00</span>&gt;
&gt; ans <span class="dv">2</span> <span class="dv">3</span>;
<span class="dv">1</span></code></pre></div>
<p>This works, but doesn’t look very nice. Often it’s more convenient to first construct a quoted term involving the necessary specials and then have it evaluated during macro evaluation. Pure provides yet another built-in macro for this purpose:</p>
<dl>
<dt><a name="__eval__"></a><em>macro</em> <code>__eval__ x</code></dt>
<dd>Evaluate <code>x</code> at macro expansion time. This works by stripping one level of (outermost) quotes from <code>x</code> and performing macro expansion on the resulting unquoted subexpressions.
</dd>
</dl>
<!-- -->
<p>Using <a href="#__eval__"><code>__eval__</code></a>, we can implement the <code>swap</code> macro as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear swap
&gt; <span class="kw">def</span> swap (\x y -&gt; z) = __eval__ (&#39;(\y x -&gt; z));
&gt; swap (\a b-&gt;a-b);
-- macro swap: swap (\a b -&gt; a-b) --&gt; __eval__ (&#39;__lambda__ [b,a] (a-b))
-- macro __lambda__: __lambda__ [b,a] (a-b) --&gt; \b a -&gt; a-b
-- macro __eval__: __eval__ (&#39;__lambda__ [b,a] (a-b)) --&gt; \b a -&gt; a-b
#&lt;closure <span class="dv">0x7f7e1f867dc8</span>&gt;
&gt; ans <span class="dv">2</span> <span class="dv">3</span>;
<span class="dv">1</span></code></pre></div>
<p>Lisp programmers should note the difference. In Lisp, macros usually yield a quoted expression which is evaluated implicitly during macro expansion. This is never done automatically in Pure, since many Pure macros work perfectly well without it. Instead, quotes in a macro expansion are treated as literals, and you’ll have to explicitly call <code>__eval__</code> to remove them during macro evaluation.</p>
<p>A final caveat: Placeholder terms for specials are just simple expressions; they don’t do any variable binding by themselves. Thus the rules of <a href="#macro-hygiene">macro hygiene</a> don’t apply to them, which makes it possible to manipulate lambdas and local definitions in any desired way. On the other hand, this means that it is the programmer’s responsibility to avoid accidental name capture when using these facilities. Most macro code will work all right when written in a straightforward way, but there are some corner cases which need special attention (cf. <a href="#name-capture">Name Capture</a>).</p>
<p>Sometimes the only convenient way to avoid name capture is to create new symbols on the fly. This will often be necessary if a macro generates an entire block construct (<a href="#case"><code>case</code></a>, <a href="#when"><code>when</code></a>, <a href="#with"><code>with</code></a> or lambda) from scratch. The following built-in macro is provided for this purpose:</p>
<dl>
<dt><a name="__gensym__"></a><em>macro</em> <code>__gensym__</code></dt>
<dd>Create a new unqualified symbol which is guaranteed to not exist at the time of the macro call. These symbols typically look like <code>__x123__</code> and can be used for any purpose (i.e., as global or local as well as function or variable symbols).
</dd>
</dl>
<!-- -->
<p>For instance, here’s how we can implement a macro <code>foo</code> which creates a lambda from a given argument, using <a href="#__gensym__"><code>__gensym__</code></a> to generate a fresh local variable for the lambda argument. This guarantees that variables in the argument expression don’t get captured by the lambda variable when the closure is created with a call to the built-in <a href="#__lambda__"><code>__lambda__</code></a> macro.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">def</span> foo x = bar __gensym__ x;
&gt; <span class="kw">def</span> bar x y = __lambda__ [x] (x+y);
&gt; trace -m foo
&gt; foo (a*b);
-- macro foo: foo (a*b) --&gt; bar __gensym__ (a*b)
-- macro __gensym__: __gensym__ --&gt; __x1__
-- macro bar: bar __x1__ (a*b) --&gt; __lambda__ [__x1__] (__x1__+a*b)
-- macro __lambda__: __lambda__ [__x1__] (__x1__+a*b) --&gt; \__x1__ -&gt; __x1__+a*b
#&lt;closure <span class="dv">0x7f66f6c88db0</span>&gt;
&gt; ans <span class="dv">77</span>;
<span class="dv">77</span>+a*b</code></pre></div>
<p>The <a href="#__gensym__"><code>__gensym__</code></a> macro returns a new variable for each invocation, and always ensures that it doesn’t accidentally reuse a symbol already introduced by the user (even if it looks like a symbol that <a href="#__gensym__"><code>__gensym__</code></a> might itself create):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo (a*__x2__);
-- macro foo: foo (a*__x2__) --&gt; bar __gensym__ (a*__x2__)
-- macro __gensym__: __gensym__ --&gt; __x3__
-- macro bar: bar __x3__ (a*__x2__) --&gt; __lambda__ [__x3__] (__x3__+a*__x2__)
-- macro __lambda__: __lambda__ [__x3__] (__x3__+a*__x2__) --&gt; \__x3__ -&gt; __x3__+a*__x2__
#&lt;closure <span class="dv">0x7f66f6c887e8</span>&gt;
&gt; ans <span class="dv">77</span>;
<span class="dv">77</span>+a*__x2__</code></pre></div>
<h3 id="advanced-optimization">Advanced Optimization</h3>
<p>We are now in a position to have a look at some of the trickier optimization macros defined in the prelude. The following <code>__do__</code> macro can be found near the end of the prelude.pure module; it is used to optimize the case of “throwaway” list and matrix comprehensions. This is useful if a comprehension is evaluated solely for its side effects. To keep things simple, we discuss a slightly abridged version of the <code>__do__</code> macro which only deals with list comprehensions and ignores some obscure corner cases. You can find this version in the examples/do.pure script. Please also check the prelude for the full version of this macro.</p>
<p>Note that we define our own versions of <code>void</code> and <code>__do__</code> here which are placed into the <code>my</code> namespace to avoid conflicts with the prelude.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> my;

<span class="dt">void</span> _ = ();

#! --quoteargs my::__do__

<span class="kw">def</span> <span class="dt">void</span> [x] = <span class="dt">void</span> x;
<span class="kw">def</span> <span class="dt">void</span> (catmap f x) | <span class="dt">void</span> (listmap f x) = __do__ f x;

<span class="co">// Recurse into embedded generator clauses.</span>
<span class="kw">def</span> __do__ (__lambda__ [x] y@(listmap _ _)) |
    __do__ (__lambda__ [x] y@(catmap _ _)) =
    __do__ $ (__lambda__ [x] (<span class="dt">void</span> y));

<span class="co">// Recurse into embedded filter clauses.</span>
<span class="kw">def</span> __do__ (__lambda__ [x] (__ifelse__ y z [])) =
    __do__ $ (__lambda__ [x] (__ifelse__ y (<span class="dt">void</span> z) ()));

<span class="co">// Eliminate extra calls to &#39;void&#39; in generator clauses.</span>
<span class="kw">def</span> __do__ (__lambda__ [x] (<span class="dt">void</span> y)) = __do__ (__lambda__ [x] y);

<span class="co">// Eliminate extra calls to &#39;void&#39; in filter clauses.</span>
<span class="kw">def</span> __do__ (__lambda__ [x] (__ifelse__ y (<span class="dt">void</span> z) ())) =
    __do__ (__lambda__ [x] (__ifelse__ y z ()));

<span class="co">// Any remaining instances reduce to a plain &#39;do&#39; (this must come last).</span>
<span class="kw">def</span> __do__ f = do f;</code></pre></div>
<p>First, note that the <a href="purelib.html#void"><code>void</code></a> function simply throws away its argument and returns <a href="purelib.html#()"><code>()</code></a> instead. The <a href="purelib.html#do"><code>do</code></a> function applies a function to every member of a list (like <a href="purelib.html#map"><code>map</code></a>), but throws away all intermediate results and just returns <a href="purelib.html#()"><code>()</code></a>, which is much more efficient if you don’t need those results anyway. These are both defined in the prelude, but we define our own version of <code>void</code> here so that we can hook it up to our simplified version of the <code>__do__</code> macro.</p>
<p>The <code>__do__</code> macro eventually reduces to just a plain <code>do</code> call, but applies some optimizations along the way. While the above rules for <code>__do__</code> are always valid optimizations for <code>do</code>, it’s a good idea to use a separate macro here instead of clobbering <code>do</code> itself, so that these optimizations do not interfere with calls to <code>do</code> in ordinary user code. The prelude handles this in an analogous fashion.</p>
<p>Before we further delve into this example, a few remarks are in order about the way list comprehensions are implemented in Pure. As already mentioned, list comprehensions are just syntactic sugar; the compiler immediately transforms them to an equivalent expression involving only lambdas and a few other list operations. The latter are essentially equivalent to piles of nested filters and maps, but for various reasons they are actually implemented using two special helper operations, <a href="purelib.html#catmap"><code>catmap</code></a> and <a href="purelib.html#listmap"><code>listmap</code></a>.</p>
<p>The <a href="purelib.html#catmap"><code>catmap</code></a> operation combines <a href="purelib.html#map"><code>map</code></a> and <a href="purelib.html#cat"><code>cat</code></a>; this is needed, in particular, to accumulate the results of nested generators, such as <code>[i,j | i = 1..n; j = 1..m]</code>. The same operation is also used to implement filter clauses, you can see this below in the examples. However, for efficiency simple generators like <code>[2*i | i = 1..n]</code> are translated to a <a href="purelib.html#listmap"><code>listmap</code></a> instead (which is basically just <a href="purelib.html#map"><code>map</code></a>, but works with different aggregate types, so that list comprehensions can draw values from aggregates other than lists, such as matrices).</p>
<p>Now let’s see how the rules above transform a list comprehension if we “void” it. (Remember to switch to the <code>my</code> namespace when trying the following examples.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; <span class="kw">using</span> <span class="kw">namespace</span> my;
&gt; f = [printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>) | x=<span class="dv">1</span>..<span class="dv">5</span>; x mod <span class="dv">2</span>];
&gt; g = <span class="dt">void</span> [printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>) | x=<span class="dv">1</span>..<span class="dv">5</span>; x mod <span class="dv">2</span>];
&gt; show f g
f = catmap (\x -&gt; <span class="kw">if</span> x mod <span class="dv">2</span> <span class="kw">then</span> [printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>)] <span class="kw">else</span> []) (<span class="dv">1</span>..<span class="dv">5</span>);
g = do (\x -&gt; <span class="kw">if</span> x mod <span class="dv">2</span> <span class="kw">then</span> printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>) <span class="kw">else</span> ()) (<span class="dv">1</span>..<span class="dv">5</span>);</code></pre></div>
<p>As you can see, the <a href="purelib.html#catmap"><code>catmap</code></a> got replaced with a <a href="purelib.html#do"><code>do</code></a>, and the list brackets inside the lambda were eliminated as well. These optimizations are just what’s needed to make this code go essentially as fast as a <code>for</code> loop in traditional programming languages (up to constant factors, of course). Here’s how it looks like when we run the <code>g</code> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; g;
<span class="dv">3</span>
<span class="dv">9</span>
<span class="dv">33</span>
()</code></pre></div>
<p>It’s also instructive to have a look at how the above macro rules work in concert to rewrite a “voided” comprehension. To these ends, you can rerun the right-hand side of <code>g</code> with some tracing enabled, as follows (we omit the tracing output here for brevity):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; trace -m my::<span class="dt">void</span>
&gt; <span class="dt">void</span> [printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>) | x=<span class="dv">1</span>..<span class="dv">5</span>; x mod <span class="dv">2</span>];</code></pre></div>
<p>The above optimization rules also take care of nested list comprehensions, since they recurse into the lambda bodies of generator and filter clauses. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; h = <span class="dt">void</span> [puts $ str (x,y) | x=<span class="dv">1</span>..<span class="dv">2</span>; y=<span class="dv">1</span>..<span class="dv">3</span>];
&gt; show h
h = do (\x -&gt; do (\y -&gt; puts (str (x,y))) (<span class="dv">1</span>..<span class="dv">3</span>)) (<span class="dv">1</span>..<span class="dv">2</span>);</code></pre></div>
<p>Again, you should run this with macro tracing enabled to see how the <code>__do__</code> macro recurses into the outer lambda body of the list comprehension. Here’s the rule which actually does this:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">def</span> __do__ (__lambda__ [x] y@(catmap _ _)) =
    __do__ $ (__lambda__ [x] (<span class="dt">void</span> y));</code></pre></div>
<p>Note that in order to make this work, <code>__do__</code> is implemented as a “<a href="#cmdoption-pure-pragma--quoteargs"><code>quoteargs</code></a>” macro so that it can inspect and recurse into the lambda terms in its argument. Also note the <a href="purelib.html#$"><code>$</code></a> on the right-hand side of this rule; this is also implemented as a macro in the prelude. Here the <a href="purelib.html#$"><code>$</code></a> operator is used to forcibly evaluate the macro argument <code>__lambda__ [x] (void y)</code>, so that the embedded call to the <code>void</code> macro gets expanded. (Without the <a href="purelib.html#$"><code>$</code></a> the argument to <code>__do__</code> would be quoted and thus not be evaluated.) A similar rule is used to recurse into embedded filter clauses, as in the example of the function <code>g</code> above.</p>
<p>It should be mentioned that, while our version of the <code>__do__</code> macro will properly handle most list comprehensions, there is a rather obscure corner case which it still refuses to optimize: outermost filter clauses. For instance, consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> c = <span class="dv">2</span>;
&gt; k = <span class="dt">void</span> [printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>) | c&gt;<span class="dv">0</span>; x=<span class="dv">1</span>..<span class="dv">3</span>];
&gt; show k
k = my::<span class="dt">void</span> (<span class="kw">if</span> c&gt;<span class="dv">0</span> <span class="kw">then</span> listmap (\x -&gt; printf <span class="st">&quot;%g</span><span class="ch">\n</span><span class="st">&quot;</span> (<span class="dv">2</span>^x+<span class="dv">1</span>)) (<span class="dv">1</span>..<span class="dv">3</span>) <span class="kw">else</span> []);</code></pre></div>
<p>It’s possible to handle this case as well, but we have to go to some lengths to achieve that. The complication here is that we don’t want to mess with calls to <code>void</code> in ordinary user code, so <code>void</code> itself cannot be a “<a href="#cmdoption-pure-pragma--quoteargs"><code>quoteargs</code></a>” macro. But the quoted form of <code>void</code>’s argument is needed to detect the “outermost filter clause” situation. The interested reader may refer to the prelude code to see how the prelude implementation of <code>__do__</code> uses some helper macros to make this work. Another detail of the full version of <code>__do__</code> is the handling of patterns on the left-hand side of generator clauses, which requires some special magic to filter out unmatched list elements; we also omitted this here for brevity.</p>
<h3 id="reflection">Reflection</h3>
<p>The meta representation of specials discussed in <a href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a> is also useful to obtain information about the running program and even modify it. Pure’s runtime provides some built-in operations to implement these reflection capabilities, which are comparable in scope to what the Lisp programming language offers.</p>
<p>Specifically, the <a href="purelib.html#get_fundef"><code>get_fundef</code></a> function allows you to retrieve the definition of a global Pure function. Given the symbol denoting the function, <a href="purelib.html#get_fundef"><code>get_fundef</code></a> returns the list of rewriting rules implementing the functions, using the same <code>lhs --&gt; rhs</code> format used by the <a href="#__case__"><code>__case__</code></a>, <a href="#__when__"><code>__when__</code></a> and <a href="#__with__"><code>__with__</code></a> macros discussed above. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n = <span class="dv">1</span> <span class="kw">if</span> n&lt;=<span class="dv">1</span>;
&gt;        = n*fact (n-<span class="dv">1</span>) <span class="kw">otherwise</span>;
&gt; get_fundef fact;
[(fact n--&gt;<span class="dv">1</span> __if__ n&lt;=<span class="dv">1</span>),(fact n--&gt;n*fact (n-<span class="dv">1</span>))]</code></pre></div>
<p>Defining a new function or extending an existing function definition can be done just as easily, using the <a href="purelib.html#add_fundef"><code>add_fundef</code></a> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; add_fundef $ &#39;[(fib n--&gt;<span class="dv">1</span> __if__ n&lt;=<span class="dv">1</span>),(fib n--&gt;fib (n-<span class="dv">2</span>)+fib (n-<span class="dv">1</span>))];
()
&gt; show fib
fib n = <span class="dv">1</span> <span class="kw">if</span> n&lt;=<span class="dv">1</span>;
fib n = fib (n-<span class="dv">2</span>)+fib (n-<span class="dv">1</span>);
&gt; map fib (<span class="dv">0</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">13</span>,<span class="dv">21</span>,<span class="dv">34</span>,<span class="dv">55</span>,<span class="dv">89</span>]</code></pre></div>
<p>Note that, to be on the safe side, we quoted the rule list passed to <a href="purelib.html#add_fundef"><code>add_fundef</code></a> to prevent premature evaluation of symbols used in the rules. This is necessary because <a href="purelib.html#add_fundef"><code>add_fundef</code></a> is an ordinary function, not a macro. (Of course, you could easily define a macro which would take care of this, if you like. We leave this as an exercise to the reader.)</p>
<p>Also note that <a href="purelib.html#add_fundef"><code>add_fundef</code></a> doesn’t override existing function definitions. It simply keeps on adding rules to the current program, just as if you typed the equations at the command prompt of the interpreter. It is possible to delete individual equations with <a href="purelib.html#del_fundef"><code>del_fundef</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; del_fundef $ &#39;(fib n--&gt;fib (n-<span class="dv">2</span>)+fib (n-<span class="dv">1</span>));
()
&gt; show fib
fib n = <span class="dv">1</span> <span class="kw">if</span> n&lt;=<span class="dv">1</span>;</code></pre></div>
<p>Moreover, the <a href="purelib.html#clearsym"><code>clearsym</code></a> function allows you to completely get rid of an existing function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clearsym fib <span class="dv">0</span>;
()
&gt; show fib
&gt; fib <span class="dv">9</span>;
fib <span class="dv">9</span></code></pre></div>
<p>There’s also a companion function, <a href="purelib.html#globsym"><code>globsym</code></a>, which enables you to get a list of defined symbols which match a given glob pattern:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; globsym <span class="st">&quot;fact&quot;</span> <span class="dv">0</span>;
[fact]
&gt; globsym <span class="st">&quot;*&quot;</span> <span class="dv">0</span>;
[(!),(!!),(#),($),($$),...]
&gt; #globsym <span class="st">&quot;*&quot;</span> <span class="dv">0</span>;
<span class="dv">304</span></code></pre></div>
<p>Note that <a href="purelib.html#globsym"><code>globsym</code></a> also returns symbols defined as types, macros, variables or constants. But we can easily check for a given type of symbol by using the appropriate function to retrieve the rules defining the symbol, and filter out symbols with an empty rule list:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #[sym | sym = globsym <span class="st">&quot;*&quot;</span> <span class="dv">0</span>; ~null (get_fundef sym)];
<span class="dv">253</span></code></pre></div>
<p>Pure also provides the operations <a href="purelib.html#get_typedef"><code>get_typedef</code></a>, <a href="purelib.html#get_macdef"><code>get_macdef</code></a>, <a href="purelib.html#get_vardef"><code>get_vardef</code></a> and <a href="purelib.html#get_constdef"><code>get_constdef</code></a>, which are completely analogous to <a href="purelib.html#get_fundef"><code>get_fundef</code></a>, but return the definitions of types, macros, (global) variables and constants. Note that in the latter two cases the rule list takes the form <code>[var--&gt;val]</code> if the symbol is defined, <code>[]</code> if it isn’t.</p>
<p>For instance, let’s check the definition of the <a href="purelib.html#$"><code>$</code></a> macro (cf. <a href="#optimization-rules">Optimization Rules</a>) and the <a href="purelib.html#list/type"><code>list</code></a> type (cf. <a href="#recursive-types">Recursive Types</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; get_macdef ($);
[f$x--&gt;f x]
&gt; get_typedef list;
[(list []--&gt;<span class="dv">1</span>),(list (_:_)--&gt;<span class="dv">1</span>)]</code></pre></div>
<p>Or let’s lists all global variables along with their values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; catmap get_vardef (globsym <span class="st">&quot;*&quot;</span> <span class="dv">0</span>);
[(argc--&gt;<span class="dv">0</span>),(argv--&gt;[]),(compiling--&gt;<span class="dv">0</span>),
(sysinfo--&gt;<span class="st">&quot;x86_64-unknown-linux-gnu&quot;</span>),(version--&gt;<span class="st">&quot;0.66&quot;</span>)]</code></pre></div>
<p>The counterparts of <a href="purelib.html#add_fundef"><code>add_fundef</code></a> and <a href="purelib.html#del_fundef"><code>del_fundef</code></a> are provided as well. Not very surprisingly, they are named <a href="purelib.html#add_typedef"><code>add_typedef</code></a>, <a href="purelib.html#del_typedef"><code>del_typedef</code></a>, etc. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; add_vardef [&#39;x--&gt;<span class="dv">3</span>*<span class="dv">33</span>];
()
&gt; show x
<span class="kw">let</span> x = <span class="dv">99</span>;
&gt; del_vardef (&#39;x);
()
&gt; show x</code></pre></div>
<p>The above facilities should cover most metaprogramming needs. For even more exotic requirements, you can also use the <a href="purelib.html#eval"><code>eval</code></a> and <a href="purelib.html#evalcmd"><code>evalcmd</code></a> primitives to execute arbitrary Pure code in text form; please see the <a href="purelib.html">Pure Library Manual</a> for details.</p>
<p>Finally, a word of caution: The use of <a href="purelib.html#add_fundef"><code>add_fundef</code></a>, <a href="purelib.html#del_fundef"><code>del_fundef</code></a> and similar operations to modify a running program breaks referential transparency and hence these functions should be used with care. Moreover, at present the JIT compiler doesn’t support truly self-modifying code (i.e., functions modifying themselves while they’re executing); this results in undefined behaviour. Also, note that none of the inspection and mutation capabilities provided by these operations will work in batch-compiled programs, please check the <a href="#batch-compilation">Batch Compilation</a> section for details.</p>
<p><a name="exception-handling"></a></p>
<h2 id="exception-handling">Exception Handling</h2>
<p>Pure also offers a useful exception handling facility. To raise an exception, you just invoke the built-in function <a href="purelib.html#throw"><code>throw</code></a> with the value to be thrown as the argument. Exceptions are caught with the built-in special form <a href="#catch"><code>catch</code></a> which is invoked as follows:</p>
<dl>
<dt><a name="catch"></a><code>catch handler x</code></dt>
<dd>Catch an exception. The first argument denotes the exception handler (a function to be applied to the exception value). The second (call-by-name) argument is the expression to be evaluated.
</dd>
</dl>
<!-- -->
<p>For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="fu">catch</span> error (<span class="fu">throw</span> hello_world);
error hello_world</code></pre></div>
<p>Exceptions are also generated by the runtime system if the program runs out of stack space, when a guard does not evaluate to a truth value, and when the subject term fails to match the pattern in a pattern-matching lambda abstraction, or a <a href="#let"><code>let</code></a>, <a href="#case"><code>case</code></a> or <a href="#when"><code>when</code></a> construct. These types of exceptions are reported using the symbols <a href="purelib.html#stack_fault"><code>stack_fault</code></a>, <a href="purelib.html#failed_cond"><code>failed_cond</code></a> and <a href="purelib.html#failed_match"><code>failed_match</code></a>, respectively, which are declared as nonfix symbols in the standard prelude. You can use <a href="#catch"><code>catch</code></a> to handle these kinds of exceptions just like any other. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact(n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
&gt; <span class="fu">catch</span> error (fact foo);
error failed_cond
&gt; <span class="fu">catch</span> error (fact <span class="dv">1000000</span>);
error stack_fault</code></pre></div>
<p>Unhandled exceptions are reported by the interpreter with a corresponding error message:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact foo;
&lt;stdin&gt;, line <span class="dv">2</span>: unhandled exception &#39;failed_cond&#39; while evaluating &#39;fact foo&#39;</code></pre></div>
<p>Note that since the right-hand side of a type definition (cf. <a href="#type-rules">Type Rules</a>) is just ordinary Pure code, it may be susceptible to exceptions, too. Such exceptions are reported or caught just like any other. In particular, if you want to make a type definition just fail silently in case of an exception, you’ll have to wrap it up in a suitable <a href="#catch"><code>catch</code></a> clause:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = <span class="fu">throw</span> foo; <span class="co">// dummy predicate which always throws an exception</span>
&gt; <span class="kw">type</span> bar x = foo x;
&gt; <span class="kw">type</span> baz x = <span class="fu">catch</span> (cst false) (foo x);
&gt; test_bar x::bar = x;
&gt; test_baz x::baz = x;
&gt; test_bar ();
&lt;stdin&gt;, line <span class="dv">6</span>: unhandled exception &#39;foo&#39; while evaluating &#39;test_bar ()&#39;
&gt; test_baz ();
test_baz ()</code></pre></div>
<p>Exceptions also provide a way to handle asynchronous signals. Pure’s system module provides symbolic constants for common POSIX signals and also defines the operation <a href="purelib.html#trap"><code>trap</code></a> which lets you rebind any signal to a signal exception. For instance, the following lets you handle the <code>SIGQUIT</code> signal:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; trap SIG_TRAP SIGQUIT;</code></pre></div>
<p>You can also use <a href="purelib.html#trap"><code>trap</code></a> to just ignore a signal or revert to the system’s default handler (which might take different actions depending on the type of signal, see signal(7) for details):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; trap SIG_IGN SIGQUIT; <span class="co">// signal is ignored</span>
&gt; trap SIG_DFL SIGQUIT; <span class="co">// reinstalls the default signal handler</span></code></pre></div>
<p>Note that when the interpreter runs interactively, for convenience most standard termination signals (<code>SIGINT</code>, <code>SIGTERM</code>, etc.) are already set up to produce corresponding Pure exceptions of the form <code>signal SIG</code> where <code>SIG</code> is the signal number. If a script is to be run non-interactively then you’ll have to do this yourself (otherwise most signals will terminate the program).</p>
<p>While exceptions are normally used to report abnormal error conditions, they also provide a way to implement non-local value returns. For instance, here’s a variation of our n queens algorithm (cf. <a href="#list-comprehensions">List Comprehensions</a>) which only returns the first solution. Note the use of <a href="purelib.html#throw"><code>throw</code></a> in the recursive search routine to bail out with a solution as soon as we found one. The value thrown there is caught in the main routine. Also note the use of <a href="purelib.html#void"><code>void</code></a> in the second equation of <code>search</code>. This effectively turns the list comprehension into a simple loop which suppresses the normal list result and just returns <code>()</code> instead. Thus, if no value gets thrown then the function regularly returns with <code>()</code> to indicate that there is no solution.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">queens n       = <span class="fu">catch</span> reverse (search n <span class="dv">1</span> []) <span class="kw">with</span>
  search n i p = <span class="fu">throw</span> p <span class="kw">if</span> i&gt;n;
               = <span class="dt">void</span> [search n (i+<span class="dv">1</span>) ((i,j):p) | j = <span class="dv">1</span>..n; safe (i,j) p];
  safe (i,j) p = ~any (check (i,j)) p;
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2;
<span class="kw">end</span>;</code></pre></div>
<p>E.g., let’s compute a solution for a standard 8x8 board:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; queens <span class="dv">8</span>;
[(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">5</span>),(<span class="dv">3</span>,<span class="dv">8</span>),(<span class="dv">4</span>,<span class="dv">6</span>),(<span class="dv">5</span>,<span class="dv">3</span>),(<span class="dv">6</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">2</span>),(<span class="dv">8</span>,<span class="dv">4</span>)]</code></pre></div>
<h2 id="standard-library">Standard Library</h2>
<p>Pure comes with a collection of Pure library modules, which includes the standard prelude (loaded automatically at startup time) and some other modules which can be loaded explicitly with a <a href="#using"><code>using</code></a> clause. The prelude offers the necessary functions to work with the built-in types (including arithmetic and logical operations) and to do most kind of list processing you can find in ML- and Haskell-like languages. It also provides a collection of basic string and matrix operations. Please refer to the <a href="purelib.html">Pure Library Manual</a> for details on the provided operations. Here is a very brief summary of some of the prelude operations which, besides the usual arithmetic and logical operators, are probably used most frequently:</p>
<dl>
<dt><code>x+y</code></dt>
<dd>The arithmetic <code>+</code> operation is also used to denote list and string concatenation in Pure.
</dd>
<dt><code>x:y</code></dt>
<dd>This is the list-consing operation. <code>x</code> becomes the head of the list, <code>y</code> its tail. As ‘<a href="purelib.html#:"><code>:</code></a>’ is a constructor symbol, you can use it in patterns on the left hand side of rewriting rules.
</dd>
<dt><code>x..y</code></dt>
<dd>Constructs arithmetic sequences. <code>x:y..z</code> can be used to denote sequences with arbitrary stepsize <code>y-x</code>. Infinite sequences can be constructed using an infinite bound (i.e., <code>inf</code> or <code>-inf</code>). E.g., <code>1:3..inf</code> denotes the stream of all odd integers starting at 1.
</dd>
<dt><code>x,y</code></dt>
<dd>This is the pair constructor, used to create tuples of arbitrary sizes. Tuples provide an alternative way to represent aggregate values in Pure. In contrast to lists, tuples are always “flat”, so that <code>(x,y),z</code> and <code>x,(y,z)</code> denote the same triple <code>x,y,z</code>. (This is explained in more detail in the <a href="#primary-expressions">Primary Expressions</a> section.)
</dd>
<dt><code>#x</code></dt>
<dd>The size (number of elements) of the list, tuple, matrix or string <code>x</code>. In addition, <code>dim x</code> yields the dimensions (number of rows and columns) of a matrix.
</dd>
<dt><code>x!y</code></dt>
<dd>This is Pure’s indexing operation, which applies to lists, tuples, matrices and strings. Note that all indices in Pure are zero-based, thus <code>x!0</code> and <code>x!(#x-1)</code> are the first and last element of <code>x</code>. In the case of matrices, the subscript may also be a pair of row and column indices, such as <code>x!(1,2)</code>.
</dd>
<dt><code>x!!ys</code></dt>
<dd>This is the “slicing” operation, which returns the list, tuple, matrix or string of all <code>x!y</code> while <code>y</code> runs through the elements of the list or matrix <code>ys</code>. Thus, e.g., <code>x!!(i..j)</code> returns all the elements between <code>i</code> and <code>j</code> (inclusive). Indices which fall outside the valid index range are quietly discarded. The index range <code>ys</code> may contain any number of indices (also duplicates), in any order. Thus <code>x!![0|i=1..n]</code> returns the first element of <code>x</code> <code>n</code> times, and, if <code>ys</code> is a permutation of the range <code>0..#x-1</code>, then <code>x!!ys</code> yields the corresponding permutation of the elements of <code>x</code>. In the case of matrices the index range may also contain two-dimensional subscripts, or the index range itself may be specified as a pair of row/column index lists such as <code>x!!(i..j,k..l)</code>.
</dd>
</dl>
<!-- -->
<p>The prelude also offers support operations for the implementation of list and matrix comprehensions, as well as the customary list operations like <a href="purelib.html#head"><code>head</code></a>, <a href="purelib.html#tail"><code>tail</code></a>, <a href="purelib.html#drop"><code>drop</code></a>, <a href="purelib.html#take"><code>take</code></a>, <a href="purelib.html#filter"><code>filter</code></a>, <a href="purelib.html#map"><code>map</code></a>, <a href="purelib.html#foldl"><code>foldl</code></a>, <a href="purelib.html#foldr"><code>foldr</code></a>, <a href="purelib.html#scanl"><code>scanl</code></a>, <a href="purelib.html#scanr"><code>scanr</code></a>, <a href="purelib.html#zip"><code>zip</code></a>, <a href="purelib.html#unzip"><code>unzip</code></a>, etc., which make list programming so much fun in modern FPLs. In Pure, these also work on strings as well as matrices, although, for reasons of efficiency, these data structures are internally represented as arrays.</p>
<p>Besides the prelude, Pure’s standard library also comprises a growing number of additional library modules which we can only mention in passing here. In particular, the <a href="purelib.html#module-math">math</a> module provides additional mathematical functions as well as Pure’s complex and rational number data types. Common container data structures like sets and dictionaries are implemented in the <a href="purelib.html#module-set">set</a> and <a href="purelib.html#module-dict">dict</a> modules, among others. Moreover, the system interface can be found in the <a href="purelib.html#module-system">system</a> module. In particular, this module also provides operations to do basic C-style I/O, including <a href="purelib.html#printf"><code>printf</code></a> and <a href="purelib.html#scanf"><code>scanf</code></a>.</p>
<h2 id="c-interface">C Interface</h2>
<p>Pure makes it very easy to call C functions (as well as functions in a number of other languages supported by the GNU compiler collection). To call an existing C function, you just need an <a href="#extern"><code>extern</code></a> declaration of the function, as described below. By these means, all functions in the standard C library and the Pure runtime are readily available to Pure scripts. Functions can also be loaded from dynamic libraries and LLVM bitcode files at runtime. In the latter case, you don’t even need to write any <a href="#extern"><code>extern</code></a> declarations, the interpreter will do that for you. As of Pure 0.45, you can also add inline C/C++ and Fortran code to your Pure scripts and have the Pure interpreter compile them on the fly, provided that you have the corresponding compilers from the LLVM project installed.</p>
<p>In some cases you will still have to rely on big and complicated third-party and system libraries which aren’t readily available in bitcode form. It goes without saying that writing all the <a href="#extern"><code>extern</code></a> declarations for such libraries can be a daunting task. Fortunately, there is a utility to help with this, by extracting the <a href="#extern"><code>extern</code></a> declarations automatically from C headers. Please see <a href="#external-c-functions">External C Functions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for details.</p>
<p><a name="extern"></a></p>
<h3 id="extern-declarations">Extern Declarations</h3>
<p>To access an existing C function in Pure, you need an <a href="#extern"><code>extern</code></a> declaration of the function, which is a simplified kind of C prototype. The syntax of these declarations is described by the following grammar rules:</p>
<pre class="sourceCode bnf"><code>extern_decl : [scope] &quot;extern&quot; prototype (&quot;,&quot; prototype) &quot;;&quot;
prototype : c_type identifier &quot;(&quot; [parameters | &quot;...&quot;] &quot;)&quot; [&quot;=&quot; identifier]
parameters : parameter (&quot;,&quot; parameter)* [&quot;,&quot; &quot;...&quot;]
parameter : c_type [identifier]
c_type : identifier &quot;*&quot;*</code></pre>
<p>Extern functions can be called in Pure just like any other. For instance, the following commands, entered interactively in the interpreter, let you use the <code>sin</code> function from the C library (of course you could just as well put the <a href="#extern"><code>extern</code></a> declaration into a script):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>);
&gt; sin <span class="dv">0.3</span>;
<span class="dv">0.29552020666134</span></code></pre></div>
<p>An <a href="#extern"><code>extern</code></a> declaration can also be prefixed with a <a href="#public"><code>public</code></a>/<a href="#private"><code>private</code></a> scope specifier:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">private</span> <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>);</code></pre></div>
<p>Multiple prototypes can be given in one <a href="#extern"><code>extern</code></a> declaration, separating them with commas:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>), <span class="dt">double</span> cos(<span class="dt">double</span>), <span class="dt">double</span> tan(<span class="dt">double</span>);</code></pre></div>
<p>For clarity, the parameter types can also be annotated with parameter names (these only serve informational purposes and are for the human reader; they are effectively treated as comments by the compiler):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span> x);</code></pre></div>
<p>Pointer types are indicated by following the name of the element type with one or more asterisks, as in C. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">char</span>* strchr(<span class="dt">char</span> *s, <span class="dt">int</span> c);
&gt; strchr <span class="st">&quot;foo bar&quot;</span> (ord <span class="st">&quot;b&quot;</span>);
<span class="st">&quot;bar&quot;</span></code></pre></div>
<p>As you can see in the previous example, some pointer types get special treatment, allowing you to pass certain kinds of Pure data (such as Pure strings as <code>char*</code> in this example). This is discussed in more detail in <a href="#c-types">C Types</a> below.</p>
<p>The interpreter makes sure that the parameters in a call match; if not, then by default the call is treated as a normal form expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>);
&gt; sin <span class="dv">0.3</span>;
<span class="dv">0.29552020666134</span>
&gt; sin <span class="dv">0</span>;
sin <span class="dv">0</span></code></pre></div>
<p>This gives you the opportunity to augment the external function with your own Pure equations. To make this work, you have to make sure that the <a href="#extern"><code>extern</code></a> declaration of the function comes first. For instance, we might want to extend the <code>sin</code> function with a rule to handle integers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sin x::<span class="dt">int</span> = sin (<span class="dt">double</span> x);
&gt; sin <span class="dv">0</span>;
<span class="dv">0.0</span></code></pre></div>
<p>Sometimes it is preferable to replace a C function with a wrapper function written in Pure. In such a case you can specify an <strong>alias</strong> under which the original C function is known to the Pure program, so that you can still call the C function from the wrapper. An alias is introduced by terminating the extern declaration with a clause of the form <code>= alias</code>. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>) = c_sin;
&gt; sin x::<span class="dt">double</span> = c_sin x;
&gt; sin x::<span class="dt">int</span> = c_sin (<span class="dt">double</span> x);
&gt; sin <span class="dv">0.3</span>; sin <span class="dv">0</span>;
<span class="dv">0.29552020666134</span>
<span class="dv">0.0</span></code></pre></div>
<p>Aliases are just one way to declare a <strong>synonym</strong> of an external function. As an alternative, you can also declare the C function in a special namespace (cf. <a href="#namespaces">Namespaces</a> in the <a href="#declarations">Declarations</a> section):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> c;
&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>);
&gt; c::sin <span class="dv">0.3</span>;
<span class="dv">0.29552020666134</span></code></pre></div>
<p>Note that the namespace qualification only affects the Pure side; the underlying C function is still called under the unqualified name as usual. The way in which such qualified externs are accessed is the same as for ordinary qualified symbols. In particular, the <a href="#using%20namespace"><code>using namespace</code></a> declaration applies as usual, and you can declare such symbols as <a href="#private"><code>private</code></a> if needed. It is also possible to combine a namespace qualifier with an alias:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> c;
&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>) = mysin;
&gt; c::mysin <span class="dv">0.3</span>;
<span class="dv">0.29552020666134</span></code></pre></div>
<p>In either case, different synonyms of the same external function can be declared in slightly different ways, which makes it possible to adjust the interpretation of pointer values on the Pure side. This is particularly useful for string arguments which, as described below, may be passed both as <code>char*</code> (which implies copying and conversion to or from the system encoding) and as <code>void*</code> (which simply passes through the character pointers). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">char</span> *strchr(<span class="dt">char</span> *s, <span class="dt">int</span> c) = foo;
&gt; <span class="kw">extern</span> <span class="dt">void</span> *strchr(<span class="dt">void</span> *s, <span class="dt">int</span> c) = bar;
&gt; foo <span class="st">&quot;foo bar&quot;</span> <span class="dv">98</span>; bar <span class="st">&quot;foo bar&quot;</span> <span class="dv">98</span>;
<span class="st">&quot;bar&quot;</span>
#&lt;<span class="dt">pointer</span> <span class="dv">0x12c2f24</span>&gt;</code></pre></div>
<p>Also note that, as far as Pure is concerned, different synonyms of an external function are really different functions. In particular, they can each have their own set of augmenting Pure equations. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>);
&gt; <span class="kw">extern</span> <span class="dt">double</span> sin(<span class="dt">double</span>) = mysin;
&gt; sin === sin;
<span class="dv">1</span>
&gt; sin === mysin;
<span class="dv">0</span>
&gt; sin <span class="dv">1.0</span>; mysin <span class="dv">1.0</span>;
<span class="dv">0.841470984807897</span>
<span class="dv">0.841470984807897</span>
&gt; sin x::<span class="dt">int</span> = sin (<span class="dt">double</span> x);
&gt; sin <span class="dv">1</span>; mysin <span class="dv">1</span>;
<span class="dv">0.841470984807897</span>
mysin <span class="dv">1</span></code></pre></div>
<h3 id="variadic-c-functions">Variadic C Functions</h3>
<p>Variadic C functions are declared as usual by terminating the parameter list with an ellipsis (<code>...</code>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">int</span> printf(<span class="dt">char</span>*, ...);
&gt; printf <span class="st">&quot;Hello, world</span><span class="ch">\n</span><span class="st">&quot;</span>;
Hello, world
<span class="dv">13</span></code></pre></div>
<p>Note that the variadic prototype is mandatory here, since the compiler needs to know about the optional arguments so that it can generate the proper code to call the function. However, in Pure a function always has a fixed arity, so, as far as Pure is concerned, the function is still treated as if it had no extra arguments. Thus the above declaration only allows you to call <code>printf</code> with a single argument.</p>
<p>To make it possible to pass optional arguments to a variadic function, you must explicitly give the (non-variadic) prototypes with which the function is to be called. To these ends, the additional prototypes are declared as synonyms of the original variadic function. This works because the compiler only checks the non-variadic parameters for conformance. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">int</span> printf(<span class="dt">char</span>*, <span class="dt">char</span>*) = printf_s;
&gt; printf_s <span class="st">&quot;Hello, %s</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="st">&quot;world&quot;</span>;
Hello, world
<span class="dv">13</span>
&gt; <span class="kw">extern</span> <span class="dt">int</span> printf(<span class="dt">char</span>*, <span class="dt">int</span>) = printf_d;
&gt; printf_d <span class="st">&quot;Hello, %d</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="dv">99</span>;
Hello, <span class="dv">99</span>
<span class="dv">10</span></code></pre></div>
<p><a name="c-types"></a></p>
<h3 id="c-types">C Types</h3>
<p>As indicated in the previous section, the data types in <a href="#extern"><code>extern</code></a> declarations are either C type names or pointer types derived from these. The special <code>expr*</code> pointer type is simply passed through; this provides a means to deal with Pure data in C functions in a direct fashion. For all other C types, Pure values are “marshalled” (converted) from Pure to C when passed as arguments to C functions, and the result returned by the C function is then converted back from C to Pure. All of this is handled by the runtime system in a transparent way, of course.</p>
<p>Note that, to keep things simple, Pure does <em>not</em> provide any notations for C structs or function types, although it is possible to represent pointers to such objects using <code>void*</code> or some other appropriate pointer types. In practice, this simplified system should cover most kinds of calls that need to be done when interfacing to C libraries, but there are ways to work around these limitations if you need to access C structs or call back from C to Pure, see <a href="#external-c-functions">External C Functions</a> in the <a href="#caveats-and-notes">Caveats and Notes</a> section for details.</p>
<h4 id="basic-c-types">Basic C Types</h4>
<p>Pure supports the usual range of basic C types: <code>void</code>, <code>bool</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, and converts between these and the corresponding Pure data types (machine ints, bigints and double values) in a straightforward way.</p>
<p>The <code>void</code> type is only allowed in function results. It is converted to the empty tuple <code>()</code>.</p>
<p>Both <code>float</code> and <code>double</code> are supported as floating point types. Single precision <code>float</code> arguments and return values are converted from/to Pure’s double precision floating point numbers.</p>
<p>A variety of C integer types (<code>bool</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>) are provided which are converted from/to the available Pure integer types in a straightforward way. In addition, the synonyms <code>int8</code>, <code>int16</code> and <code>int32</code> are provided for <code>char</code>, <code>short</code> and <code>int</code>, respectively, and <code>int64</code> denotes 64 bit integers (a.k.a. ISO C99 <code>long long</code>). Note that <code>long</code> is equivalent to <code>int32</code> on 32 bit systems, whereas it is the same as <code>int64</code> on most 64 bit systems. To make it easier to interface to various system routines, there’s also a special <code>size_t</code> integer type which usually is 4 bytes on 32 bit and 8 bytes on 64 bit systems.</p>
<p>All integer parameters take both Pure ints and bigints as actual arguments; truncation or sign extension is performed as needed, so that the C interface behaves as if the argument was “cast” to the C target type. Returned integers use the smallest Pure type capable of holding the result, i.e., int for the C <code>char</code>, <code>short</code> and <code>int</code> types, bigint for <code>int64</code>.</p>
<p>Pure considers all integers as signed quantities, but it is possible to pass unsigned integers as well (if necessary, you can use a bigint to pass positive values which are too big to fit into a machine int). Also note that when an unsigned integer is returned by a C routine, which is too big to fit into the corresponding signed integer type, it will “wrap around” and become negative. In this case, depending on the target type, you can use the <a href="purelib.html#ubyte"><code>ubyte</code></a>, <a href="purelib.html#ushort"><code>ushort</code></a>, <a href="purelib.html#uint"><code>uint</code></a>, <a href="purelib.html#ulong"><code>ulong</code></a> and <a href="purelib.html#uint64"><code>uint64</code></a> functions provided by the prelude to convert the result back to an unsigned quantity.</p>
<h4 id="pointer-types">Pointer Types</h4>
<p>The use of pointer types is also fairly straightforward, but Pure has some special rules for the conversion of certain pointer types which make it easy to pass aggregate Pure data to and from C routines, while also following the most common idioms for pointer usage in C. The following types of pointers are recognized both as arguments and return values of C functions.</p>
<p>Bidirectional pointer conversions:</p>
<ul>
<li><code>char*</code> is used for string arguments and return values which are converted from Pure’s internal utf-8 based string representation to the system encoding and vice versa. (Thus a C routine can never modify the raw Pure string data in-place; if this is required then you’ll have to pass the string argument as a <code>void*</code>, see below.)</li>
<li><code>void*</code> is for any generic pointer value, which is simply passed through unchanged. When used as an argument, you can also pass Pure strings, matrices and bigints. In this case the raw underlying data pointer (<code>char*</code> in the case of strings, <code>int*</code>, <code>double*</code> or <code>expr*</code> in the case of numeric and symbolic matrices, and the GMP type <code>mpz_t</code> in the case of bigints) is passed, which allows the data to be modified in place (with care). In particular, passing bigints as <code>void*</code> makes it possible to call most GMP integer routines directly from Pure.</li>
<li><code>dmatrix*</code>, <code>cmatrix*</code> and <code>imatrix*</code> allow you to pass numeric Pure matrices of the appropriate types (double, complex, int). Here a pointer to the underlying GSL matrix structure is passed (not just the data itself). This makes it possible to transfer GSL matrices between Pure and GSL routines in a direct fashion without any overhead. (For convenience, there are also some other pointer conversions for marshalling matrix arguments to numeric C vectors, which are described in <a href="#pointers-and-matrices">Pointers and Matrices</a> below.)</li>
<li><code>expr*</code> is for any kind of Pure value. A pointer to the expression node is passed to or from the C function. This type is to be used for C routines which are prepared to deal with pristine Pure data, using the corresponding functions provided by the runtime. You can find many examples of this in the standard library.</li>
</ul>
<p>All other pointer types are simply taken at face value, allowing you to pass Pure pointer values as is, without any conversions. This also includes pointers to arbitrary named types which don’t have a predefined meaning in Pure, such as <code>FILE*</code>. As of Pure 0.45, the interpreter keeps track of the actual names of all pointer types and checks (at runtime) that the types match in an external call, so that you can’t accidentally get a core dump by passing, say, a <code>FILE*</code> for a <code>char*</code>. (The call will then simply fail and yield a normal form, which gives you the opportunity to hook into the function with your own Pure definitions which may supply any desired data conversions.) Typing information about pointer values is also available to Pure scripts by means of corresponding library functions, please see the <a href="purelib.html#tagged-pointers">Tagged Pointers</a> section in the <a href="purelib.html">Pure Library Manual</a> for details.</p>
<h4 id="pointers-and-matrices">Pointers and Matrices</h4>
<p>The following additional pointer conversions are provided to deal with Pure matrix values in arguments of C functions, i.e., on the input side. These enable you to pass Pure matrices for certain kinds of C vectors. Note that in any case, you can also simply pass a suitable plain pointer value instead. Also, these types aren’t special in return values, where they will simply yield a pointer value (with the exception of <code>char*</code> which gets special treatment as explained in the previous subsection). Thus you will have to decode such results manually if needed. The standard library provides various routines to do this, please see the <a href="purelib.html#string-functions">String Functions</a> and <a href="purelib.html#matrix-functions">Matrix Functions</a> sections in the <a href="purelib.html">Pure Library Manual</a> for details.</p>
<p>Numeric pointer conversions (input only):</p>
<ul>
<li><code>char*</code>, <code>short*</code>, <code>int*</code>, <code>int64*</code>, <code>float*</code>, <code>double*</code> can be used to pass numeric matrices as C vectors. This kind of conversion passes just the matrix data (not the GSL matrix structure, as the <code>dmatrix*</code> et al conversions do) and does conversions between integer or floating point data of different sizes on the fly. You can either pass an int matrix as a <code>char*</code>, <code>short*</code> <code>int*</code> or <code>int64*</code> argument, or a double or complex matrix as a <code>float*</code> or <code>double*</code> argument (complex values are then represented as two separate double numbers, first the real, then the imaginary part, for each matrix element).</li>
<li><code>char**</code>, <code>short**</code>, <code>int**</code>, <code>int64**</code>, <code>float**</code>, <code>double**</code> provide yet another way to pass numeric matrix arguments. This works analogously to the numeric vector conversions above, but here a temporary C vector of pointers is passed to the C function, whose elements point to the rows of the matrix.</li>
</ul>
<p>Argv-style conversions (input only):</p>
<ul>
<li><code>char**</code> and <code>void**</code> can be used to pass <code>argv</code>-style vectors as arguments to C functions. In this case, the Pure argument must be a symbolic vector of strings or generic pointer values. <code>char**</code> converts the string elements to the system encoding, whereas <code>void**</code> passes through character string data and other pointers unchanged (and allows in-place modification of the data). A temporary C vector of these elements is passed to the C function, which is always <a href="purelib.html#NULL"><code>NULL</code></a>-terminated and can thus be used for almost any purpose which requires such <code>argv</code>-style vectors.</li>
</ul>
<p>Note that in the numeric pointer conversions, the matrix data is passed “per reference” to C routines, i.e., the C function may modify the data “in place”. This is true even for target data types such as <code>short*</code> or <code>float**</code> which involve automatic conversions and hence need temporary storage. In this case the data from the temporary storage is written back to the original matrix when the function returns, to maintain the illusion of in-place modification. Temporary storage is also needed when the GSL matrix has the data in non-contiguous storage. You may want to avoid this if performance is critical, by always using “packed” matrices (see <a href="purelib.html#pack"><code>pack</code></a> in <a href="purelib.html#matrix-functions">Matrix Functions</a>) of the appropriate types.</p>
<h4 id="pointer-examples">Pointer Examples</h4>
<p>Let’s finally have a look at some instructive examples to explain some of the trickier pointer types.</p>
<p>First, the matrix pointer types <code>dmatrix*</code>, <code>cmatrix*</code> and <code>imatrix*</code> can be used to pass double, complex double and int matrices to GSL functions taking pointers to the corresponding GSL types (<code>gsl_matrix</code>, <code>gsl_matrix_complex</code> and <code>gsl_matrix_int</code>) as arguments or returning them as results. (Note that there is no special marshalling of Pure’s symbolic matrix type, as these aren’t supported by GSL anyway.) Also note that matrices are always passed by reference. Thus, if you need to pass a matrix as an output parameter of a GSL matrix routine, you should either create a zero matrix or a copy of an existing matrix to hold the result. The prelude provides various operations for that purpose (in particular, see the <a href="purelib.html#dmatrix"><code>dmatrix</code></a>, <a href="purelib.html#cmatrix"><code>cmatrix</code></a>, <a href="purelib.html#imatrix"><code>imatrix</code></a> and <a href="purelib.html#pack"><code>pack</code></a> functions in matrices.pure). For instance, here is how you can quickly wrap up GSL’s double matrix addition function in a way that preserves value semantics:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="st">&quot;lib:gsl&quot;</span>;
&gt; <span class="kw">extern</span> <span class="dt">int</span> gsl_matrix_add(<span class="dt">dmatrix</span>*, <span class="dt">dmatrix</span>*);
&gt; x::<span class="dt">matrix</span> + y::<span class="dt">matrix</span> = gsl_matrix_add x y $$ x <span class="kw">when</span> x = pack x <span class="kw">end</span>;
&gt; <span class="kw">let</span> x = <span class="dt">dmatrix</span> {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>}; <span class="kw">let</span> y = <span class="dt">dmatrix</span> {<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>}; x; y; x+y;
{<span class="dv">1.0</span>,<span class="dv">2.0</span>,<span class="dv">3.0</span>}
{<span class="dv">2.0</span>,<span class="dv">3.0</span>,<span class="dv">2.0</span>}
{<span class="dv">3.0</span>,<span class="dv">5.0</span>,<span class="dv">5.0</span>}</code></pre></div>
<p>Most GSL matrix routines can be wrapped in this fashion quite easily. A ready-made GSL interface providing access to all of GSL’s numeric functions is in the works; please check the Pure website for details.</p>
<p>For convenience, it is also possible to pass any kind of numeric matrix for a <code>char*</code>, <code>short*</code>, <code>int*</code>, <code>int64*</code>, <code>float*</code> or <code>double*</code> parameter. This requires that the pointer and the matrix type match up; conversions between <code>char</code>, <code>short</code>, <code>int64</code> and <code>int</code> data and, likewise, between <code>float</code> and <code>double</code> are handled automatically, however. For instance, here is how you can call the <code>puts</code> routine from the C library with an int matrix encoding the string <code>&quot;Hello, world!&quot;</code> as byte values (ASCII codes):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">int</span> puts(<span class="dt">char</span>*);
&gt; puts {<span class="dv">72</span>,<span class="dv">101</span>,<span class="dv">108</span>,<span class="dv">108</span>,<span class="dv">111</span>,<span class="dv">44</span>,<span class="dv">32</span>,<span class="dv">119</span>,<span class="dv">111</span>,<span class="dv">114</span>,<span class="dv">108</span>,<span class="dv">100</span>,<span class="dv">33</span>,<span class="dv">0</span>};
Hello, world!
<span class="dv">14</span></code></pre></div>
<p>Pure 0.45 and later also support <code>char**</code>, <code>short**</code>, <code>int**</code>, <code>int64**</code>, <code>float**</code> and <code>double**</code> parameters which encode a matrix as a vector of row pointers instead. This kind of matrix representation is often found in audio and video processing software (where the rows of the matrix might denote different audio channels, display lines or video frames), but it’s also fairly convenient to do any kind of matrix processing in C. For instance, here’s how to do matrix multiplication (the naive algorithm):</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> matmult(<span class="dt">int</span> n, <span class="dt">int</span> l, <span class="dt">int</span> m, <span class="dt">double</span> **x, <span class="dt">double</span> **y, <span class="dt">double</span> **z)
{
  <span class="dt">int</span> i, j, k;
  <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; n; i++)
    <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; m; j++) {
      z[i][j] = <span class="fl">0.0</span>;
      <span class="cf">for</span> (k = <span class="dv">0</span>; k &lt; l; k++)
        z[i][j] += x[i][k]*y[k][j];
    }
}</code></pre></div>
<p>As you can see, this multiplies a <code>n</code> times <code>l</code> matrix <code>x</code> with a <code>l</code> times <code>m</code> matrix <code>y</code> and puts the result into the <code>n</code> times <code>m</code> matrix <code>z</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">void</span> matmult(<span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">double</span>**, <span class="dt">double</span>**, <span class="dt">double</span>**);
&gt; <span class="kw">let</span> x = {<span class="dv">0.11</span>,<span class="dv">0.12</span>,<span class="dv">0.13</span>;<span class="dv">0.21</span>,<span class="dv">0.22</span>,<span class="dv">0.23</span>};
&gt; <span class="kw">let</span> y = {<span class="dv">1011.0</span>,<span class="dv">1012.0</span>;<span class="dv">1021.0</span>,<span class="dv">1022.0</span>;<span class="dv">1031.0</span>,<span class="dv">1032.0</span>};
&gt; <span class="kw">let</span> z = <span class="dt">dmatrix</span> (<span class="dv">2</span>,<span class="dv">2</span>);
&gt; matmult <span class="dv">2</span> <span class="dv">3</span> <span class="dv">2</span> x y z $$ z;
{<span class="dv">367.76</span>,<span class="dv">368.12</span>;<span class="dv">674.06</span>,<span class="dv">674.72</span>}</code></pre></div>
<p>Also new in Pure 0.45 is the support for passing <code>argv</code>-style vectors as arguments. For instance, here is how you can use <code>fork</code> and <code>execvp</code> to implement a poor man’s version of the C <code>system</code> function. (This is Unix-specific and doesn’t do much error-checking, but you get the idea.)</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">extern</span> <span class="dt">int</span> fork();
<span class="kw">extern</span> <span class="dt">int</span> execvp(<span class="dt">char</span> *path, <span class="dt">char</span> **argv);
<span class="kw">extern</span> <span class="dt">int</span> waitpid(<span class="dt">int</span> pid, <span class="dt">int</span> *status, <span class="dt">int</span> options);

system cmd::<span class="dt">string</span> = <span class="kw">case</span> fork <span class="kw">of</span>
  <span class="co">// child: execute the program, bail out if error</span>
  <span class="dv">0</span> = execvp <span class="st">&quot;/bin/sh&quot;</span> {<span class="st">&quot;/bin/sh&quot;</span>,<span class="st">&quot;-c&quot;</span>,cmd} $$ exit <span class="dv">1</span>;
  <span class="co">// parent: wait for the child and return its exit code</span>
  pid = waitpid pid status <span class="dv">0</span> $$ status!<span class="dv">0</span> &gt;&gt; <span class="dv">8</span>
        <span class="kw">when</span> status = {<span class="dv">0</span>} <span class="kw">end</span> <span class="kw">if</span> pid&gt;=<span class="dv">0</span>;
<span class="kw">end</span>;

system <span class="st">&quot;echo Hello, world!&quot;</span>;
system <span class="st">&quot;ls -l *.pure&quot;</span>;
system <span class="st">&quot;exit 1&quot;</span>;</code></pre></div>
<h3 id="importing-dynamic-libraries">Importing Dynamic Libraries</h3>
<p>By default, external C functions are resolved by the LLVM runtime, which first looks for the symbol in the C library and Pure’s runtime library (or the interpreter executable, if the interpreter was linked statically). Thus all C library and Pure runtime functions are readily available in Pure programs. Other functions can be provided by adding them to the runtime, or by linking them into the runtime or the interpreter executable. Better yet, you can just “dlopen” shared libraries at runtime with a special form of the <a href="#using"><code>using</code></a> clause:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="st">&quot;lib:libname[.ext]&quot;</span>;</code></pre></div>
<p>For instance, if you want to call the functions from library libxyz directly from Pure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="st">&quot;lib:libxyz&quot;</span>;</code></pre></div>
<p>After this declaration the functions from the given library will be ready to be imported into your Pure program by means of corresponding <a href="#extern"><code>extern</code></a> declarations.</p>
<p>Shared libraries opened with using clauses are searched for in the same way as source scripts (see section <a href="#modules-and-imports">Modules and Imports</a> above), using the <a href="#cmdoption-pure-L"><code>-L</code></a> option and the <a href="#envvar-PURE_LIBRARY"><code>PURE_LIBRARY</code></a> environment variable in place of <a href="#cmdoption-pure-I"><code>-I</code></a> and <a href="#envvar-PURE_INCLUDE"><code>PURE_INCLUDE</code></a>. If the library isn’t found by these means, the interpreter will also consider other platform-specific locations searched by the dynamic linker, such as the system library directories and <a href="#envvar-LD_LIBRARY_PATH"><code>LD_LIBRARY_PATH</code></a> on Linux. The necessary filename suffix (e.g., .so on Linux or .dll on Windows) will be supplied automatically when needed. Of course you can also specify a full pathname for the library if you prefer that. If a library file cannot be found, or if an <a href="#extern"><code>extern</code></a> declaration names a function symbol which cannot be resolved, an appropriate error message is printed.</p>
<h3 id="importing-llvm-bitcode">Importing LLVM Bitcode</h3>
<p>As of Pure 0.44, the interpreter also provides a direct way to import LLVM bitcode modules in Pure scripts. The main advantage of this method over the “plain” C interface explained above is that the bitcode loader knows all the call interfaces and generates the necessary <a href="#extern"><code>extern</code></a> declarations automatically. This is more than just a convenience, as it also eliminates at least some of the mistakes in <a href="#extern"><code>extern</code></a> declarations that may arise when importing functions manually from dynamic libraries.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> The facilities described below require that you have an LLVM-capable C/C++ compiler installed. The available options right now are <a href="#clang">clang</a>, <a href="#llvm-gcc">llvm-gcc</a> and <a href="#dragonegg">dragonegg</a>. Please check the Pure <a href="install.html">installation instructions</a> on how to get one of these (or all of them) up and running. Note that clang and llvm-gcc are standalone compilers, while dragonegg is supplied as a gcc plugin which hooks into your existing system compiler (gcc 4.5 or later is required for that). Any of these enable you to compile C/C++ source to LLVM assembler or bitcode. The clang compiler is recommended for C/C++ development, as it offers faster compilation times and has much better diagnostics than gcc. On the other hand, llvm-gcc and dragonegg have the advantage that they also support alternative frontends so that you can compile Fortran and Ada code as well. (But note that, as of LLVM 3.x, llvm-gcc is not supported any more.)</p>
</blockquote>
<hr />
<p>LLVM bitcode is loaded in a Pure script using the following special format of the <a href="#using"><code>using</code></a> clause:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="st">&quot;bc:modname[.bc]&quot;</span>;</code></pre></div>
<p>(Here the <code>bc</code> tag indicates a bitcode file, and the default <code>.bc</code> bitcode filename extension is supplied automatically. Also, the bitcode file is searched for on the usual library search path.)</p>
<p>That’s it, no explicit <a href="#extern"><code>extern</code></a> declarations are required on the Pure side. The Pure interpreter automatically creates <a href="#extern"><code>extern</code></a> declarations (in the current namespace) for all the external functions defined in the LLVM bitcode module, and generates the corresponding wrappers to make the functions callable from Pure. (This also works when batch-compiling a Pure script. In this case, the bitcode file actually gets linked into the output code, so the loaded bitcode module only needs to be present at compile time.)</p>
<p>By default the imported symbols will be public. You can also specify the desired scope of the symbols explicitly, by placing the <a href="#public"><code>public</code></a> or <a href="#private"><code>private</code></a> keyword before the module name. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> <span class="kw">private</span> <span class="st">&quot;bc:modname&quot;</span>;</code></pre></div>
<p>You can also import the same bitcode module several times, possibly in different namespaces. This will not actually reload the module, but it will create synonyms for the external functions in different namespaces:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> foo;
<span class="kw">using</span> <span class="st">&quot;bc:modname&quot;</span>;
<span class="kw">namespace</span> bar;
<span class="kw">using</span> <span class="kw">private</span> <span class="st">&quot;bc:modname&quot;</span>;</code></pre></div>
<p>You can load any number of bitcode modules along with shared libraries in a Pure script, in any order. The JIT will try to satisfy external references in modules and libraries from other loaded libraries and bitcode modules. This is deferred until the code is actually JIT-compiled, so that you can make sure beforehand that all required libraries and bitcode modules have been loaded. If the JIT fails to resolve a function, the interpreter will print its name and also raise an exception at runtime when the function is being called from other C code. (You can then run your script in the debugger to locate the external visible in Pure from which the unresolved function is called.)</p>
<p>Let’s take a look at a concrete example to see how this actually works. Consider the following C code which defines a little function to compute the greatest common divisor of two (machine) integers:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> mygcd(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
  <span class="cf">if</span> (y == <span class="dv">0</span>)
    <span class="cf">return</span> x;
  <span class="cf">else</span>
    <span class="cf">return</span> mygcd(y, x%y);
}</code></pre></div>
<p>Let’s say that this code is in the file <code>mygcd.c</code>, then you’d compile it to a bitcode module using <a href="#clang">clang</a> as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">clang -emit-llvm -c mygcd.c -o mygcd.bc</code></pre></div>
<p>Note that the <code>-emit-llvm -c</code> options instruct clang to build an LLVM bitcode module. Of course, you can also add optimizations and other options to the compile command as desired.</p>
<p>Using <a href="#dragonegg">dragonegg</a> is somewhat more involved, as it doesn’t provide a direct way to produce a bitcode file yet. However, you can create an LLVM assembler file which can then be translated to bitcode using the llvm-as program as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">gcc -fplugin=dragonegg -flto -S mygcd.c -o mygcd.ll
llvm-as mygcd.ll -o mygcd.bc</code></pre></div>
<p>(Note that the <code>-fplugin</code> option instructs gcc to use the dragonegg plugin, which in conjunction with the <code>-flto</code> flag switches it to LLVM output. Please check the dragonegg website for details.)</p>
<p>In either case, you can now load the resulting bitcode module and run the <code>mygcd</code> function in the Pure interpreter simply as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="st">&quot;bc:mygcd&quot;</span>;
&gt; mygcd <span class="dv">75</span> <span class="dv">105</span>;
<span class="dv">15</span></code></pre></div>
<p>To actually see the generated <a href="#extern"><code>extern</code></a> declaration of the imported function, you can use the interactive <code>show</code> command:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show mygcd
<span class="kw">extern</span> <span class="dt">int</span> mygcd(<span class="dt">int</span>, <span class="dt">int</span>);</code></pre></div>
<p>Some more examples showing how to use the bitcode interface can be found in the Pure sources. In particular, the interface also works with Fortran (using llvm-gfortran or gfortran with dragonegg), and there is special support for interfacing to Grame’s functional DSP programming language <a href="#faust">Faust</a> (the latter uses a special variant of the bitcode loader, which is selected with the <code>dsp</code> tag in the <a href="#using"><code>using</code></a> clause). Further details about these can be found below.</p>
<p>Please note that at this time the LLVM bitcode interface is still somewhat experimental, and there are some known limitations:</p>
<ul>
<li><p>LLVM doesn’t distinguish between <code>char*</code> and <code>void*</code> in bitcode, so all <code>void*</code> parameters and return values in C code will be promoted to <code>char*</code> on the Pure side. Also, pointers to types which neither have a predefined meaning in Pure nor a proper type name in the bitcode file, will become a generic pointer type (<code>void*</code>, <code>void**</code>, etc.) in Pure. If this is a problem then you can just redeclare the corresponding functions under a synonym <em>after</em> loading the bitcode module, giving the proper argument and result types (see <a href="#extern-declarations">Extern Declarations</a> above). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="st">&quot;bc:foo&quot;</span>;
&gt; show foo
<span class="kw">extern</span> <span class="dt">char</span>* foo(<span class="dt">char</span>*);
&gt; <span class="kw">extern</span> <span class="dt">void</span> *foo(<span class="dt">void</span>*) = myfoo;
&gt; show myfoo
<span class="kw">extern</span> <span class="dt">void</span>* foo(<span class="dt">void</span>*) = myfoo;</code></pre></div></li>
<li><p>The bitcode interface is limited to the same range of C types as Pure’s plain C interface. In practice, this should cover most C code, but it’s certainly possible that you run into unsupported types for arguments and return values. The compiler will then print a warning; the affected functions will still be linked in, but they will not be callable from Pure. Also note that calling conventions for passing C structs <em>by value</em> depend on the host ABI, so you should have a look at the resulting <a href="#extern"><code>extern</code></a> declaration (using <code>show</code>) to determine how the function is actually to be called from Pure.</p></li>
</ul>
<h3 id="inline-code">Inline Code</h3>
<p>Instead of manually compiling source files to bitcode modules, you can also just place the source code into a Pure script, enclosing it in <code>%&lt; ... %&gt;</code>. (Optionally, the opening brace may also be preceded with a <a href="#public"><code>public</code></a> or <a href="#private"><code>private</code></a> scope specifier, which is used in the same way as the scope specifier following the <a href="#using"><code>using</code></a> keyword when importing bitcode files.)</p>
<p>For instance, here is a little script showing inline code for the <code>mygcd</code> function from the previous subsection:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">%&lt;
<span class="dt">int</span> mygcd(<span class="dt">int</span> x, <span class="dt">int</span> y)
{
  <span class="kw">if</span> (y == <span class="dv">0</span>)
    return x;
  <span class="kw">else</span>
    return mygcd(y, x%y);
}
%&gt;

mygcd <span class="dv">75</span> <span class="dv">105</span>;</code></pre></div>
<p>The interpreter automatically compiles the inlined code to LLVM bitcode which is then loaded as usual. (Of course, this will only work if you have the corresponding LLVM compilers installed.) This method has the advantage that you don’t have to write a Makefile and you can create self-contained Pure scripts which include all required external functions. The downside is that the inline code sections will have to be recompiled every time you run the script with the interpreter which may considerably increase startup times. If this is a problem then it’s usually better to import a separate bitcode module instead (see <a href="#importing-llvm-bitcode">Importing LLVM Bitcode</a>), or batch-compile your script to an executable (see <a href="#batch-compilation">Batch Compilation</a>).</p>
<p>At present, C, C++, Fortran, ATS and Faust are supported as foreign source languages, with clang, clang++, gfortran (with the dragonegg plugin), patscc and faust as the corresponding (default) compilers. C is the default language. The desired source language can be selected by placing an appropriate tag into the inline code section, immediately after the opening brace. (The tag is removed before the code is submitted to compilation.) For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">%&lt; -*- Fortran90 -*-
function fact(n) result(p)
  integer n, p
  p = <span class="dv">1</span>
  do i = <span class="dv">1</span>, n
     p = p*i
  <span class="kw">end</span> do
<span class="kw">end</span> function fact
%&gt;

fact n::<span class="dt">int</span> = fact_ {n};
map fact (<span class="dv">1</span>..<span class="dv">10</span>);</code></pre></div>
<p>As indicated, the language tag takes the form <code>-*- lang -*-</code> where <code>lang</code> can currently be any of <code>c</code>, <code>c++</code>, <code>fortran</code>, <code>ats</code> and <code>dsp</code> (the latter indicates the Faust language). Case is insignificant here, so you can also write <code>C</code>, <code>C++</code>, <code>Fortran</code>, <code>ATS</code>, <code>DSP</code> etc. For the <code>fortran</code> tag, you may also have to specify the appropriate language standard, such as <code>fortran90</code> which is used in the example above. The language tag can also be followed by a module name, using the format <code>-*- lang:name -*-</code>. This is optional for all languages except Faust (where the module name specifies the namespace for the interface routines of the Faust module; see <a href="#interfacing-to-faust">Interfacing to Faust</a> below). So, e.g., a Faust DSP named <code>test</code> would be specified with a <code>dsp:test</code> tag. Case is <em>significant</em> in the module name.</p>
<p>The Pure interpreter has some built-in knowledge on how to invoke the LLVM compilers to produce a working bitcode file ready to be loaded by the interpreter, so the examples above should work out of the box if you have the required compilers installed on your <a href="#envvar-PATH"><code>PATH</code></a>. However, there are also some environment variables you can set for customization purposes. Specifically, <a href="#envvar-PURE_CC"><code>PURE_CC</code></a> is the command to invoke the C compiler. This variable lets you specify the exact name of the executable along with any debugging and optimization options that you may want to add. Likewise, <a href="#envvar-PURE_CXX"><code>PURE_CXX</code></a>, <a href="#envvar-PURE_FC"><code>PURE_FC</code></a>, <a href="#envvar-PURE_ATS"><code>PURE_ATS</code></a> and <a href="#envvar-PURE_FAUST"><code>PURE_FAUST</code></a> are used for the C++, Fortran, ATS and Faust compilers, respectively.</p>
<p>For instance, if you prefer to use <a href="#llvm-gcc">llvm-gcc</a> as your C compiler, and you’d like to invoke it with the <code>-O3</code> optimization option, you would set <a href="#envvar-PURE_CC"><code>PURE_CC</code></a> to <code>&quot;llvm-gcc -O3&quot;</code>. (To verify the settings you made, you can have the interpreter echo the compilation commands which are actually executed, by running Pure with the <code>-v0100</code> option, see <a href="#verbosity-and-debugging-options">Verbosity and Debugging Options</a>. Also note that the options necessary to produce LLVM bitcode will be added automatically, so you don’t have to specify these.)</p>
<p>Beginning with Pure 0.48, the <a href="#dragonegg">dragonegg</a> gcc plugin is also fully supported. To make this work, you need to explicitly specify the name of the plugin in the compilation command, so that the Pure interpreter can add the proper set of options needed for bitcode compilation. For instance:</p>
<pre class="sourceCode console"><code>PURE_CC=&quot;gcc -fplugin=dragonegg -O3&quot;</code></pre>
<p>Some further details on the bitcode support for specific target languages can be found in the subsections below.</p>
<h3 id="interfacing-to-c">Interfacing to C++</h3>
<p>Interfacing to C++ code requires additional preparations because of the name mangling performed by C++ compilers. Usually, you won’t be able to call C++ functions and methods directly, so you’ll have to expose the required functionality using functions with C binding (<code>extern &quot;C&quot;</code>). For instance, the following example shows how to work with STL maps from Pure.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">%&lt; -*- C++ -*-

#include &lt;pure/runtime.h&gt;
#include &lt;<span class="dt">string</span>&gt;
#include &lt;map&gt;

<span class="co">// An STL map mapping strings to Pure expressions.</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;
typedef map&lt;<span class="dt">string</span>,pure_expr*&gt; exprmap;

<span class="co">// Since we can&#39;t directly deal with C++ classes in Pure, provide some C</span>
<span class="co">// functions to create, destroy and manipulate these objects.</span>

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> exprmap *map_create()
{
  return new exprmap;
}

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> map_add(exprmap *m, <span class="kw">const</span> <span class="dt">char</span> *key, pure_expr *x)
{
  exprmap::iterator it = m-&gt;find(<span class="dt">string</span>(key));
  <span class="kw">if</span> (it != m-&gt;<span class="kw">end</span>()) pure_free(it-&gt;second);
  (*m)[key] = pure_new(x);
}

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> map_del(exprmap *m, <span class="kw">const</span> <span class="dt">char</span> *key)
{
  exprmap::iterator it = m-&gt;find(key);
  <span class="kw">if</span> (it != m-&gt;<span class="kw">end</span>()) {
    pure_free(it-&gt;second);
    m-&gt;erase(it);
  }
}

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> pure_expr *map_get(exprmap *m, <span class="kw">const</span> <span class="dt">char</span> *key)
{
  exprmap::iterator it = m-&gt;find(key);
  return (it != m-&gt;<span class="kw">end</span>())?it-&gt;second:<span class="dv">0</span>;
}

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> pure_expr *map_keys(exprmap *m)
{
  size_t i = <span class="dv">0</span>, n = m-&gt;size();
  pure_expr **xs = new pure_expr*[n];
  for (exprmap::iterator it = m-&gt;begin(); it != m-&gt;<span class="kw">end</span>(); ++it)
    xs[i++] = pure_string_dup(it-&gt;first.c_str());
  pure_expr *x = pure_listv(n, xs);
  delete[] xs;
  return x;
}

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> map_destroy(exprmap *m)
{
  for (exprmap::iterator it = m-&gt;begin(); it != m-&gt;<span class="kw">end</span>(); ++it)
    pure_free(it-&gt;second);
  delete m;
}

%&gt;

<span class="co">// Create the STL map and add a sentry so that it garbage-collects itself.</span>
<span class="kw">let</span> m = sentry map_destroy map_create;

<span class="co">// Populate the map with some arbitrary Pure data.</span>
do (\(x=&gt;y) -&gt; map_add m x y) [<span class="st">&quot;foo&quot;</span>=&gt;<span class="dv">99</span>, <span class="st">&quot;bar&quot;</span>=&gt;bar 4711L, <span class="st">&quot;baz&quot;</span>=&gt;<span class="dv">1</span>..<span class="dv">5</span>];

<span class="co">// Query the map.</span>
map_keys m; <span class="co">// =&gt; [&quot;bar&quot;,&quot;baz&quot;,&quot;foo&quot;]</span>
map (map_get m) (map_keys m); <span class="co">// =&gt; [bar 4711L,[1,2,3,4,5],99]</span>

<span class="co">// Delete an element.</span>
map_del m <span class="st">&quot;foo&quot;</span>;
map_keys m; <span class="co">// =&gt; [&quot;bar&quot;,&quot;baz&quot;]</span>
map (map_get m) (map_keys m); <span class="co">// =&gt; [bar 4711L,[1,2,3,4,5]]</span></code></pre></div>
<h3 id="interfacing-to-ats">Interfacing to ATS</h3>
<p><a href="#ats">ATS</a> is a statically typed functional programming language somewhat similar to ML, which also offers imperative and concurrent programming features. One of ATS’s most unusual and interesting aspects is its highly expressive Applied Type System, which gives the language its name. ATS has a very elaborate <a href="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/HTML/c1995.html">C interface</a> which lets you expose functions written in the language using C linkage. This makes it easy to call ATS functions from Pure via Pure’s C interface.</p>
<p>Here is a simple example which illustrates how to implement the factorial in ATS and call that function from Pure:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">%&lt; -*- ATS -*-

#include <span class="st">&quot;share/atspre_staload.hats&quot;</span>

<span class="co">// A recursive definition of the factorial relation.</span>
<span class="co">// FACT (n, r) means ‘the factorial of n equals r’.</span>
<span class="co">// MUL (i, j, k) means ‘the product of i and j equals k’.</span>
dataprop FACT (<span class="dt">int</span>, <span class="dt">int</span>) =
  | FACT_base (<span class="dv">0</span>, <span class="dv">1</span>)
  | {n : nat} {r1, r : <span class="dt">int</span>}
    FACT_induction (n, r) <span class="kw">of</span>
      (FACT (n-<span class="dv">1</span>, r1), MUL (n, r1, r))

<span class="co">// Declare ifact as an ATS function that is referred to in C by the</span>
<span class="co">// name ‘ifact_nonneg’. The ‘ifact_nonneg’ function returns an integer</span>
<span class="co">// equal to r, where r satisfies the relation FACT (n, r).</span>
<span class="kw">extern</span> fun ifact :
    {n : nat} (<span class="dt">int</span> n) -&lt;&gt; [r : <span class="dt">int</span>] (FACT (n, r) | <span class="dt">int</span> r) =
      <span class="st">&quot;ext#ifact_nonneg&quot;</span>

implement ifact (n) =
  <span class="kw">let</span>
    fun fact {n : nat} .&lt;n&gt;. (n : <span class="dt">int</span> n) :&lt;&gt;
        [r : <span class="dt">int</span>] (FACT (n, r) | <span class="dt">int</span> r) =
      begin
        <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span>
          <span class="kw">let</span>
            val (pf1 | r1) = ifact (n - <span class="dv">1</span>)
            val (pfmul | r) = g1int_mul2 (n, r1)
          in
            (FACT_induction (pf1, pfmul) | r)
          <span class="kw">end</span>
        <span class="kw">else</span>
          (FACT_base () | <span class="dv">1</span>)
      <span class="kw">end</span>
  in
    fact n
  <span class="kw">end</span>

%&gt;

ifact n::<span class="dt">int</span> = ifact_nonneg n <span class="kw">if</span> <span class="dv">0</span> &lt;= n;

map ifact (<span class="dv">0</span>..<span class="dv">9</span>);</code></pre></div>
<p>To make this work in Pure, you need to have ATS2 (the current version of the ATS compiler) installed. ATS2 in turn needs a suitable C compiler for generating LLVM bitcode. By default, Pure uses clang for that purpose. If you have gcc’s dragonegg plugin installed, you can also use gcc as the C compiler instead, by setting the <a href="#envvar-PURE_ATS"><code>PURE_ATS</code></a> environment variable to <code>patscc -fplugin=dragonegg</code>. Also make sure that you have the <a href="#envvar-PATSHOME"><code>PATSHOME</code></a> environment variable set to ATS’s library directory, as explained in the <a href="http://www.ats-lang.org/Downloads.html#Install_source_compile">ATS installation instructions</a>.</p>
<p>More information about ATS, as well as sources and binary packages of the ATS compiler can be found on the <a href="http://www.ats-lang.org/">ATS website</a>.</p>
<p><a name="interfacing-to-faust"></a></p>
<h3 id="interfacing-to-faust">Interfacing to Faust</h3>
<p><a href="#faust">Faust</a> is a functional dsp (digital signal processing) programming language developed at Grame, which is tailored to the task of generating and transforming streams of numeric data at the sample level. It is typically used to program sound synthesis and audio effect units, but can in fact be employed to process any kind of numeric vector and matrix data. The Faust compiler is capable of generating very efficient code for such tasks which is comparable in performance with carefully handcrafted C routines. Pure’s Faust interface lets you use these capabilities in order to process sample data stored in Pure matrices.</p>
<p>Pure’s LLVM bitcode loader has some special knowledge about Faust built into it, which makes interfacing to Faust programs simple and efficient. At present, you’ll need a special LLVM-capable version of Faust to make this work, which is available under the “faust2” branch in Faust’s git repository. Some information on how to get this up and running can be found on the <a href="https://bitbucket.org/purelang/pure-lang/wiki/Faust2">LLVM backend for Faust</a> website.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> There’s also an alternative interface to Faust which is available as a separate package and works with either Faust2 or the stable Faust version. Please check the <a href="pure-faust.html">pure-faust</a> package for details. This package also provides the <a href="pure-faust.html#module-faust2">faust2</a> compatibility module which implements the pure-faust API on top of Pure’s built-in Faust interface, so that you can also use the operations of this module instead. (The pure-faust API can in fact be more convenient to use in some cases, especially if you want to load a lot of different Faust modules dynamically at runtime.)</p>
</blockquote>
<hr />
<p>The <code>-lang llvm</code> option instructs the Faust compiler to output LLVM bitcode. Also, you want to add the <code>-double</code> option to make the compiled Faust module use double precision floating point values for samples and control values. So you’d compile an existing Faust module in the source file example.dsp as follows:</p>
<pre class="sourceCode console"><code>faust -double -lang llvm example.dsp -o example.bc</code></pre>
<p>The <code>-double</code> option isn’t strictly necessary, but it makes interfacing between Pure and Faust easier and more efficient, since Pure uses <code>double</code> as its native floating point format.</p>
<p>Alternatively, you can also use the Faust <code>pure.c</code> architecture (included in recent Faust2 revisions and also in the <a href="pure-faust.html">pure-faust</a> package) to compile a Faust program to corresponding C source which can then be fed into an LLVM-capable C compiler to produce bitcode which is compatible with Pure’s Faust bitcode loader. This is useful, in particular, if you want to make use of special optimization options provided by the C compiler, or if the Faust module needs to be linked against additional C/C++ code. For instance:</p>
<pre class="sourceCode console"><code>faust -double -a pure.c -lang c example.dsp -o example.c
clang -emit-llvm -O3 -c example.c -o example.bc</code></pre>
<p>A third possibility is to just inline Faust code in a Pure script, as described in the <a href="#inline-code">Inline Code</a> section. The compilation step is then handled by the Pure compiler and the <code>-double</code> option is added automatically. The <a href="#envvar-PURE_FAUST"><code>PURE_FAUST</code></a> environment variable can be used to specify a custom Faust command to be invoked by the Pure interpreter. This is useful if you’d like to invoke the Faust compiler with some special options, e.g.:</p>
<pre class="sourceCode console"><code>PURE_FAUST=&quot;faust -single -vec&quot;</code></pre>
<p>(Note that you do not have to include the <code>-lang llvm</code> option; the inline compiler will supply it automatically.)</p>
<p>Moreover, you can also set the <a href="#envvar-FAUST_OPT"><code>FAUST_OPT</code></a> environment variable to specify any needed postprocessing of the output of the Faust compiler; this is typically used to invoke the LLVM <code>opt</code> utility in a pipeline, in order to have some additional optimizations performed on the Faust-generated code:</p>
<pre class="sourceCode console"><code>FAUST_OPT=&quot;| opt -O3&quot;</code></pre>
<p>After loading or inlining the Faust module, the Pure compiler makes the interface routines of the Faust module available in its own namespace. Thus, e.g., the interface routines for the example.dsp module will end up in the <code>example</code> namespace.</p>
<p>Pure’s Faust interface offers another useful feature not provided by the general bitcode interface, namely the ability to reload Faust modules on the fly. If you repeat the import clause for a Faust module, the compiler checks whether the module was modified and, if so, replaces the old module with the new one. Retyping an inline Faust code section has the same effect. This is mainly intended as a convenience for interactive usage, so that you can test different versions of a Faust module without having to restart the Pure interpreter. But it is also put to good use in addon packages like <a href="pd-faust.html">pd-faust</a> which allows Faust dsps to be reloaded at runtime.</p>
<p>For instance, consider the following little Faust program, which takes a stereo audio signal as input, mixes the two channels and multiplies the resulting mono signal with a gain value given by a corresponding Faust control variable:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">gain = nentry(<span class="st">&quot;gain&quot;</span>, <span class="dv">0.3</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0.01</span>);
process = + : *(gain);</code></pre></div>
<p>The interface routines of this Faust module look as follows on the Pure side:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show -g example::*
<span class="kw">extern</span> <span class="dt">void</span> buildUserInterface(struct_dsp_example*, struct_UIGlue*) = example::buildUserInterface;
<span class="kw">extern</span> <span class="dt">void</span> classInit(<span class="dt">int</span>) = example::classInit;
<span class="kw">extern</span> <span class="dt">void</span> compute(struct_dsp_example*, <span class="dt">int</span>, <span class="dt">double</span>**, <span class="dt">double</span>**) = example::compute;
<span class="kw">extern</span> <span class="dt">void</span> delete(struct_dsp_example*) = example::delete;
<span class="kw">extern</span> <span class="dt">void</span> destroy(struct_dsp_example*) = example::destroy;
<span class="kw">extern</span> <span class="dt">int</span> getNumInputs(struct_dsp_example*) = example::getNumInputs;
<span class="kw">extern</span> <span class="dt">int</span> getNumOutputs(struct_dsp_example*) = example::getNumOutputs;
<span class="kw">extern</span> <span class="dt">int</span> getSampleRate(struct_dsp_example*) = example::getSampleRate;
<span class="kw">extern</span> <span class="dt">expr</span>* info(struct_dsp_example*) = example::info;
<span class="kw">extern</span> <span class="dt">void</span> init(struct_dsp_example*, <span class="dt">int</span>) = example::init;
<span class="kw">extern</span> <span class="dt">void</span> instanceInit(struct_dsp_example*, <span class="dt">int</span>) = example::instanceInit;
<span class="kw">extern</span> <span class="dt">expr</span>* meta() = example::meta;
<span class="kw">extern</span> <span class="dt">void</span> metadata(struct_MetaGlue*) = example::metadata;
<span class="kw">extern</span> struct_dsp_example* new() = example::new;
<span class="kw">extern</span> struct_dsp_example* newinit(<span class="dt">int</span>) = example::newinit;</code></pre></div>
<p>The most important interface routines are <code>new</code>, <code>init</code> and <code>delete</code> (used to create, initialize and destroy an instance of the dsp) and <code>compute</code> (used to apply the dsp to a given block of samples). Some useful convenience functions are added by the Pure compiler:</p>
<ul>
<li><code>newinit</code> combines <code>new</code> and <code>init</code>;</li>
<li><code>info</code> yields pertinent information about the dsp as a Pure tuple containing the number of input and output channels and the Faust control descriptions;</li>
<li><code>meta</code> yields metadata about the dsp, as declared in the Faust source.</li>
</ul>
<p>The latter two are provided in a symbolic format ready to be used in Pure; more about that below.</p>
<p>Note that there’s usually no need to explicitly invoke the <code>delete</code> routine in Pure programs; the Pure compiler makes sure that this routine is added automatically as a finalizer (see <a href="purelib.html#sentry"><code>sentry</code></a>) to all dsp pointers created through the <code>new</code> and <code>newinit</code> routines so that dsp instances are destroyed automatically when the corresponding Pure objects are garbage-collected. (If you prefer to do the finalization manually then you must also remove the sentry from the dsp object, so that it doesn’t get deleted twice.)</p>
<p>Another point worth mentioning here is that the Pure compiler always generates code that ensures that the Faust dsp instances (the <code>struct_dsp</code> pointers) are fully typechecked at runtime. Thus it is only possible to pass a dsp struct pointer to the interface routines of the Faust module it was created with.</p>
<p>Let’s have a brief look at how we can actually run a Faust module in Pure to process some audio samples.</p>
<p><strong>Step 1: Load the Faust dsp.</strong> This assumes that the Faust source has already been compiled to a bitcode file, as shown above. You can then load the module in Pure as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> <span class="st">&quot;dsp:example&quot;</span>;</code></pre></div>
<p>Note that the .bc bitcode extension is supplied automatically. Also note the special <code>dsp</code> tag; this tells the compiler that this is a Faust-generated module, so that it does some Faust-specific processing while linking the module.</p>
<p>Alternatively, you can also just inline the code of the Faust module. For the example above, the inline code section looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">%&lt; -*- dsp:example -*-
gain = nentry(<span class="st">&quot;gain&quot;</span>, <span class="dv">0.3</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0.01</span>);
process = + : *(gain);
%&gt;</code></pre></div>
<p>You can either add this code to a Pure script, or just type it directly in the Pure interpreter.</p>
<p>Finally, you may want to verify that the module has been properly loaded by typing <code>show -g example::*</code>. The output should look like the listing above.</p>
<p><strong>Step 2: Create and initialize a dsp instance.</strong> After importing the Faust module you can now create an instance of the Faust signal processor using the <code>newinit</code> routine, and assign it to a Pure variable as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> dsp = example::newinit <span class="dv">44100</span>;</code></pre></div>
<p>Note that the constant 44100 denotes the desired sample rate in Hz. This can be an arbitrary integer value, which is available in the Faust program by means of the <code>SR</code> variable. It’s completely up to the dsp whether it actually uses this value in some way (our example doesn’t, but we need to specify a value anyway).</p>
<p>The dsp is now fully initialized and we can use it to compute some samples. But before we can do this, we’ll need to know how many channels of audio data the dsp consumes and produces, and which control variables it provides. This information can be extracted with the <code>info</code> function, and be assigned to some Pure variables as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> k,l,ui = example::info dsp;</code></pre></div>
<p>(We’ll have a closer look at the contents of the <code>ui</code> variable below.)</p>
<p>In a similar fashion, the <code>meta</code> function provides some “metadata” about the Faust dsp, as a list of <code>key=&gt;val</code> string pairs. This is static data which doesn’t belong to any particular dsp instance, so it can be extracted without actually creating an instance. In our case the metadata will be empty, since we didn’t supply any in the Faust program. If needed, we can add some metadata as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">declare descr   <span class="st">&quot;Faust Hello World&quot;</span>;
declare author  <span class="st">&quot;Faust Guru&quot;</span>;
declare version <span class="st">&quot;1.0&quot;</span>;
gain = nentry(<span class="st">&quot;gain&quot;</span>, <span class="dv">0.3</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0.01</span>);
process = + : *(gain);</code></pre></div>
<p>If we now reload the Faust dsp, we’ll get:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; test::meta;
[<span class="st">&quot;descr&quot;</span>=&gt;<span class="st">&quot;Faust Hello World&quot;</span>,<span class="st">&quot;author&quot;</span>=&gt;<span class="st">&quot;Faust Guru&quot;</span>,<span class="st">&quot;version&quot;</span>=&gt;<span class="st">&quot;1.0&quot;</span>]</code></pre></div>
<p><strong>Step 3: Prepare input and output buffers.</strong> Pure’s Faust interface allows you to pass Pure double matrices as sample buffers, which makes this step quite convenient. For given numbers k and l of input and output channels, respectively, we’ll need a k x n matrix for the input and a l x n matrix for the output, where n is the desired block size (the number of samples to be processed per channel in one go). Note that the matrices have one row per input or output channel. Here’s how we can create some suitable input and output matrices using a Pure matrix comprehension and the <code>dmatrix</code> function available in the standard library:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> n = <span class="dv">10</span>; <span class="co">// the block size</span>
&gt; <span class="kw">let</span> in  = {i*<span class="dv">10.0</span>+j | i = <span class="dv">1</span>..k; j = <span class="dv">1</span>..n};
&gt; <span class="kw">let</span> out = <span class="dt">dmatrix</span> (l,n);</code></pre></div>
<p>In our example, k=2 and l=1, thus we obtain the following matrices:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; in;
{<span class="dv">11.0</span>,<span class="dv">12.0</span>,<span class="dv">13.0</span>,<span class="dv">14.0</span>,<span class="dv">15.0</span>,<span class="dv">16.0</span>,<span class="dv">17.0</span>,<span class="dv">18.0</span>,<span class="dv">19.0</span>,<span class="dv">20.0</span>;
<span class="dv">21.0</span>,<span class="dv">22.0</span>,<span class="dv">23.0</span>,<span class="dv">24.0</span>,<span class="dv">25.0</span>,<span class="dv">26.0</span>,<span class="dv">27.0</span>,<span class="dv">28.0</span>,<span class="dv">29.0</span>,<span class="dv">30.0</span>}
&gt; out;
{<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>,<span class="dv">0.0</span>}</code></pre></div>
<p><strong>Step 4: Apply the dsp to compute some samples.</strong> With the <code>in</code> and <code>out</code> matrices as given above, we can now apply the dsp by invoking its <code>compute</code> routine:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; example::compute dsp n in out;</code></pre></div>
<p>This takes the input samples specified in the <code>in</code> matrix and stores the resulting output in the <code>out</code> matrix. The output matrix now looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; out;
{<span class="dv">9.6</span>,<span class="dv">10.2</span>,<span class="dv">10.8</span>,<span class="dv">11.4</span>,<span class="dv">12.0</span>,<span class="dv">12.6</span>,<span class="dv">13.2</span>,<span class="dv">13.8</span>,<span class="dv">14.4</span>,<span class="dv">15.0</span>}</code></pre></div>
<p>Note that the <code>compute</code> routine also modifies the internal state of the dsp instance so that a subsequent call will continue with the output stream where the previous call left off. (This isn’t relevant in this specific example, but in general a Faust dsp may contain delays and similar constructions which need a memory of past samples to be maintained between different invocations of <code>compute</code>.) Thus we can now just keep on calling <code>compute</code> (possibly with different <code>in</code> buffers) to compute as much of the output signal as we need.</p>
<p><strong>Step 5: Inspecting and modifying control variables.</strong> Recall that our sample dsp also has a Faust control variable <code>gain</code> which lets us change the amplification of the output signal. We’ve already assigned the corresponding information to the <code>ui</code> variable, let’s have a look at it now:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ui;
vgroup [] (<span class="st">&quot;test&quot;</span>,[nentry #&lt;<span class="dt">pointer</span> <span class="dv">0x1611f00</span>&gt; [] (<span class="st">&quot;gain&quot;</span>,<span class="dv">0.3</span>,<span class="dv">0.0</span>,<span class="dv">10.0</span>,<span class="dv">0.01</span>)])</code></pre></div>
<p>In general, this data structure takes the form of a tree which corresponds to the hierarchical layout of the control groups and values in the Faust program. In this case, we just have one toplevel group containing a single <code>gain</code> parameter, which is represented as a Pure term containing the relevant information about the type, name, initial value, range and stepsize of the control, along with a double pointer which can be used to inspect and modify the control value. While it’s possible to access this information in a direct fashion, there’s also a faustui.pure module in the standard library which makes this easier. First we extract the mapping of control variable names to the corresponding double pointers as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> faustui;
&gt; <span class="kw">let</span> ui = control_map $ controls ui; ui;
{<span class="st">&quot;gain&quot;</span>=&gt;#&lt;<span class="dt">pointer</span> <span class="dv">0xd81820</span>&gt;}</code></pre></div>
<p>The result is a record value indexed by control names, thus the pointer which belongs to our <code>gain</code> control can now be obtained with <code>ui!&quot;gain&quot;</code>. The faustui.pure module also provides convenience functions to inspect a control and change its value:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> gain = ui!<span class="st">&quot;gain&quot;</span>;
&gt; get_control gain;
<span class="dv">0.3</span>
&gt; put_control gain <span class="dv">1.0</span>;
()
&gt; get_control gain;
<span class="dv">1.0</span></code></pre></div>
<p>Let’s rerun <code>compute</code> to get another block of samples from the same input data, using the new <code>gain</code> value:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; example::compute dsp n in out;
&gt; out;
{<span class="dv">32.0</span>,<span class="dv">34.0</span>,<span class="dv">36.0</span>,<span class="dv">38.0</span>,<span class="dv">40.0</span>,<span class="dv">42.0</span>,<span class="dv">44.0</span>,<span class="dv">46.0</span>,<span class="dv">48.0</span>,<span class="dv">50.0</span>}</code></pre></div>
<p>Faust also allows metadata to be attached to individual controls and control groups, which is available in the same form of a list of <code>key=&gt;val</code> string pairs that we have seen already with the <code>meta</code> operation. This metadata is used to provide auxiliary information about a control to specific applications. It’s completely up to the application how to interpret this metadata. Typical examples are style hints about GUI renderings of a control, or the assignment of external “MIDI” controllers. (<strong>MIDI</strong> is the “Musical Instruments Digital Interface”, a standardized hardware and software interface for electronic music instruments and other digital multimedia equipment.)</p>
<p>In our example these metadata lists are all empty. Control metadata is specified in a Faust program in the labels of the controls using the syntax <code>[key:val]</code>, please see the Faust documentation for details. For instance, if we’d like to assign MIDI controller 7 (usually the “volume controller” on MIDI keyboards) to our <code>gain</code> control, this might be done as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">gain = nentry(<span class="st">&quot;gain [midi:ctrl 7]&quot;</span>, <span class="dv">0.3</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0.01</span>);</code></pre></div>
<p>After reloading the dsp and creating a new instance, this metadata is available in the <code>ui</code> structure and can be extracted with the <code>control_meta</code> function of the faustui module as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> dsp = test::newinit SR;
&gt; <span class="kw">let</span> k,l,ui = example::info dsp;
&gt; controls ui!<span class="dv">0</span>;
nentry #&lt;<span class="dt">pointer</span> <span class="dv">0x1c97070</span>&gt; [<span class="st">&quot;midi&quot;</span>=&gt;<span class="st">&quot;ctrl 7&quot;</span>] (<span class="st">&quot;gain&quot;</span>,<span class="dv">0.3</span>,<span class="dv">0.0</span>,<span class="dv">10.0</span>,<span class="dv">0.01</span>)
&gt; control_meta ans;
[<span class="st">&quot;midi&quot;</span>=&gt;<span class="st">&quot;ctrl 7&quot;</span>]</code></pre></div>
<p>As you can see, all these steps are rather straightforward. Of course, in a real program we would probably run <code>compute</code> in a loop which reads some samples from an audio device or sound file, applies the dsp, and writes back the resulting samples to another audio device or file. We might also have to process MIDI controller input and change the control variables accordingly. This can all be done quite easily using the appropriate addon modules available on the Pure website.</p>
<p>We barely scratched the surface here, but it should be apparent that the programming techniques sketched out in this section open the door to the realm of sophisticated multimedia and signal processing applications. More Faust-related examples can be found in the Pure distribution. Also, have a look at the <a href="pd-pure.html">pd-pure</a> and <a href="pd-faust.html">pd-faust</a> packages to see how these facilities can be used in Pd modules written in Pure.</p>
<h2 id="interactive-usage">Interactive Usage</h2>
<p>In interactive mode, the interpreter reads definitions and expressions and processes them as usual. You can use the <a href="#cmdoption-pure-i"><code>-i</code></a> option to force interactive mode when invoking the interpreter with some script files. Additional scripts can be loaded interactively using either a <a href="#using"><code>using</code></a> declaration or the interactive <code>run</code> command (see the description of the <code>run</code> command below for the differences between these). Or you can just start typing away, entering your own definitions and expressions to be evaluated.</p>
<p>The input language is mostly the same as for source scripts, and hence individual definitions and expressions must be terminated with a semicolon before they are processed. For instance, here is a simple interaction which defines the factorial and then uses that definition in some evaluations. Input lines begin with “&gt;”, which is the interpreter’s default command prompt:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">1</span> = <span class="dv">1</span>;
&gt; fact n = n*fact (n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">1</span>;
&gt; <span class="kw">let</span> x = fact <span class="dv">10</span>; x;
<span class="dv">3628800</span>
&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>As indicated, in interactive mode the normal forms of toplevel expressions are printed after each expression is entered. This is also commonly known as the <strong>read-eval-print loop</strong>. Normal form expressions are usually printed in the same form as you’d enter them. However, there are a few special kinds of objects like anonymous closures, thunks (“lazy” values to be evaluated when needed) and pointers which don’t have a textual representation in the Pure syntax and will be printed in the format <code>#&lt;</code><em>object description</em><code>&gt;</code> by default. It is also possible to override the print representation of any kind of expression by means of the <a href="#__show__"><code>__show__</code></a> function, see <a href="#pretty-printing">Pretty-Printing</a> below for details.</p>
<p>A number of other special features of Pure’s command line interface are discussed in the following subsections.</p>
<h3 id="command-syntax">Command Syntax</h3>
<p>Besides Pure definitions and expressions, the interpreter also understands a number of special interactive commands for performing basic maintenance tasks, such as loading source scripts, exiting and restarting the interpreter, changing the working directory, escaping to the shell, getting help and displaying definitions. In contrast to the normal input language, the command language is line-oriented; it consists of special command words to be typed at the beginning of an input line, which may be followed by some parameters as required by the command. The command language is intended solely for interactive purposes and thus doesn’t offer any programming facilities of its own. However, it can be extended with user-defined commands implemented as ordinary Pure functions; this is described in the <a href="#user-defined-commands">User-Defined Commands</a> section below.</p>
<p>In fact, as of Pure 0.56 the interpreter actually provides two slightly different command syntaxes, which we’ll refer to as “default” and “escape mode”. The manual assumes that you’re running the interpreter in its traditional <strong>default mode</strong> where interactive commands are typed simply as they are shown in the following subsections, with the command word at the very beginning of the line. However, this mode has its pitfalls, especially for beginners. As most of the commands look just like ordinary identifiers, you may run into situations where the beginning of an expression or definition to be typed at the prompt can be mistaken for a command word. In such cases the default mode requires that you insert one or more spaces at the beginning of the line, so that the interpreter reads the line as normal Pure code. Unfortunately, it’s much too easy to forget this if you’re not familiar with the command language.</p>
<p>Therefore there is an alternative <strong>escape mode</strong> available which handles special command input more like some other popular programming language interpreters. In escape mode <em>all</em> interactive commands have to be escaped by prefixing them with a special character at the very beginning of the line. The command itself must follow the prefix character, without any intervening whitespace. Any line not prefixed with the prefix character will then be considered normal Pure code. This mode can be enabled with the <a href="#cmdoption-pure--escape"><code>--escape</code></a> option, which takes the desired prefix character as an argument, or you can just set the <a href="#envvar-PURE_ESCAPE"><code>PURE_ESCAPE</code></a> variable in your environment to enable escape mode by default.</p>
<p>For example, to set the escape character to ‘<code>:</code>’ you’ll invoke the interpreter as follows:</p>
<pre class="sourceCode console"><code>$ pure --escape=&#39;:&#39;</code></pre>
<p>Alternatively, you could also set the <a href="#envvar-PURE_ESCAPE"><code>PURE_ESCAPE</code></a> environment variable like this (using Bourne shell syntax):</p>
<pre class="sourceCode console"><code>$ export PURE_ESCAPE=&#39;:&#39;</code></pre>
<p>Note that specifying the prefix character with the <a href="#cmdoption-pure--escape"><code>--escape</code></a> option overrides the value of the environment variable, and only the initial character in the value of <a href="#cmdoption-pure--escape"><code>--escape</code></a> or <a href="#envvar-PURE_ESCAPE"><code>PURE_ESCAPE</code></a> will be used. If the specified value is empty, the interpreter reverts to the default mode. The following prefix characters can be used: <code>!$%&amp;*,:&lt;&gt;@\|</code>. Note that these all belong to 7 bit ASCII, and only some of the ASCII punctuation characters are permitted in order to prevent conflicts with ordinary Pure code. In any case, all of these characters <em>can</em> also occur in ordinary Pure code, so you should use a prefix that you aren’t likely to type at the beginning of a line in your usual coding style.</p>
<p>Many Pure programmers prefer escape mode, and in fact we recommend it for Pure novices even though it’s not the default (yet). Others may prefer default mode because it’s less effort to type. For the manual we stick to the default mode syntax. This means that if you’re running the interpreter in escape mode then you’ll have to do the necessary translation of the command syntax yourself. For instance, if the manual tells you to type the following command,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show foldl</code></pre></div>
<p>and you are using ‘<code>:</code>’ as the command prefix, then you will have to type this in escape mode instead:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; :show foldl</code></pre></div>
<p>Note that in this case ‘<code>!</code>’ continues to serve as a shell escape:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ! find . &#39;*.pure&#39;</code></pre></div>
<p>This will not work, however, if you use ‘<code>!</code>’ as your command prefix. In this case you will have to type <em>two</em> exclamation marks instead (the same caveat applies if you escape a shell command in the debugger, cf. <a href="#debugging">Debugging</a>):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; !! find . &#39;*.pure&#39;</code></pre></div>
<p>This should be rather straightforward, so in the following we just use the default mode command syntax throughout without further notice.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> Escape mode only applies to the interactive command line. It doesn’t affect the <a href="purelib.html#evalcmd"><code>evalcmd</code></a> function in any way, so interactive commands in the string argument of <a href="purelib.html#evalcmd"><code>evalcmd</code></a> are always specified without the escape character prefix no matter which mode the interpreter is running in.</p>
</blockquote>
<hr />
<h3 id="online-help">Online Help</h3>
<p>Online help is available in the interpreter with the interactive <code>help</code> command, which gives you access to all the available documentation in html format; this includes the present manual, the <a href="purelib.html">Pure Library Manual</a>, as well as all manuals of the addon modules available from the Pure website.</p>
<p>You need to have a html browser installed to make this work. By default, the <code>help</code> command uses <strong>w3m</strong>, but you can change this by setting either the <a href="#envvar-PURE_HELP"><code>PURE_HELP</code></a> or the <a href="#envvar-BROWSER"><code>BROWSER</code></a> environment variable accordingly.</p>
<p>When invoked without arguments, the <code>help</code> command displays an overview of the available documentation, from which you can follow the links to the provided manuals:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help</code></pre></div>
<p>(If the interpreter gives you an error message when you do this then you haven’t installed the documentation yet. The complete set of manuals is provided as a separate package at the Pure website, please see the Pure installation instructions for details.)</p>
<p>The <code>help</code> command also accepts a parameter which lets you specify a search term which is looked up in the global index, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help foldl</code></pre></div>
<p>Besides Pure functions, macros, variables and constants described in the manual you can also look up program options and environment variables, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help -x
&gt; help pure-gen -x
&gt; help PURE_STACK</code></pre></div>
<p>(Note that you can specify the program name to disambiguate between options for different utilities, such as the <code>-x</code> option which is accepted both by the Pure interpreter and the <code>pure-gen</code> program.)</p>
<p>If the search term doesn’t appear in the index, it is assumed to be a topic (a link target, usually a section title) in the Pure manual. Note that the <a href="http://docutils.sourceforge.net/">docutils</a> tools used to generate the html source of the Pure documentation mangle the section titles so that they are in lowercase and blanks are replaced with hyphens. So to look up the present section in this manual you’d have to type:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help online-help</code></pre></div>
<p>The help files are in html format and located in the docs subdirectory of the Pure library directory (i.e., /usr/local/lib/pure/docs by default). You can look up topics in any of the help files with a command like the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help pure-gsl#matrices</code></pre></div>
<p>Here <code>pure-gsl</code> is the basename of the help file (library path and .html suffix are supplied automatically), and <code>matrices</code> is a link target in that document. To just read the pure-gsl.html file without specifying a target, type the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help pure-gsl#</code></pre></div>
<p>(Note that just <code>help pure-gsl</code> won’t work, since it would look for a search term in the index or a topic in the Pure manual.)</p>
<p>Last but not least, you can also point the help browser to any html document (either a local file or some website) denoted by a proper URL, provided that your browser program can handle these. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; help file:mydoc.html#foo
&gt; help http:<span class="co">//purelang.bitbucket.org</span></code></pre></div>
<p><a name="commands"></a></p>
<h3 id="interactive-commands">Interactive Commands</h3>
<p>The following built-in commands are always understood by the interpreter. (In addition, you can define your own commands for frequently-used operations; see <a href="#user-defined-commands">User-Defined Commands</a> below.)</p>
<dl>
<dt><code>! command</code></dt>
<dd>Shell escape.
</dd>
<dt><code>break [symbol ...]</code></dt>
<dd>Sets breakpoints on the given function or operator symbols. All symbols must be specified in fully qualified form, see the remarks below. If invoked without arguments, prints all currently defined breakpoints. This requires that the interpreter was invoked with the <a href="#cmdoption-pure-g"><code>-g</code></a> option to enable debugging support. See <a href="#debugging">Debugging</a> below for details.
</dd>
<dt><code>bt</code></dt>
<dd>Prints a full backtrace of the call sequence of the most recent evaluation, if that evaluation ended with an unhandled exception. This requires that the interpreter was invoked with the <a href="#cmdoption-pure-g"><code>-g</code></a> option to enable debugging support. See <a href="#debugging">Debugging</a> below for details.
</dd>
<dt><code>cd dir</code></dt>
<dd>Change the current working dir.
</dd>
<dt><code>clear [option ...] [symbol ...]</code></dt>
<dd>Purge the definitions of the given symbols (functions, macros, constants or global variables). All symbols must be specified in fully qualified form, see the remarks below. If invoked as <code>clear ans</code>, clears the <a href="purelib.html#ans"><code>ans</code></a> value (see <a href="#last-result">Last Result</a> below). When invoked without any arguments, <code>clear</code> purges all definitions at the current interactive “level” (after confirmation) and returns you to the previous level, if any. (It might be a good idea to first check your current definitions with <code>show</code> or back them up with <code>dump</code> before you do that.) The desired level can be specified with the <code>-t</code> option. See the description of the <code>save</code> command and <a href="#definition-levels">Definition Levels</a> below for further details. A description of the common options accepted by the <code>clear</code>, <code>dump</code> and <code>show</code> commands can be found in <a href="#specifying-symbol-selections">Specifying Symbol Selections</a> below.
</dd>
<dt><code>del [-b|-m|-t] [symbol ...]</code></dt>
<dd><p>Deletes breakpoints and tracepoints on the given function or operator symbols. If the <code>-b</code> option is specified then only breakpoints are deleted; similarly, <code>del -t</code> only deletes tracepoints. If none of these are specified then both breakpoints and tracepoints are deleted. All symbols must be specified in fully qualified form, see the remarks below. If invoked without non-option arguments, <code>del</code> clears <em>all</em> currently defined breakpoints and/or tracepoints (after confirmation); see <a href="#debugging">Debugging</a> below for details.</p>
<p>The <code>-m</code> option works similarly to <code>-t</code>, but deletes macro rather than function tracepoints, see the description of the <code>trace</code> command below.</p>
</dd>
<dt><code>dump [-n filename] [option ...] [symbol ...]</code></dt>
<dd><p>Dump a snapshot of the current function, macro, constant and variable definitions in Pure syntax to a text file. All symbols must be specified in fully qualified form, see the remarks below. This works similar to the <code>show</code> command (see below), but writes the definitions to a file. The default output file is .pure in the current directory, which is then reloaded automatically the next time the interpreter starts up in interactive mode in the same directory. This provides a quick-and-dirty way to save an interactive session and have it restored later, but note that this isn’t perfect. In particular, declarations of <a href="#extern"><code>extern</code></a> symbols won’t be saved unless they’re specified explicitly, and some objects like closures, thunks and pointers don’t have a textual representation from which they could be reconstructed. To handle these, you’ll probably have to prepare a corresponding .purerc file yourself, see <a href="#interactive-startup">Interactive Startup</a> below.</p>
<p>A different filename can be specified with the <code>-n</code> option, which expects the name of the script to be written in the next argument, e.g: <code>dump -n myscript.pure</code>. You can then edit that file and use it as a starting point for an ordinary script or a .purerc file, or you can just run the file with the <code>run</code> command (see below) to restore the definitions in a subsequent interpreter session.</p>
</dd>
<dt><code>help [topic]</code></dt>
<dd>Display online documentation. If a topic is given, it is looked up in the index. Alternatively, you can also specify a link target in any of the installed help files, or any other html document denoted by a proper URL. Please see <a href="#online-help">Online Help</a> above for details.
</dd>
<dt><code>ls [args]</code></dt>
<dd>List files (shell <code>ls</code> command).
</dd>
<dt><code>mem</code></dt>
<dd>Print current memory usage. This reports the number of expression cells currently in use by the program, along with the size of the freelist (the number of allocated but currently unused expression cells). Note that the actual size of the expression storage may be somewhat larger than this, since the runtime always allocates expression memory in bigger chunks. Also, this figure does not reflect other heap-allocated memory in use by the program, such as strings or malloc’ed pointers.
</dd>
<dt><code>override</code></dt>
<dd>Enter “override” mode. This allows you to add equations “above” existing definitions in the source script, possibly overriding existing equations. See <a href="#definition-levels">Definition Levels</a> below for details.
</dd>
<dt><code>pwd</code></dt>
<dd>Print the current working dir (shell <code>pwd</code> command).
</dd>
<dt><code>quit</code></dt>
<dd>Exits the interpreter.
</dd>
<dt><code>run [-g|script]</code></dt>
<dd><p>When invoked without arguments or with the <code>-g</code> option, <code>run</code> does a “cold” restart of the interpreter, with the scripts and options given on the interpreter’s original command line. If just <code>-g</code> is specified as the argument, the interpreter is run with debugging enabled. Otherwise the interpreter is invoked without debugging support. (This overrides the corresponding option from the interpreter’s command line.) This command provides a quick way to rerun the interpreter after changes in some of the loaded script files, or if you want to enable or disable debugging on the fly (which requires a restart of the interpreter). You’ll also loose any definitions that you entered interactively in the interpreter, so you may want to back them up with <code>dump</code> beforehand.</p>
<p>When invoked with a script name as argument, <code>run</code> loads the given script file and adds its definitions to the current environment. This works more or less like a <a href="#using"><code>using</code></a> clause, but only searches for the script in the current directory and places the definitions in the script at the current temporary level, so that <code>clear</code> can be used to remove them again. Also note that namespace and pragma settings of scripts loaded with <code>run</code> stick around after loading the script. This allows you to quickly set up your environment by just running a script containing the necessary namespace declarations and compiler directives. (Alternatively, you can also use the interpreter’s startup files for that purpose, see <a href="#interactive-startup">Interactive Startup</a> below.)</p>
</dd>
<dt><code>save</code></dt>
<dd>Begin a new level of temporary definitions. A subsequent <code>clear</code> command (see above) will purge the definitions made since the most recent <code>save</code> command. See <a href="#definition-levels">Definition Levels</a> below for details.
</dd>
<dt><code>show [option ...] [symbol ...]</code></dt>
<dd>Show the definitions of symbols in various formats. See <a href="#the-show-command">The show Command</a> below for details. All symbols must be specified in fully qualified form, see the remarks below. A description of the common options accepted by the <code>clear</code>, <code>dump</code> and <code>show</code> commands can be found in <a href="#specifying-symbol-selections">Specifying Symbol Selections</a> below.
</dd>
<dt><code>stats [-m] [on|off]</code></dt>
<dd>Enables (default) or disables “stats” mode, in which some statistics are printed after an expression has been evaluated. Invoking just <code>stats</code> or <code>stats on</code> only prints the cpu time in seconds for each evaluation. If the <code>-m</code> option is specified, memory usage is printed along with the cpu time, which indicates the maximum amount of expression memory (in terms of expression cells) used during the computation. Invoking <code>stats off</code> disables stats mode, while <code>stats -m off</code> just disables the printing of the memory usage statistics.
</dd>
<dt><code>trace [-a] [-m] [-r] [-s] [symbol ...]</code></dt>
<dd><p>Sets tracepoints on the given function or operator symbols. Without the <code>-m</code> option, this works pretty much like the <code>break</code> command (see above) but only prints rule invocations and reductions without actually interrupting the evaluation; see <a href="#debugging">Debugging</a> below for details.</p>
<p>The <code>-m</code> option allows you to trace macro (rather than function) calls. If this option is specified, the compiler prints reduction sequences involving the given macro symbol, which is useful when debugging macros; see the <a href="#macros">Macros</a> section for details and examples. Note that macro tracing works even if the interpreter was invoked without debugging mode.</p>
<p>If the <code>-a</code> option is specified, tracepoints are set on <em>all</em> global function or macro symbols, respectively (in this case the symbol arguments are ignored). This is convenient if you want to see any and all reductions performed in a computation.</p>
<p>Tracing can actually be performed in two different modes, <em>recursive</em> mode in which the trace is triggered by any of the active tracepoints and continues until the corresponding call is finished, or <em>skip</em> mode in which <em>only</em> calls by the active tracepoints are reported. The former is usually more helpful and is the default. The <code>-s</code> option allows you to switch to skip mode, while the <code>-r</code> option switches back to recursive mode.</p>
<p>Finally, if neither symbols nor any of the <code>-a</code>, <code>-r</code> and <code>-s</code> options are specified then the currently defined tracepoints are printed. Note that, as with the <code>break</code> command, existing tracepoints can be deleted with the <code>del</code> command (see above).</p>
</dd>
<dt><code>underride</code></dt>
<dd>Exits “override” mode. This returns you to the normal mode of operation, where new equations are added “below” previous rules of an existing function. See <a href="#definition-levels">Definition Levels</a> below for details.
</dd>
</dl>
<!-- -->
<p>Commands that accept options generally also understand the <code>-h</code> (help) option which prints a brief summary of the command syntax and the available options.</p>
<p>Note that symbols (identifiers, operators etc.) must always be specified in fully qualified form. No form of namespace lookup is performed by commands like <code>break</code>, <code>clear</code>, <code>show</code> etc. Thus the specified symbols always work the same no matter what <code>namespace</code> and <code>using namespace</code> declarations are currently in effect.</p>
<p>Besides the commands listed above, the interpreter also provides some special commands for the benefit of other programs such as <strong>emacs</strong> driving the interpreter; currently these are <code>completion_matches</code>, <code>help_matches</code> and <code>help_index</code>. These aren’t supposed to be invoked directly by the user, although they may sometimes be useful to implement custom functionality, see <a href="#user-defined-commands">User-Defined Commands</a>.</p>
<h3 id="specifying-symbol-selections">Specifying Symbol Selections</h3>
<p>The <code>clear</code>, <code>dump</code> and <code>show</code> commands all accept the following options for specifying a subset of symbols and definitions on which to operate. All symbols must be specified in fully qualified form. Options may be combined, thus, e.g., <code>show -mft</code> is the same as <code>show -m -f -t</code>. Some options specify optional numeric parameters; these must follow immediately behind the option character if present, as in <code>-t0</code>.</p>
<dl>
<dt><code>-c</code></dt>
<dd><p>Select defined constants.</p>
</dd>
<dt><code>-f</code></dt>
<dd><p>Select defined functions.</p>
</dd>
<dt><code>-g</code></dt>
<dd><p>Indicates that the following symbols are actually shell glob patterns and that all matching symbols should be selected.</p>
</dd>
<dt><code>-m</code></dt>
<dd><p>Select defined macros.</p>
</dd>
<dt><code>-pflag</code></dt>
<dd><p>Select only private symbols if <em>flag</em> is nonzero (the default), otherwise (<em>flag</em> is zero) select only public symbols. If this option is omitted then both private and public symbols are selected.</p>
</dd>
<dt><code>-tlevel</code></dt>
<dd><p>Select symbols and definitions at the given “level” of definitions and above. This is described in more detail below. Briefly, the executing program and all imported modules (including the prelude) are at level 0, while “temporary” definitions made interactively in the interpreter are at level 1 and above. Thus a level of 1 restricts the selection to all temporary definitions, whereas 0 indicates all definitions (i.e., everything, including the prelude). If <em>level</em> is omitted, it defaults to the current definitions level.</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>Select defined variables.</p>
</dd>
<dt><code>-y</code></dt>
<dd><p>Select defined types.</p>
</dd>
</dl>
<p>In addition, the <code>-h</code> option prints a short help message describing all available options of the command at hand.</p>
<p>If none of the <code>-c</code>, <code>-f</code>, <code>-m</code>, <code>-v</code> and <code>-y</code> options are specified, then all kinds of symbols (constants, functions, macros, variables and types) are selected, otherwise only the specified categories will be considered.</p>
<p>A reasonable default is used if the <code>-t</code> option is omitted. By default, if no symbols are specified, only temporary definitions are considered, which corresponds to <code>-t1</code>. Otherwise the command applies to all corresponding definitions, no matter whether they belong to the executing program, the prelude, or some temporary level, which has the same effect as <code>-t0</code>. This default choice can be overridden by specifying the desired level explicitly.</p>
<p>As a special case, just <code>clear</code> (without any other options or symbol arguments) always backs out to the previous definitions level (instead of level #1). This is inconsistent with the rules set out above, but is implemented this way for convenience and backward compatibility. Thus, if you really want to delete all your temporary definitions, use <code>clear -t1</code> instead. When used in this way, the <code>clear</code> command will only remove temporary definitions; if you need to remove definitions at level #0, you must specify those symbols explicitly.</p>
<p>Note that <code>clear -g *</code> will have pretty much the same disastrous consequences as the Unix command <code>rm -rf *</code>, so don’t do that. Also note that a macro or function symbol may well have defining equations at different levels, in which case a command like <code>clear -tn foo</code> might only affect some part of <code>foo</code>’s definition. The <code>dump</code> and <code>show</code> commands work analogously (albeit less destructively). See <a href="#definition-levels">Definition Levels</a> below for some examples.</p>
<h3 id="the-show-command">The show Command</h3>
<p>The <code>show</code> command can be used to obtain information about defined symbols in various formats. Besides the common selection options discussed above, this command recognizes the following additional options for specifying the content to be listed and the format to use.</p>
<dl>
<dt><code>-a</code></dt>
<dd><p>Disassembles pattern matching automata. Works like the <code>-v4</code> option of the interpreter.</p>
</dd>
<dt><code>-d</code></dt>
<dd><p>Disassembles LLVM IR, showing the generated LLVM assembler code of a function. Works like the <code>-v8</code> option of the interpreter.</p>
</dd>
<dt><code>-e</code></dt>
<dd><p>Annotate printed definitions with lexical environment information (de Bruijn indices, subterm paths). Works like the <code>-v2</code> option of the interpreter.</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>Long format, prints definitions along with the summary symbol information. This implies <code>-s</code>.</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>Summary format, print just summary information about listed symbols.</p>
</dd>
</dl>
<p>Symbols are always listed in lexicographic order. Note that some of the options (in particular, <code>-a</code> and <code>-d</code>) may produce excessive amounts of information. By setting the <a href="#envvar-PURE_MORE"><code>PURE_MORE</code></a> environment variable, you can specify a shell command to be used for paging, usually <code>more</code> or <code>less</code>.</p>
<p>For instance, to list all temporary definitions made in an interactive session, simply say:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show</code></pre></div>
<p>You can also list a specific symbol, no matter whether it comes from the interactive command line, the executing script or the prelude:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show foldl
foldl f a x::<span class="dt">matrix</span> = foldl f a (list x);
foldl f a s::<span class="dt">string</span> = foldl f a (chars s);
foldl f a [] = a;
foldl f a (x:xs) = foldl f (f a x) xs;</code></pre></div>
<p>Wildcards can be used with the <code>-g</code> option, which is useful if you want to print an entire family of related functions, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show -g foldl*
foldl f a x::<span class="dt">matrix</span> = foldl f a (list x);
foldl f a s::<span class="dt">string</span> = foldl f a (chars s);
foldl f a [] = a;
foldl f a (x:xs) = foldl f (f a x) xs;
foldl1 f x::<span class="dt">matrix</span> = foldl1 f (list x);
foldl1 f s::<span class="dt">string</span> = foldl1 f (chars s);
foldl1 f (x:xs) = foldl f x xs;</code></pre></div>
<p>Or you can just specify multiple symbols as follows (this also works with multiple glob patterns when you add the <code>-g</code> option):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show min max
max x y = <span class="kw">if</span> x&gt;=y <span class="kw">then</span> x <span class="kw">else</span> y;
min x y = <span class="kw">if</span> x&lt;=y <span class="kw">then</span> x <span class="kw">else</span> y;</code></pre></div>
<p>You can also select symbols by category. E.g., the following command shows summary information about all the variable symbols along with their current values (using the “long” format):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show -lvg *
argc       var  argc = <span class="dv">0</span>;
argv       var  argv = [];
compiling  var  compiling = <span class="dv">0</span>;
sysinfo    var  sysinfo = <span class="st">&quot;x86_64-unknown-linux-gnu&quot;</span>;
version    var  version = <span class="st">&quot;0.66&quot;</span>;
<span class="dv">5</span> variables</code></pre></div>
<p>Or you can list just private symbols of the namespace <code>foo</code>, as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show -pg foo::*</code></pre></div>
<p>The following command will list each and every symbol that’s currently defined (instead of <code>-g *</code> you can also use the <code>-t0</code> option):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show -g *</code></pre></div>
<p>This usually produces a lot of output and is rarely needed, unless you’d like to browse through an entire program including all library imports. (In that case you might consider to use the <code>dump</code> command instead, which writes the definitions to a file which can then be loaded into a text editor for easier viewing. This may occasionally be useful for debugging purposes.)</p>
<p>The <code>show</code> command also has the following alternate forms which are used for special purposes:</p>
<ul>
<li><p><code>show interface</code> lists the actual <a href="#type"><code>type</code></a> rules for an interface type. This is useful if you want to verify which patterns will be matched by an interface type, see <a href="#interface-types">Interface Types</a> for details. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">interface</span> stack <span class="kw">with</span>
&gt;   push xs::stack x;
&gt;   pop xs::stack;
&gt;   top xs::stack;
&gt; <span class="kw">end</span>;
&gt; push xs@[] x |
&gt; push xs@(_:_) x = x:xs;
&gt; pop (x:xs) = xs;
&gt; top (x:xs) = x;
&gt; show <span class="kw">interface</span> stack
<span class="kw">type</span> stack xs@(_:_);
&gt; pop [] = <span class="fu">throw</span> <span class="st">&quot;empty stack&quot;</span>;
&gt; top [] = <span class="fu">throw</span> <span class="st">&quot;empty stack&quot;</span>;
&gt; show <span class="kw">interface</span> stack
<span class="kw">type</span> stack xs@[];
<span class="kw">type</span> stack xs@(_:_);</code></pre></div></li>
<li><p><code>show namespace</code> lists the current and search namespaces, while <code>show namespaces</code> lists all declared namespaces. These come in handy if you have forgotten what namespaces are currently active and which other namespaces are available in your program. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show <span class="kw">namespace</span>
&gt; show namespaces
<span class="kw">namespace</span> C;
<span class="kw">namespace</span> <span class="dt">matrix</span>;
&gt; <span class="kw">using</span> <span class="kw">namespace</span> C;
&gt; <span class="kw">namespace</span> my;
&gt; show <span class="kw">namespace</span>
<span class="kw">namespace</span> my;
<span class="kw">using</span> <span class="kw">namespace</span> C;</code></pre></div></li>
</ul>
<h3 id="definition-levels">Definition Levels</h3>
<p>To help with incremental development, the interpreter offers some commands to manipulate the current set of definitions interactively. To these ends, definitions are organized into different subsets called <strong>levels</strong>. As already mentioned, the prelude, as well as other source programs specified when invoking the interpreter, are always at level 0, while the interactive environment starts at level 1. Each <code>save</code> command introduces a new temporary level, and each subsequent <code>clear</code> command (without any arguments) “pops” the definitions on the current level and returns you to the previous one (if any). This gives you a “stack” of temporary environments which enables you to “plug and play” in a (more or less) safe fashion, without affecting the rest of your program.</p>
<p>For all practical purposes, this stack is unlimited, so that you can create as many levels as you like. However, this facility also has its limitations. The interpreter doesn’t really keep a full history of everything you entered interactively, it only records the level a variable, constant, and function or macro rule belongs to so that the corresponding definitions can be removed again when the level is popped. On the other hand, intermediate changes in variable values are not recorded anywhere and cannot be undone. Moreover, global declarations (which encompasses <a href="#using"><code>using</code></a> clauses, <a href="#extern"><code>extern</code></a> declarations and special symbol declarations) always apply to all levels, so they can’t be undone either.</p>
<p>That said, the temporary levels can still be pretty useful when you’re playing around with the interpreter. Here’s a little example which shows how to use <code>clear</code> to quickly get rid of a definition that you entered interactively:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo (x:xs) = x+foo xs;
&gt; foo [] = <span class="dv">0</span>;
&gt; show
foo (x:xs) = x+foo xs;
foo [] = <span class="dv">0</span>;
&gt; foo (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">55</span>
&gt; clear
This will clear all temporary definitions at level #<span class="dv">1</span>.
Continue (y/n)? y
&gt; show
&gt; foo (<span class="dv">1</span>..<span class="dv">10</span>);
foo [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</code></pre></div>
<p>We’ve seen already that normally, if you enter a sequence of equations, they will be recorded in the order in which they were written. However, it is also possible to override definitions in lower levels with the <code>override</code> command:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo (x:xs) = x+foo xs;
&gt; foo [] = <span class="dv">0</span>;
&gt; show
foo (x:xs) = x+foo xs;
foo [] = <span class="dv">0</span>;
&gt; foo (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">55</span>
&gt; save
save: now at temporary definitions level #<span class="dv">2</span>
&gt; override
&gt; foo (x:xs) = x*foo xs;
&gt; show
foo (x:xs) = x*foo xs;
foo (x:xs) = x+foo xs;
foo [] = <span class="dv">0</span>;
&gt; foo (<span class="dv">1</span>..<span class="dv">10</span>);
warning: rule never reduced: foo (x:xs) = x+foo xs;
<span class="dv">0</span></code></pre></div>
<p>Note that the equation <code>foo (x:xs) = x*foo xs</code> was inserted before the previous rule <code>foo (x:xs) = x+foo xs</code>, which is at level #1. (The latter equation is now “shadowed” by the rule we just entered, hence the compiler warns us that this rule can’t be reduced any more.)</p>
<p>Even in override mode, new definitions will be added after other definitions at the <em>current</em> level. This allows us to just continue adding more high-priority definitions overriding lower-priority ones:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo [] = <span class="dv">1</span>;
&gt; show
foo (x:xs) = x*foo xs;
foo [] = <span class="dv">1</span>;
foo (x:xs) = x+foo xs;
foo [] = <span class="dv">0</span>;
&gt; foo (<span class="dv">1</span>..<span class="dv">10</span>);
warning: rule never reduced: foo (x:xs) = x+foo xs;
warning: rule never reduced: foo [] = <span class="dv">0</span>;
<span class="dv">3628800</span></code></pre></div>
<p>Again, the new equation was inserted above the existing lower-priority rules, but below our previous equation <code>foo (x:xs) = x*foo xs</code> entered at the same level. As you can see, we have now effectively replaced our original definition of <code>foo</code> with a version that calculates list products instead of sums, but of course we can easily go back one level to restore the previous definition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear
This will clear all temporary definitions at level #<span class="dv">2</span>.
Continue (y/n)? y
clear: now at temporary definitions level #<span class="dv">1</span>
clear: override mode is on
&gt; show
foo (x:xs) = x+foo xs;
foo [] = <span class="dv">0</span>;
&gt; foo (<span class="dv">1</span>..<span class="dv">10</span>);
<span class="dv">55</span></code></pre></div>
<p>Note that <code>clear</code> reminded us that override mode is still enabled (<code>save</code> will do the same if override mode is on while pushing a new definitions level). To turn it off again, use the <code>underride</code> command. This will revert to the normal behaviour of adding new equations below existing ones:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; underride</code></pre></div>
<p>It’s also possible to use <code>clear</code> to back out multiple levels at once, if you specify the target level to be cleared with the -t option. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; save
save: now at temporary definitions level #<span class="dv">2</span>
&gt; <span class="kw">let</span> bar = <span class="dv">99</span>;
&gt; show
<span class="kw">let</span> bar = <span class="dv">99</span>;
foo (x:xs) = x+foo xs;
foo [] = <span class="dv">0</span>;
&gt; <span class="co">// this scraps all our scribblings!</span>
&gt; clear -t1
This will clear all temporary definitions at level #<span class="dv">1</span> and above.
Continue (y/n)? y
clear: now at temporary definitions level #<span class="dv">1</span>
&gt; show
&gt; </code></pre></div>
<p>The facilities described above are also available to Pure programs, as the <code>save</code> and <code>clear</code> commands can also be executed under program control using the <a href="purelib.html#evalcmd"><code>evalcmd</code></a> primitive. Conversely, the library provides its own functions for inspecting and manipulating the source program, which may also be useful in custom command definitions; see the <a href="purelib.html">Pure Library Manual</a> for details.</p>
<p><a name="debugging"></a></p>
<h3 id="debugging">Debugging</h3>
<p>The interpreter provides a simple but reasonably convenient symbolic debugging facility when running interactively. To make this work, you have to specify the <a href="#cmdoption-pure-g"><code>-g</code></a> option when invoking the interpreter (<code>pure -g</code>). If you’re already at the interpreter’s command line, you can also use the <code>run -g</code> command to enable the debugger. The <code>-g</code> option disables tail call optimization (see <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>) to make it easier to debug programs. It also causes special debugging code to be generated which will make your program run <em>much</em> slower. Therefore the <a href="#cmdoption-pure-g"><code>-g</code></a> option should only be used if you actually need the debugger.</p>
<p>One common use of the debugger is “post mortem” debugging after an evaluation ended with an unhandled exception. In such a case, the <code>bt</code> command of the interpreter prints a backtrace of the call sequence which caused the exception. Note that this only works if debugging mode was enabled. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; [<span class="dv">1</span>,<span class="dv">2</span>]!<span class="dv">3</span>;
&lt;stdin&gt;, line <span class="dv">2</span>: unhandled exception &#39;out_of_bounds&#39; while evaluating &#39;[<span class="dv">1</span>,<span class="dv">2</span>]!<span class="dv">3</span>&#39;
&gt; bt
   [<span class="dv">1</span>] (!): (x:xs)!n::<span class="dt">int</span> = xs!(n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
     n = <span class="dv">3</span>; x = <span class="dv">1</span>; xs = [<span class="dv">2</span>]
   [<span class="dv">2</span>] (!): (x:xs)!n::<span class="dt">int</span> = xs!(n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
     n = <span class="dv">2</span>; x = <span class="dv">2</span>; xs = []
   [<span class="dv">3</span>] (!): []!n::<span class="dt">int</span> = <span class="fu">throw</span> out_of_bounds;
     n = <span class="dv">1</span>
&gt;&gt; [<span class="dv">4</span>] <span class="fu">throw</span>: <span class="kw">extern</span> <span class="dt">void</span> pure_throw(<span class="dt">expr</span>*) = <span class="fu">throw</span>;
     x1 = out_of_bounds</code></pre></div>
<p>The last call, which is also marked with the <code>&gt;&gt;</code> symbol, is the call that raised the exception. The format is similar to the <code>p</code> command of the debugger, see below, but <code>bt</code> always prints a full backtrace. (As with the <code>show</code> command of the interpreter, you can set the <a href="#envvar-PURE_MORE"><code>PURE_MORE</code></a> environment variable to pipe the output through the corresponding command, or use <a href="purelib.html#evalcmd"><code>evalcmd</code></a> to capture the output of <code>bt</code> in a string.)</p>
<p>The debugger can also be used interactively. To these ends, you can set breakpoints on functions with the <code>break</code> command. The debugger then gets invoked as soon as a rule for one of the given functions is executed. Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
&gt; break fact
&gt; fact <span class="dv">1</span>;
** [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
(Type &#39;h&#39; for help.)
:
** [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
:
++ [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
     --&gt; <span class="dv">1</span>
** [<span class="dv">2</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
:
++ [<span class="dv">2</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
     --&gt; <span class="dv">1</span>
++ [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
     --&gt; <span class="dv">1</span>
<span class="dv">1</span></code></pre></div>
<p>Lines beginning with <code>**</code> indicate that the evaluation was interrupted to show the rule (or external) which is currently being considered, along with the current depth of the call stack, the invoked function and the values of parameters and other local variables in the current lexical environment. In contrast, the prefix <code>++</code> denotes reductions which were actually performed during the evaluation and the results that were returned by the function call (printed as <code>--&gt; return value</code>).</p>
<p>Sometimes you might also see funny symbols like <code>#&lt;closure&gt;</code>, <code>#&lt;case&gt;</code> or <code>#&lt;when&gt;</code> instead of the function name. These indicate lambdas and the special variable-binding environments, which are all implemented as anonymous closures in Pure. Also note that the debugger doesn’t know about the argument names of external functions (which are optional in Pure and not recorded anywhere), so it will display the generic names <code>x1</code>, <code>x2</code> etc. instead.</p>
<p>At the debugger prompt ‘<code>:</code>’ you can enter various special debugger commands, or just keep on hitting the carriage return key to walk through an evaluation step by step, as we did in the example above. (Command line editing works as usual at the debugger prompt, if it is enabled.) The usual commands are provided to walk through an evaluation, print and navigate the call stack, step over the current call, or continue the evaluation unattended until you hit another breakpoint. If you know other source level debuggers like <strong>gdb</strong> then you should feel right at home. You can type <code>h</code> at the debugger prompt to print the following list:</p>
<pre class="sourceCode none"><code>: h
Debugger commands:
a       auto: step through the entire program, run unattended
c [f]   continue until next breakpoint, or given function f
h       help: print this list
n       next step: step over reduction
p [n]   print rule stack (n = number of frames)
r       run: finish evaluation without debugger
s       single step: step into reduction
t, b    move to the top or bottom of the rule stack
u, d    move up or down one level in the rule stack
x       exit the interpreter (after confirmation)
.       reprint current rule
! cmd   execute interpreter command
? expr  evaluate expression
&lt;cr&gt;    single step (same as &#39;s&#39;)
&lt;eof&gt;   step through program, run unattended (same as &#39;a&#39;)</code></pre>
<hr />
<blockquote>
<p><strong>Note:</strong> If you specified an <a href="#cmdoption-pure--escape"><code>--escape</code></a> prefix other than ‘<code>!</code>’ (cf. <a href="#command-syntax">Command Syntax</a>), that prefix will be used to execute interpreter commands instead, see below. The help message will tell you which command prefix is in effect.</p>
</blockquote>
<hr />
<p>The command syntax is very simple. Besides the commands listed above you can also enter comment lines (<code>// comment text</code>) which will just be ignored. Extra arguments on commands which don’t expect any will generally be ignored as well. The single letter commands all have to be separated from any additional parameters with whitespace, whereas the ‘<code>!</code>’, ‘<code>?</code>’ and ‘<code>.</code>’ commands count as word delimiters and can thus be followed immediately by an argument. For convenience, the ‘<code>?</code>’ command can also be omitted if the expression to be evaluated doesn’t start with a single letter or one of the special punctuation commands.</p>
<p>The debugger can be exited or suspended in the following ways:</p>
<ul>
<li>You can type <code>c</code> to continue the evaluation until the next breakpoint, or <code>c foo</code> in order to proceed until the debugger hits an invocation of the function <code>foo</code>.</li>
<li>You can type <code>r</code> to run the rest of the evaluation without the debugger.</li>
<li>The <code>a</code> (“auto”) command single-steps through the rest of the evaluation, running unattended. This command can also be entered by just hitting the end-of-file key (<code>Ctrl-d</code> on Unix systems) at the debugger prompt.</li>
<li>You can also type <code>x</code> to exit from the debugger <em>and</em> the interpreter immediately (after confirmation).</li>
</ul>
<p>In addition, you can use the <code>!</code> command (or whatever command prefix has been set with the <a href="#cmdoption-pure--escape"><code>--escape</code></a> option) to run any interpreter command while in the debugger. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">: !ls</code></pre></div>
<p>This is particularly useful to invoke the <code>break</code> and <code>del</code> commands to change breakpoints. Note that you can actually escape any valid input to the interpreter that way, not just the special interactive commands. However, you shouldn’t try to modify the program while you’re debugging it. This may work in some cases, but will have nasty consequences if you happen to change a function which is currently being executed.</p>
<p>The interpreter’s shell escape can also be used from the debugger. In default mode or when using <code>!</code> as the <a href="#cmdoption-pure--escape"><code>--escape</code></a> prefix, you’ll have to escape shell commands with <code>!!</code>, otherwise a single <code>!</code> suffices.</p>
<p>At the debugger prompt, you can use the <code>u</code> (“up”), <code>d</code> (“down”), <code>t</code> (“top”) and <code>b</code> (“bottom”) commands to move around on the current call stack. The <code>p</code> command prints a range of the call stack centered around the currently selected stack frame, which is indicated with the <code>&gt;&gt;</code> tag, whereas <code>**</code> denotes the current bottom of the stack (which is the rule to be executed with the single step command). The <code>p</code> command can also be followed by a numeric argument which indicates the number of stack frames to be printed (this will then become the default for subsequent invocations of <code>p</code>). The <code>n</code> command steps over the call selected with the stack navigation commands. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">3</span>;
** [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">3</span>
: c *
** [<span class="dv">4</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
: p
   [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">3</span>
   [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">2</span>
   [<span class="dv">3</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
** [<span class="dv">4</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
: u
&gt;&gt; [<span class="dv">3</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
: u
&gt;&gt; [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">2</span>
: p
   [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">3</span>
&gt;&gt; [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">2</span>
   [<span class="dv">3</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
** [<span class="dv">4</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
: n
++ [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">2</span>
     --&gt; <span class="dv">2</span>
** [<span class="dv">2</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">3</span>; y = <span class="dv">2</span>
:</code></pre></div>
<p>If you ever get lost, you can reprint the current rule with the ‘<code>.</code>’ command:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">: .
** [<span class="dv">2</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">3</span>; y = <span class="dv">2</span></code></pre></div>
<p>Another useful feature is the <code>?</code> command which lets you evaluate any Pure expression, with the local variables of the current rule bound to their corresponding values. Like the <code>n</code> command, <code>?</code> applies to the current stack frame as selected with the stack navigation commands. The expression must be entered on a single line, and the trailing semicolon is optional. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact <span class="dv">3</span>;
** [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">3</span>
: c *
** [<span class="dv">4</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
: ?x+y
<span class="dv">2</span>
: u
&gt;&gt; [<span class="dv">3</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
: n&gt;<span class="dv">0</span>, fact n
<span class="dv">1</span>,<span class="dv">1</span></code></pre></div>
<p>A third use of the debugger is to trace function calls. For that the interpreter provides the <code>trace</code> command which works similarly to <code>break</code>, but sets so-called “tracepoints” which only print rule invocations and reductions instead of actually interrupting the evaluation. For instance, assuming the same example as above, let’s first remove the breakpoint on <code>fact</code> (using the <code>del</code> command) and then set it as a tracepoint instead:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; del fact
&gt; trace fact
&gt; fact <span class="dv">1</span>;
** [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
** [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
++ [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
     --&gt; <span class="dv">1</span>
** [<span class="dv">2</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
++ [<span class="dv">2</span>] (*): x::<span class="dt">int</span>*y::<span class="dt">int</span> = x*y;
     x = <span class="dv">1</span>; y = <span class="dv">1</span>
     --&gt; <span class="dv">1</span>
++ [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
     --&gt; <span class="dv">1</span>
<span class="dv">1</span></code></pre></div>
<p>The <code>break</code> and <code>trace</code> commands can also be used in concert if you want to debug some functions while only tracing others.</p>
<p>Note that the <code>trace</code> command can actually be run in two different modes: <em>recursive</em> mode in which the trace is triggered by any of the active tracepoints and continues until the corresponding call is finished, or <em>skip</em> mode in which <em>only</em> calls by the active tracepoints are reported. The former is the default and is often preferable, because it gives you a complete transcript of the reductions performed during a function call.</p>
<p>If you don’t need that much detail, you can also switch to skip mode by invoking the <code>trace</code> command with the <code>-s</code> option. This allows you to see a quick summary of the computation which only shows reductions by rules directly involving the active tracepoints. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; trace -s
&gt; fact <span class="dv">1</span>;
** [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
** [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
++ [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
     --&gt; <span class="dv">1</span>
++ [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
     --&gt; <span class="dv">1</span>
<span class="dv">1</span></code></pre></div>
<p>Moreover, the <code>trace</code> command can also be invoked with the <code>-a</code> option to trace all function calls, which is convenient to quickly obtain a full transcript of a reduction sequence. The same options also work in an analogous fashion with macro calls, see the <a href="#macros">Macros</a> section for some examples.</p>
<p>The current sets of breakpoints and tracepoints can be changed with the <code>break</code>, <code>trace</code> and <code>del</code> commands, as shown above, and just <code>break</code> or <code>trace</code> without any arguments lists the currently defined breakpoints or tracepoints, respectively. Please see <a href="#interactive-commands">Interactive Commands</a> above for details. Also note that these are really interpreter commands, so to invoke them in the debugger you have to escape them with the <code>!</code> command (or whatever other <a href="#cmdoption-pure--escape"><code>--escape</code></a> prefix you specified).</p>
<p>The debugger can also be triggered programmatically with the built-in parameter-less functions <a href="purelib.html#__break__"><code>__break__</code></a> and <a href="purelib.html#__trace__"><code>__trace__</code></a>. This gives you much better control over the precise location and the conditions under which the debugger should be invoked. Just place a call to <a href="purelib.html#__break__"><code>__break__</code></a> or <a href="purelib.html#__trace__"><code>__trace__</code></a> near the point where you’d like to start debugging or tracing; this can be done either with the sequencing operator ‘<a href="#$$"><code>$$</code></a>’ or with a <a href="#when"><code>when</code></a> clause. The debugger will then be invoked at the next opportunity (usually when a function is called or a reduction is completed). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> <span class="fu">__break__</span> $$ n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
&gt; fact <span class="dv">10</span>;
++ [<span class="dv">2</span>] <span class="fu">__break__</span>: <span class="kw">extern</span> <span class="dt">void</span> pure_break() = <span class="fu">__break__</span>;
     --&gt; ()
** [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> __break__$$n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">9</span>
: </code></pre></div>
<p>Here the debugger is invoked right after the call to <a href="purelib.html#__break__"><code>__break__</code></a>, when the <code>n*fact (n-1)</code> expression in the <a href="#then"><code>then</code></a> branch is about to be evaluated. The debugger thus stops at the recursive invocation of <code>fact 9</code>. Tracing works in a similar fashion, using <a href="purelib.html#__trace__"><code>__trace__</code></a> in lieu of <a href="purelib.html#__break__"><code>__break__</code></a>, and continues until the current stack frame is exited. One major advantage of this method is that it is possible to invoke <a href="purelib.html#__break__"><code>__break__</code></a> or <a href="purelib.html#__trace__"><code>__trace__</code></a> only under certain conditions, so that you can focus on interesting “events” during evaluation, which can make debugging much less tedious. In our example, in order to stop when <code>n</code> becomes <code>1</code>, we might invoke <a href="purelib.html#__break__"><code>__break__</code></a> as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n&gt;<span class="dv">1</span>||<span class="fu">__break__</span> $$ n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
&gt; fact <span class="dv">3</span>;
++ [<span class="dv">4</span>] <span class="fu">__break__</span>: <span class="kw">extern</span> <span class="dt">void</span> pure_break() = <span class="fu">__break__</span>;
     --&gt; ()
** [<span class="dv">4</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n&gt;<span class="dv">1</span>||__break__$$n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
: p
   [<span class="dv">1</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n&gt;<span class="dv">1</span>||__break__$$n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">3</span>
   [<span class="dv">2</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n&gt;<span class="dv">1</span>||__break__$$n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">2</span>
   [<span class="dv">3</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n&gt;<span class="dv">1</span>||__break__$$n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">1</span>
** [<span class="dv">4</span>] fact: fact n::<span class="dt">int</span> = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n&gt;<span class="dv">1</span>||__break__$$n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;
     n = <span class="dv">0</span>
: </code></pre></div>
<h3 id="last-result">Last Result</h3>
<p>Another convenience for interactive usage is the <a href="purelib.html#ans"><code>ans</code></a> function, which retrieves the most recent result printed in interactive mode. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; fact n = <span class="kw">if</span> n&lt;=<span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n*fact (n-<span class="dv">1</span>);
&gt; map fact (<span class="dv">1</span>..<span class="dv">10</span>);
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]
&gt; scanl (+) <span class="dv">0</span> ans;
[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">9</span>,<span class="dv">33</span>,<span class="dv">153</span>,<span class="dv">873</span>,<span class="dv">5913</span>,<span class="dv">46233</span>,<span class="dv">409113</span>,<span class="dv">4037913</span>]</code></pre></div>
<p>Note that <a href="purelib.html#ans"><code>ans</code></a> is just an ordinary function, defined in the prelude, not a special command. However, there is a special <code>clear ans</code> command which purges the <code>ans</code> value. This is useful, e.g., if you got a huge result which you want to erase from memory before starting the next computation.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear ans
&gt; ans;
ans</code></pre></div>
<h3 id="pretty-printing">Pretty-Printing</h3>
<p>The interpreter provides the following “hook” to override the print representations of expressions. This works in a fashion similar to Haskell’s <code>show</code> function.</p>
<dl>
<dt><a name="__show__"></a><code>__show__ x</code></dt>
<dd>The programmer may define this function to supply custom print representations for certain expressions.
</dd>
</dl>
<!-- -->
<p><a href="#__show__"><code>__show__</code></a> is just an ordinary Pure function expected to return a string with the desired custom representation of a normal form value given as the function’s single argument. The interpreter prints the strings returned by <a href="#__show__"><code>__show__</code></a> just as they are. It will not check whether they conform to Pure syntax and/or semantics, or modify them in any way. Also, the library doesn’t define this function anywhere, so you are free to add any rules that you want.</p>
<p>Custom print representations are most useful for interactive purposes, if you’re not happy with the default print syntax of some kinds of objects. One particularly useful application of <a href="#__show__"><code>__show__</code></a> is to change the format of numeric values. Here are some examples:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; __show__ x::<span class="dt">double</span> = sprintf <span class="st">&quot;%0.6f&quot;</span> x;
&gt; <span class="dv">1</span>/<span class="dv">7</span>;
<span class="dv">0.142857</span>
&gt; __show__ x::<span class="dt">int</span> = sprintf <span class="st">&quot;0x%0x&quot;</span> x;
&gt; <span class="dv">1786</span>;
<span class="dv">0x6fa</span>
&gt; <span class="kw">using</span> math;
&gt; __show__ (x::<span class="dt">double</span> +: y::<span class="dt">double</span>) = sprintf <span class="st">&quot;%0.6f+%0.6fi&quot;</span> (x,y);
&gt; cis (-pi/<span class="dv">2</span>);
<span class="dv">0.000000</span>+-<span class="dv">1.</span>000000i</code></pre></div>
<p>The prelude function <a href="purelib.html#str"><code>str</code></a>, which returns the print representation of any Pure expression, calls <a href="#__show__"><code>__show__</code></a> as well:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; str (<span class="dv">1</span>/<span class="dv">7</span>);
<span class="st">&quot;0.142857&quot;</span></code></pre></div>
<p>Conversely, you can call the <a href="purelib.html#str"><code>str</code></a> function from <a href="#__show__"><code>__show__</code></a>, but in this case it always returns the default representation of an expression. This prevents the expression printer from going recursive, and allows you to define your custom representation in terms of the default one. E.g., the following rule removes the <code>L</code> suffixes from bigint values:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; __show__ x::<span class="dt">bigint</span> = init (str x);
&gt; fact n = foldl (*) 1L (<span class="dv">1</span>..n);
&gt; fact <span class="dv">30</span>;
<span class="dv">265252859812191058636308480000000</span></code></pre></div>
<p>Of course, your definition of <a href="#__show__"><code>__show__</code></a> can also call <a href="#__show__"><code>__show__</code></a> itself recursively to determine the custom representation of an object.</p>
<p>One case which needs special consideration are thunks (futures). The printer will <em>never</em> use <a href="#__show__"><code>__show__</code></a> for those, to prevent them from being forced inadvertently. In fact, you <em>can</em> use <a href="#__show__"><code>__show__</code></a> to define custom representations for thunks, but only in the context of a rule for other kinds of objects, such as lists. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">nonfix</span> ...;
&gt; __show__ (x:xs) = str (x:...) <span class="kw">if</span> thunkp xs;
&gt; <span class="dv">1</span>:<span class="dv">2</span>:(<span class="dv">3</span>..inf);
<span class="dv">1</span>:<span class="dv">2</span>:<span class="dv">3</span>:...</code></pre></div>
<p>Another case which needs special consideration are numeric matrices. For efficiency, the expression printer will always use the default representation for these, unless you override the representation of the matrix as a whole. E.g., the following rule for double matrices mimics Octave’s default output format (for the sake of simplicity, this isn’t perfect, but you get the idea):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; __show__ x::<span class="dt">matrix</span> =
&gt;   strcat [printd j (x!(i,j))|i=<span class="dv">0</span>..n-<span class="dv">1</span>; j=<span class="dv">0</span>..m-<span class="dv">1</span>] + <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>
&gt; <span class="kw">with</span> printd <span class="dv">0</span> = sprintf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">%10.5f&quot;</span>; printd _ = sprintf <span class="st">&quot;%10.5f&quot;</span> <span class="kw">end</span>
&gt; <span class="kw">when</span> n,m = dim x <span class="kw">end</span> <span class="kw">if</span> dmatrixp x;
&gt; {<span class="dv">1.0</span>,<span class="dv">1</span>/<span class="dv">2</span>;<span class="dv">1</span>/<span class="dv">3</span>,<span class="dv">4.0</span>};
   <span class="dv">1.00000</span>   <span class="dv">0.50000</span>
   <span class="dv">0.33333</span>   <span class="dv">4.00000</span></code></pre></div>
<p>Finally, by just purging the definition of the <a href="#__show__"><code>__show__</code></a> function you can easily go back to the standard print syntax:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear __show__
&gt; <span class="dv">1</span>/<span class="dv">7</span>; <span class="dv">1786</span>; cis (-pi/<span class="dv">2</span>);
<span class="dv">0.142857142857143</span>
<span class="dv">1786</span>
<span class="dv">6.12303176911189e-17</span>+:-<span class="dv">1.0</span></code></pre></div>
<p>Note that if you have a set of definitions for the <a href="#__show__"><code>__show__</code></a> function which should always be loaded at startup, you can put them into the interpreter’s interactive startup files, see <a href="#interactive-startup">Interactive Startup</a> below.</p>
<h3 id="user-defined-commands">User-Defined Commands</h3>
<p>It is possible to extend the interpreter with your own interactive commands. To these ends, all you have to do is provide some corresponding public function definitions in the special <code>__cmd__</code> namespace (cf. <a href="#namespaces">Namespaces</a>). These definitions are typically placed in one of the interpreter’s startup files (see <a href="#interactive-startup">Interactive Startup</a> below) so that they are always available when running the interpreter interactively.</p>
<p>A command function is invoked with one string argument which contains the rest of the command line (with leading and trailing whitespace stripped off). It may return a string result which is printed on standard output (appending a newline if needed). Thus a simple command which just prints its arguments as is can be implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span> __cmd__;
&gt; echo s = s;
&gt; echo Hello, world!
Hello, world!</code></pre></div>
<p>You can split arguments and do any required processing of the arguments with the usual string processing functions. For instance, let’s change our <code>echo</code> command so that it prints each whitespace-delimited token on a line of its own:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear __cmd__::echo
&gt; echo s = join <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> args <span class="kw">when</span>
&gt;   args = [a | a = split <span class="st">&quot; &quot;</span> s; ~null a];
&gt; <span class="kw">end</span>;
&gt; echo Hello, world!
Hello,
world!</code></pre></div>
<p>A command function may in fact return any kind of value. However, only string results are printed by the interpreter, other results are silently ignored. Thus we might implement the <code>echo</code> command in a direct fashion, using the C <code>puts</code> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear __cmd__::echo
&gt; <span class="kw">private</span> <span class="kw">extern</span> <span class="dt">int</span> puts(<span class="dt">char</span>*);
&gt; echo s = puts s;
&gt; echo Hello, world!
Hello, world!</code></pre></div>
<p>Note that we declared <code>puts</code> as a private symbol here. In general, the interpreter only exposes public functions in the <code>__cmd__</code> namespace as commands, private symbols are hidden. On the other hand, we might also just expose the external function <code>puts</code> itself under the (public) alias <code>echo</code>, so here’s yet another possible implementation of the <code>echo</code> command:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear __cmd__::echo
&gt; <span class="kw">extern</span> <span class="dt">int</span> puts(<span class="dt">char</span>*) = echo;
warning: external &#39;echo&#39; shadows previous undefined use <span class="kw">of</span> this symbol
&gt; echo Hello, world!
Hello, world!</code></pre></div>
<p>Instead of returning a result, a command function may also throw an exception. If the exception value is a string, it will be printed as an error message on standard error, using the same format as the built-in commands:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; error s = <span class="fu">throw</span> s;
&gt; error Hello, world!
error: Hello, world!</code></pre></div>
<p>You can also override a built-in command in order to provide custom functionality. In this case, the original builtin can still be executed by escaping the command name with a leading ‘<code>^</code>’. The same syntax works with the <a href="purelib.html#evalcmd"><code>evalcmd</code></a> function, so that a custom command can be defined in terms of the builtin that it replaces. E.g., if we always want to invoke the <code>ls</code> command with the <code>-l</code> option, we can redefine the <code>ls</code> command as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; ls examples<span class="co">/*.c</span>
<span class="co">examples/poor.c  examples/sort.c</span>
<span class="co">&gt;   ls s = evalcmd $ &quot;^ls -l &quot;+s;</span>
<span class="co">&gt; ls examples/*.c</span>
<span class="co">-rw-r--r-- 1 ag users 1883 2011-01-07 16:35 examples/poor.c</span>
<span class="co">-rw-r--r-- 1 ag users 3885 2011-01-07 16:35 examples/sort.c</span></code></pre></div>
<p>(Note that since we entered the definition of the <code>ls</code> function interactively, we need to escape the second input line above with leading whitespace, so that it’s not mistaken for an invocation of the built-in <code>ls</code> command. This isn’t necessary if you’re using the alternative “escape” command syntax described in <a href="#command-syntax">Command Syntax</a>.)</p>
<p>To do more interesting things, you should take a look at the reflection capabilities discussed in the <a href="#macros">Macros</a> section, which open up endless possibilities for commands to inspect and manipulate the running program in an interactive fashion. For instance, let’s define a variation of the built-in <code>clear</code> command which allows us to delete a specific rule rather than an entire function definition:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> __cmd__;

clr s = <span class="kw">case</span> val $ <span class="st">&quot;&#39;(0 with &quot;</span>+s+<span class="st">&quot; end)&quot;</span> <span class="kw">of</span>
  &#39;(<span class="dv">0</span> __with__ [r]) = del_fundef r;
  _ = <span class="fu">throw</span> <span class="st">&quot;bad rule syntax&quot;</span>;
<span class="kw">end</span>;</code></pre></div>
<p>Note that we employ a little trick here to have <a href="purelib.html#val"><code>val</code></a> do all the hard work of parsing the rule specified as argument to the command, in order to translate the Pure rule syntax to the special meta representation used by <a href="purelib.html#del_fundef"><code>del_fundef</code></a>. The following example shows our <code>clr</code> command in action:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">namespace</span>;
&gt; fact n = <span class="dv">1</span> <span class="kw">if</span> n&lt;=<span class="dv">0</span>;
&gt;        = n*fact (n-<span class="dv">1</span>) <span class="kw">otherwise</span>;
&gt; show fact
fact n = <span class="dv">1</span> <span class="kw">if</span> n&lt;=<span class="dv">0</span>;
fact n = n*fact (n-<span class="dv">1</span>);
&gt; clr fact n = <span class="dv">1</span> <span class="kw">if</span> n&lt;=<span class="dv">0</span>;
&gt; show fact
fact n = n*fact (n-<span class="dv">1</span>);</code></pre></div>
<p>Here’s another useful command <code>apropos</code> which quickly summarizes the information available on a given symbol (as reported by the <code>show</code> and <code>help_index</code> commands):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">namespace</span> __cmd__;

apropos s = <span class="kw">case</span> catmap descr $ split <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> $ evalcmd $ <span class="st">&quot;show -s &quot;</span>+s <span class="kw">of</span>
  [] = <span class="fu">throw</span> $ <span class="st">&quot;undefined symbol &#39;&quot;</span>+s+<span class="st">&quot;&#39;&quot;</span>;
  info = s+<span class="st">&quot; is a &quot;</span>+join <span class="st">&quot; and a &quot;</span> info+<span class="st">&quot;. \</span>
<span class="st">Type &#39;show &quot;</span>+s+<span class="st">&quot;&#39; for more information.&quot;</span>+
(<span class="kw">if</span> null (evalcmd $ <span class="st">&quot;help_index &quot;</span>+s) <span class="kw">then</span> <span class="st">&quot;&quot;</span> <span class="kw">else</span>
<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Documentation for this symbol is available. Type &#39;help &quot;</span>+s+<span class="st">&quot;&#39;.&quot;</span>);
<span class="kw">end</span> <span class="kw">with</span>
  descr info = <span class="kw">case</span> [x | x = split <span class="st">&quot; &quot;</span> info; ~null x] <span class="kw">of</span>
    t:c:_ = [symtypes!c] <span class="kw">if</span> s==t <span class="kw">when</span>
      symtypes = {<span class="st">&quot;fun&quot;</span>=&gt;<span class="st">&quot;function&quot;</span>,<span class="st">&quot;mac&quot;</span>=&gt;<span class="st">&quot;macro&quot;</span>,<span class="st">&quot;var&quot;</span>=&gt;<span class="st">&quot;variable&quot;</span>,
                  <span class="st">&quot;cst&quot;</span>=&gt;<span class="st">&quot;constant&quot;</span>};
    <span class="kw">end</span>;
    _ = [];
  <span class="kw">end</span>;
<span class="kw">end</span>;</code></pre></div>
<p>This command can be used as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; apropos foldl
foldl is a function. Type &#39;show foldl&#39; for more information.
Documentation for this symbol is available. Type &#39;help foldl&#39;.
&gt; apropos $
$ is a macro and a function. Type &#39;show $&#39; for more information.
Documentation for this symbol is available. Type &#39;help $&#39;.
&gt; <span class="kw">let</span> x = <span class="dv">11</span>;
&gt; apropos x
x is a variable. Type &#39;show x&#39; for more information.
&gt; apropos y
apropos: undefined symbol &#39;y&#39;</code></pre></div>
<p>More examples can be found in the sample.purerc file distributed with the Pure interpreter.</p>
<h3 id="interactive-startup">Interactive Startup</h3>
<p>In interactive mode, the interpreter runs some additional scripts at startup, after loading the prelude and the scripts specified on the command line. This lets you tailor the interactive environment to your liking.</p>
<p>The interpreter first looks for a .purerc file in the user’s home directory (as given by the <a href="#envvar-HOME"><code>HOME</code></a> environment variable) and then for a .purerc file in the current working directory. These are just ordinary Pure scripts which may contain any additional definitions (including command definitions, as described in the previous section) that you need. The .purerc file in the home directory is for global definitions which should always be available when running interactively, while the .purerc file in the current directory can be used for project-specific definitions.</p>
<p>Finally, you can also have a .pure initialization file in the current directory, which is usually created with the <code>dump</code> command (see above). This file is loaded after the .purerc files if it is present.</p>
<p>The interpreter processes all these files in the same way as with the <code>run</code> command (see <a href="#interactive-commands">Interactive Commands</a> above). When invoking the interpreter, you can specify the <a href="#cmdoption-pure--norc"><code>--norc</code></a> option on the command line if you wish to skip these initializations.</p>
<p><a name="batch-compilation"></a></p>
<h2 id="batch-compilation">Batch Compilation</h2>
<p>The interpreter’s <a href="#cmdoption-pure-c"><code>-c</code></a> option provides a means to turn Pure scripts into standalone executables. This feature is still a bit experimental. In particular, note that the compiled executable is essentially a <em>static snapshot</em> of your program which is executed on the “bare metal”, without a hosting interpreter. Only a minimal runtime system is provided. This considerably reduces startup times, but also implies some quirks and limitations as detailed below.</p>
<p>First and foremost, the batch compiler always reorders the code so that all toplevel expressions and <a href="#let"><code>let</code></a> bindings are evaluated <em>after</em> all functions have been defined. This is done to reduce the size of the output executable, so that there’s only a <em>single</em> snapshot of each function which will be used by all toplevel expressions and global variable definitions invoking the function. Therefore you should avoid code like the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">let</span> x = foo <span class="dv">99</span>;
foo x = x+<span class="dv">1</span>;
<span class="kw">let</span> y = foo <span class="dv">99</span>;</code></pre></div>
<p>Note that if you run this through the interpreter, <code>x</code> and <code>y</code> are bound to <code>foo 99</code> and <code>100</code>, respectively, because expressions and variable definitions are executed immediately, as the program is being processed. In contrast, if the same program is batch-compiled, <em>both</em> variables will be defined <em>after</em> the definition of <code>foo</code> and thus refer to the same value <code>100</code> instead. This will rarely be a problem in practice (the above example is really rather pathological and won’t usually occur in real-world programs), but to avoid these semantic differences, you’ll have to make sure that expressions are evaluated <em>after</em> all functions used in the evaluation have been defined completely. (However, the batch compiler currently doesn’t check this condition and will happily generate code for programs which violate it.)</p>
<p>Plain toplevel expressions won’t be of much use in a batch-compiled program, unless, of course, they are evaluated for their side-effects. Your program will have to include at least one of these to play the role of the “main program” in your script. In most cases these expressions are best placed after all the function and variable definitions, at the end of your program.</p>
<p>Also note that during a batch compilation, the compiled program is actually executed as usual, i.e., the script is also run <em>at compile time</em>. This might first seem to be a big annoyance, but it actually opens the door for some powerful programming techniques like <a href="http://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a>. It is also a necessity because of Pure’s highly dynamic nature. For instance, Pure allows you to define constants by evaluating an arbitrary expression (cf. <a href="#constant-definitions">Constant Definitions</a>), and using <a href="purelib.html#eval"><code>eval</code></a> a program can easily modify itself in even more unforeseeable ways. Therefore pretty much anything in your program can actually depend on previous computations performed while the program is being executed. To make this work in batch-compiled scripts, the batch compiler thus executes the script as usual. The <a href="#compiling"><code>compiling</code></a> variable can be used to check whether the script is being batch-compiled, so you can adjust to that by selectively enabling or disabling parts of the code. For instance, you will usually want to skip execution of the “main program” during batch compilation.</p>
<p>Last but not least, note that some parts of Pure’s metaprogramming capabilities and other compile time features are disabled in batch-compiled programs:</p>
<ul>
<li>The <a href="purelib.html#eval"><code>eval</code></a> function can only be used to evaluate plain toplevel expressions. You can define local functions and variables in <a href="#with"><code>with</code></a> and <a href="#when"><code>when</code></a> clauses inside an expression, but you can’t use <a href="purelib.html#eval"><code>eval</code></a> to define new global variables and functions. In other words, anything which changes the executing program is “verboten”. Moreover, the introspective capabilities provided by <a href="purelib.html#evalcmd"><code>evalcmd</code></a> and similar operations (discussed under <a href="#reflection">Reflection</a> in the <a href="#macros">Macros</a> section) are all disabled. If you need any of these capabilities, you have to run your program with the interpreter.</li>
<li>Constant and macro definitions, being compile time features, aren’t available in the compiled program. If you need to use these with <a href="purelib.html#eval"><code>eval</code></a> at run time, you have to provide them through variable and function definitions instead. Also, the compiler usually strips unused functions from the output code, so that only functions which are actually called somewhere in the static program text are available to <a href="purelib.html#eval"><code>eval</code></a>. (The <a href="#cmdoption-pure-u"><code>-u</code></a> option and the <a href="#cmdoption-pure-pragma--required"><code>--required</code></a> pragma can be used to avoid this, see <a href="#options-affecting-code-size">Options Affecting Code Size</a> below.)</li>
<li>Code which gets executed to compute constant values at compile time will generally <em>not</em> be executed in the compiled executable, so your program shouldn’t rely on side-effects of such computations (this would be bad practice anyway). There is an exception to this rule, however, namely if a constant value contains run time data such as pointers and local functions which requires an initialization at run time, then the batch compiler will generate code for that. (The same happens if the <a href="#cmdoption-pure--noconst"><code>--noconst</code></a> option is used to force computation of constant values at run time, see <a href="#options-affecting-code-size">Options Affecting Code Size</a>.)</li>
</ul>
<p>What this boils down to is that in the batch-compiled program you will have to avoid anything which requires the compile time or interactive facilities of the interpreter. These restrictions only apply at run time, of course. At compile time the program <em>is</em> being executed by the full version of the interpreter so you can use <a href="purelib.html#eval"><code>eval</code></a> and <a href="purelib.html#evalcmd"><code>evalcmd</code></a> in any desired way.</p>
<p>For most kinds of scripts, the above restrictions aren’t really that much of an obstacle, or can easily be worked around. For the few scripts which actually need the full dynamic capabilities of Pure you’ll just have to run the script with the interpreter. This isn’t a big deal either, only the startup will be somewhat slower because the script is compiled on the fly. Once the JIT has done its thing the “interpreted” script will run every bit as fast as the “compiled” one, since in fact <em>both</em> are compiled (only at different times) to exactly the same code!</p>
<h3 id="example">Example</h3>
<p>For the sake of a concrete example, consider the following little script:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;

fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;

main n = do puts [<span class="st">&quot;Hello, world!&quot;</span>, str (map fact (<span class="dv">1</span>..n))];

<span class="kw">if</span> argc&lt;=<span class="dv">1</span> <span class="kw">then</span> () <span class="kw">else</span> main (sscanf (argv!<span class="dv">1</span>) <span class="st">&quot;%d&quot;</span>);</code></pre></div>
<p>When invoked from the command line, with the number <code>n</code> as the first parameter, this program will print the string <code>&quot;Hello, world!&quot;</code> and the list of the first <code>n</code> factorials:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure hello.pure <span class="dv">10</span>
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>Note the condition on <code>argc</code> in the last line of the script. This prevents the program from producing an exception if no command line parameters are specified, so that the program can also be run interactively:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -i -q hello.pure
&gt; main <span class="dv">10</span>;
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]
()
&gt; quit</code></pre></div>
<p>To turn the script into an executable, we just invoke the Pure interpreter with the <a href="#cmdoption-pure-c"><code>-c</code></a> option, using the <a href="#cmdoption-pure-o"><code>-o</code></a> option to specify the desired output file name:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -c hello.pure -o hello
$ ./hello <span class="dv">10</span>
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>Next suppose that we’d like to supply the value <code>n</code> at <em>compile</em> rather than run time. To these ends we want to turn the value passed to the <code>main</code> function into a compile time constant, which can be done as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">const</span> n = <span class="kw">if</span> argc&gt;<span class="dv">1</span> <span class="kw">then</span> sscanf (argv!<span class="dv">1</span>) <span class="st">&quot;%d&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;</code></pre></div>
<p>(Note that we provide <code>10</code> as a default if <code>n</code> isn’t specified on the command line.)</p>
<p>Moreover, in such a case we usually want to skip the execution of the main function at compile time. To these ends, the predefined <a href="#compiling"><code>compiling</code></a> variable holds a truth value indicating whether the program is actually running under the auspices of the batch compiler, so that it can adjust accordingly. In our example, the evaluation of <code>main</code> becomes:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">if</span> compiling <span class="kw">then</span> () <span class="kw">else</span> main n;</code></pre></div>
<p>Our program now looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;

fact n = <span class="kw">if</span> n&gt;<span class="dv">0</span> <span class="kw">then</span> n*fact (n-<span class="dv">1</span>) <span class="kw">else</span> <span class="dv">1</span>;

main n = do puts [<span class="st">&quot;Hello, world!&quot;</span>, str (map fact (<span class="dv">1</span>..n))];

<span class="kw">const</span> n = <span class="kw">if</span> argc&gt;<span class="dv">1</span> <span class="kw">then</span> sscanf (argv!<span class="dv">1</span>) <span class="st">&quot;%d&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;
<span class="kw">if</span> compiling <span class="kw">then</span> () <span class="kw">else</span> main n;</code></pre></div>
<p>This script “specializes” <code>n</code> to the first (compile time) parameter when being batch-compiled, and it still works as before when we run it through the interpreter in both batch and interactive mode, too:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -i -q hello.pure
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]
&gt; main <span class="dv">5</span>;
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>]
()
&gt; quit

$ pure hello.pure <span class="dv">7</span>
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>]

$ pure -o hello -c -x hello.pure <span class="dv">7</span>

$ ./hello
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>]</code></pre></div>
<p>In addition, there’s also a <em>compile time</em> check analogous to the <a href="#compiling"><code>compiling</code></a> variable, which indicates whether the source script is being run normally or in a batch compilation; see <a href="#conditional-compilation">Conditional Compilation</a>. We might employ this as follows, replacing the last line of the script with this:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --<span class="kw">if</span> compiled
<span class="kw">if</span> compiling <span class="kw">then</span> () <span class="kw">else</span> main n;
#! --<span class="kw">else</span>
<span class="kw">if</span> argc&gt;<span class="dv">1</span> <span class="kw">then</span> main n <span class="kw">else</span> puts <span class="st">&quot;Try &#39;main n&#39; where n is a number.&quot;</span>;
#! --endif</code></pre></div>
<p>The code in the <code>--if compiled</code> section, which is the same as before, is now only executed during batch compilation and in the compiled executable. If we run the script normally, in the interpreter, the code in the <code>--else</code> section, which just prints a welcome message if no arguments are given on the command line, is executed instead. So we now actually have <em>four</em> different code paths, depending on whether the script is run normally, with or without arguments, or in a batch compilation, or as a native executable. This kind of setup is useful if the script is to be run both interactively and non-interactively in the interpreter while developing it, but once the script is finished it gets compiled and installed as a native executable.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -i -q hello.pure
Try &#39;main n&#39; where n is a number.
&gt; main <span class="dv">5</span>;
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>]
()
&gt; quit

$ pure hello.pure <span class="dv">7</span>
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>]

$ pure -o hello -c hello.pure

$ ./hello
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>,<span class="dv">40320</span>,<span class="dv">362880</span>,<span class="dv">3628800</span>]</code></pre></div>
<p>You’ll rarely need an elaborate setup like this, most of the time something like our simple first example will do the trick. But, as you’ve seen, Pure can easily do it.</p>
<h3 id="options-affecting-code-size">Options Affecting Code Size</h3>
<p>By default, the batch compiler strips unused functions from the output code, to keep the code size small. You can disable this with the <a href="#cmdoption-pure-u"><code>-u</code></a> option, in which case the output code includes <em>all</em> functions defined in the compiled program, the prelude and any other module imported with a <a href="#using"><code>using</code></a> clause, even if they don’t seem to be used anywhere. This considerably increases compilation times and makes the compiled executable much larger. For instance, on a 64 bit Linux systems with ELF binaries the executable of our hello.pure example is about thrice as large:</p>
<pre class="sourceCode none"><code>$ pure -o hello -c -x hello.pure 7 &amp;&amp; ls -l hello
-rwxr-xr-x 1 ag users 178484 2010-01-12 06:21 hello
$ pure -o hello -c -u -x hello.pure 7 &amp;&amp; ls -l hello
-rwxr-xr-x 1 ag users 541941 2010-01-12 06:21 hello</code></pre>
<p>(Note that even the stripped executable is fairly large when compared to compiled C code, as it still contains the symbol table of the entire program, which is needed by the runtime environment.)</p>
<p>Stripped executables should be fine for most purposes, but you have to be careful when using <a href="purelib.html#eval"><code>eval</code></a> in your compiled program. The compiler only does a <em>static</em> analysis of which functions might be reached from the initialization code (i.e., toplevel expressions and <a href="#let"><code>let</code></a> bindings). It does <em>not</em> take into account code run via the <a href="purelib.html#eval"><code>eval</code></a> routine. Thus, functions used only in <a href="purelib.html#eval"><code>eval</code></a>ed code will be stripped from the executable, as if they were never defined at all. If such a function is then being called using <a href="purelib.html#eval"><code>eval</code></a> at runtime, it will evaluate to a plain constructor symbol.</p>
<p>If this is a problem then you can either use the <a href="#cmdoption-pure-u"><code>-u</code></a> option to produce an unstripped executable, or you can force specific functions to be included in the stripped executable with the <a href="#cmdoption-pure-pragma--required"><code>--required</code></a> pragma (cf. <a href="#code-generation-options">Code Generation Options</a>). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --required foo
foo x = bar (x-<span class="dv">1</span>);
eval <span class="st">&quot;foo 99&quot;</span>;</code></pre></div>
<p>There is another code generation option which may have a substantial effect on code size, namely the <a href="#cmdoption-pure--noconst"><code>--noconst</code></a> option. Normally, constant values defined in a <a href="#const"><code>const</code></a> definition are precomputed at compile time and then stored in the generated executable; this reduces startup times but may increase the code size considerably if your program contains big constant values such as lists. If you prefer smaller executables then you can use the <a href="#cmdoption-pure--noconst"><code>--noconst</code></a> option to force the value of the constant to be recomputed at run time (which effectively turns the constant into a kind of read-only variable). For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">#! --noconst
<span class="kw">const</span> xs = 1L..100000L;
sum = foldl (+) <span class="dv">0</span>;

<span class="kw">using</span> system;
puts $ str $ sum xs;</code></pre></div>
<p>On my 64 bit Linux system this produces a 187115 bytes executable. Without <a href="#cmdoption-pure--noconst"><code>--noconst</code></a> the code becomes almost an order of magnitude larger in this case (1788699 bytes). On the other hand, the smaller executable also takes a little longer to run since it must first recompute the value of the list constant at startup. So you have to consider the tradeoffs in a given situation. Usually big executables aren’t much of a problem on modern operating systems, but if your program contains a lot of big constants then this may become an important consideration. However, if a constant value takes a long time to compute then you’ll be better off with the default behaviour of precomputing the value at compile time.</p>
<h3 id="other-output-code-formats">Other Output Code Formats</h3>
<p>Note that while the batch compiler generates native executables by default, it can just as well create object files which can be linked into other C/C++ programs and libraries:</p>
<pre class="sourceCode none"><code>$ pure -o hello.o -c -x hello.pure 7</code></pre>
<p>The .o extension tells the compiler that you want an object file. When linking the object module, you also need to supply an initialization routine which calls the <code>__pure_main__</code> function in hello.o to initialize the compiled module. This routine is declared in C/C++ code as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> __pure_main__(<span class="dt">int</span> argc, <span class="dt">char</span>** argv);</code></pre></div>
<p>As indicated, <code>__pure_main__</code> is to be invoked with two parameters, the argument count and <a href="purelib.html#NULL"><code>NULL</code></a>-terminated argument vector which become the <code>argc</code> and the <code>argv</code> of the Pure program, respectively. (You can also just pass 0 for both arguments if you don’t need to supply command line parameters.) The purpose of <code>__pure_main__</code> is to initialize a shell instance of the Pure interpreter which provides the minimal runtime support necessary to execute the Pure program, and to invoke all “initialization code” (variable definitions and toplevel expressions) of the program itself.</p>
<p>A minimal C <code>main</code> function which does the job of initializing the Pure module looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">extern</span> <span class="dt">void</span> __pure_main__(<span class="dt">int</span> argc, <span class="dt">char</span>** argv);

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span>** argv)
{
  __pure_main__(argc, argv);
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>If you link the <code>main</code> routine with the Pure module, don’t forget to also pull in the Pure runtime library. Assuming that the above C code is in pure_main.c:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ gcc -c pure_main.c -o pure_main.o
$ g++ -o hello hello.o pure_main.o -lpure
$ ./hello
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>]</code></pre></div>
<p>(The C++ compiler is used as the linker here so that the standard C++ library gets linked in, too. This is necessary because Pure’s runtime library is actually written in C++.)</p>
<p>In fact, this is pretty much what <code>pure -c</code> actually does for you when creating an executable.</p>
<p>If your script loads dynamic libraries (<code>using &quot;lib:...&quot;;</code>) then you’ll also have to link with those; <em>all</em> external references have to be resolved at compile time. This is taken care of automatically when creating executables. Otherwise it is a good idea to run <code>pure -c</code> with the <code>-v0100</code> verbosity option so that it prints the libraries to be linked (in addition to the commands which are invoked in the compilation process):</p>
<pre class="sourceCode none"><code>$ pure -v0100 -c hello.pure -o hello.o
opt -f -std-compile-opts hello.o.bc | llc -f -o hello.o.s
gcc -c hello.o.s -o hello.o
Link with: g++ hello.o -lpure</code></pre>
<p>Well, we already knew that, so let’s consider a slightly more interesting example from Pure’s ODBC module:</p>
<pre class="sourceCode none"><code>$ pure -v0100 -c pure-odbc/examples/menagerie.pure -o menagerie.o
opt -f -std-compile-opts menagerie.o.bc | llc -f -o menagerie.o.s
gcc -c menagerie.o.s -o menagerie.o
Link with: g++ menagerie.o /usr/local/lib/pure/odbc.so -lpure
$ g++ -shared -o menagerie.so menagerie.o /usr/local/lib/pure/odbc.so -lpure</code></pre>
<p>Note that the listed link options are necessary but might not be sufficient; <code>pure -c</code> just makes a best guess based on the Pure source. On most systems this will be good enough, but if it isn’t, you can just add options to the linker command as needed to pull in additional required libraries.</p>
<p>As this last example shows, you can also create shared libraries from Pure modules. However, on some systems (most notably x86_64), this requires that you pass the <a href="#cmdoption-pure-fPIC"><code>-fPIC</code></a> option when batch-compiling the module, so that position-independent code is generated:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -c -fPIC pure-odbc/examples/menagerie.pure -o menagerie.o</code></pre></div>
<p>Note that even when building a shared module, you’ll have to supply an initialization routine which calls <code>__pure_main__</code> somewhere.</p>
<p>Also note that since Pure doesn’t support separate compilation in the present implementation, if you create different shared modules like this, each will contain their own copy all the required Pure functions from the prelude and other imported Pure modules. This becomes a problem when trying to link several separate batch-compiled modules into the same executable or library, because you’ll get many name clashes for routines present in different modules (including the <code>__pure_main__</code> entry point). To prevent this, the batch compiler can be invoked with the <a href="#cmdoption-pure--main"><code>--main</code></a> option to explicitly set a name for the main entry point. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -c hello.pure -o hello.o --main __hello_main__</code></pre></div>
<p>This has two effects. First, the main entry point will be called whatever you specified with <a href="#cmdoption-pure--main"><code>--main</code></a>, so you have to call this function instead of <code>__pure_main__</code> to initialize the module. Second, if <a href="#cmdoption-pure--main"><code>--main</code></a> is specified, then all Pure functions in the module will be changed to internal linkage (like <code>static</code> functions in C) to prevent any possible name clashes between different modules. (Alas, this also makes it impossible to employ <code>pure_funcall</code> to call Pure functions directly from C, as described in the following section, so you’ll have to use other runtime routines such as <code>pure_eval</code> or <code>pure_appl</code> to achieve this in an indirect way.)</p>
<p>The batch compiler also lets you pass some special options to the llc program when creating a native assembler or object file. The present implementation understands options of the form <code>-m</code><em>opt</em><code>=</code><em>val</em> which can be used to select the desired target architecture and cpu type. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -march=x86-<span class="dv">64</span> -mcpu=generic -c hello.pure -o hello</code></pre></div>
<p>This is useful, in particular, in cross compilation and if you need to select a specific processor variant. If you do not specify these options, llc will pick a suitable default based on the characteristics of the host system on which the code is compiled. Please check the documentation of the llc program for further information.</p>
<p>For more elaborate uses not covered by the options discussed above, <code>pure -c</code> can also generate just plain LLVM assembler code:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">pure -c hello.pure -o hello.ll</code></pre></div>
<p>Note the .ll extension; this tells the compiler that you want an LLVM assembler file. An LLVM bitcode file can be created just as easily:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">pure -c hello.pure -o hello.bc</code></pre></div>
<p>In these cases you’ll have to have to handle the rest of the compilation yourself. This gives you the opportunity, e.g., to play with more advanced optimization and code generation options provided by the LLVM toolchain. Please refer to the <a href="http://llvm.org/docs/">LLVM documentation</a> (in particular, the description of the opt and llc programs) for details.</p>
<h3 id="calling-pure-functions-from-c">Calling Pure Functions From C</h3>
<p>Another point worth mentioning here is that you can’t just call Pure functions in a batch-compiled module directly. That’s because in order to call a Pure function, at least in the current implementation, you have to set up a Pure stack frame for the function. However, there’s a convenience function called <code>pure_funcall</code> in the runtime API to handle this. This function takes a pointer to the Pure function, the argument count and the arguments themselves (as <code>pure_expr*</code> objects) as parameters. For instance, here is a pure_main.c module which can be linked against the hello.pure program from above, which calls the <code>fact</code> function from the Pure program:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;pure/runtime.h&gt;</span>

<span class="kw">extern</span> <span class="dt">void</span> __pure_main__(<span class="dt">int</span> argc, <span class="dt">char</span>** argv);
<span class="kw">extern</span> pure_expr *fact(pure_expr *x);

<span class="dt">int</span> main()
{
  <span class="dt">int</span> n = <span class="dv">10</span>, m;
  __pure_main__(<span class="dv">0</span>, NULL);
  <span class="cf">if</span> (pure_is_int(pure_funcall(fact, <span class="dv">1</span>, pure_int(n)), &amp;m))
    printf(<span class="st">&quot;fact %d = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, n, m);
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>And here’s how you can compile, link and run this program:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">$ pure -o hello.o -c -x hello.pure <span class="dv">7</span>
$ gcc -o pure_main.o -c pure_main.c
$ g++ -o myhello hello.o pure_main.o -lpure
$ ./myhello
Hello, world!
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">24</span>,<span class="dv">120</span>,<span class="dv">720</span>,<span class="dv">5040</span>]
fact <span class="dv">10</span> = <span class="dv">3628800</span></code></pre></div>
<p>Note that the first two lines are output from the Pure program; the last line is what gets printed by the <code>main</code> routine in pure_main.c.</p>
<h2 id="caveats-and-notes">Caveats and Notes</h2>
<p>This section is a grab bag of casual remarks, useful tips and tricks, and information on common pitfalls, quirks and limitations of the current implementation and how to deal with them.</p>
<h3 id="etymology">Etymology</h3>
<p>People keep asking me what’s so “pure” about Pure. The long and apologetic answer is that Pure tries to stay as close as possible to the spirit of term rewriting without sacrificing practicality. Pure’s term rewriting core is in fact purely functional. It’s thus possible and in fact quite easy to write purely functional programs in Pure, and you’re encouraged to do so whenever this is reasonable. On the other hand, Pure doesn’t get in your way if you want to call external operations with side effects; after all, it does allow you to call any C function at any point in a Pure program.</p>
<p>The short answer is that I simply liked the name, and there wasn’t any programming language named “Pure” yet (quite a feat nowadays), so there’s one now. If you insist on a (recursive) backronym, just take “Pure” to stand for the “Pure universal rewriting engine”.</p>
<h3 id="backward-compatibility">Backward Compatibility</h3>
<p>Pure is based on the author’s earlier <a href="#q">Q</a> language, but it offers many new and powerful features and programs run much faster than their Q equivalents. The language also went through a thorough facelift in order to modernize the syntax and make it more similar to other modern-style functional languages, in particular <a href="#miranda">Miranda</a> and <a href="#haskell">Haskell</a>. Thus porting Q scripts to Pure often involves a substantial amount of manual work, but it can (and has) been done.</p>
<p>Since its modest beginnings in April 2008, Pure has gone through a lot of major and minor revisions which raise various backward compatibility issues. We document these in the following, in order to facilitate the porting of older Pure scripts. (Note that this isn’t intended to be a full history of Pure development, so you may want to consult the NEWS and ChangeLog files included in the distribution for more details.)</p>
<p>Pure 0.7 introduced built-in matrix structures, which called for some minor changes in the syntax of comprehensions and arithmetic sequences. Specifically, the template expression and generator/filter clauses of a comprehension are now separated with <code>|</code> instead of <code>;</code>. Moreover, arithmetic sequences with arbitrary stepsize are now written <code>x:y..z</code> instead of <code>x,y..z</code>, and the ‘<code>..</code>’ operator now has a higher precedence than the ‘<code>,</code>’ operator. This makes writing matrix slices like <code>x!!(i..j,k..l)</code> much more convenient.</p>
<p>In Pure 0.13 the naming of the logical and bitwise operations was changed, so that these are now called <code>~</code>, <code>&amp;&amp;</code>, <code>||</code> and <code>not</code>/<code>and</code>/<code>or</code>, respectively. (Previously, <code>~</code> was used for bitwise, <code>not</code> for logical negation, which was rather inconsistent, albeit compatible with the naming of the <code>not</code> operation in Haskell and ML.) Also, to stay in line with this naming scheme, inequality was renamed to <code>~=</code> (previously <code>!=</code>).</p>
<p>Pure 0.14 introduced the namespaces feature. Consequently, the scope of private symbols is now confined to a namespace rather than a source module; scripts making use of private symbols need to be adapted accordingly. Also note that syntax like <code>foo::int</code> may now also denote a qualified symbol rather than a tagged variable, if <code>foo</code> has been declared as a namespace. You can work around such ambiguities by renaming the variable, or by placing spaces around the ‘<code>::</code>’ delimiter (these aren’t permitted in a qualified symbol, so the construct <code>foo :: int</code> is always interpreted as a tagged variable, no matter whether <code>foo</code> is also a valid namespace).</p>
<p>Pure 0.26 extended the namespaces feature to add support for hierarchical namespaces. This means that name lookup works in a slightly different fashion now (see <a href="#hierarchical-namespaces">Hierarchical Namespaces</a> for details), but old code which doesn’t use the new feature should continue to work unchanged.</p>
<p>Pure 0.26 also changed the <code>nullary</code> keyword to <a href="#nonfix"><code>nonfix</code></a>, which is more consistent with the other kinds of fixity declarations. Moreover, the parser was enhanced so that it can cope with a theoretically unbounded number of precedence levels, and the system of standard operators in the prelude was modified so that it becomes possible to sneak in new operator symbols with ease; details can be found in the <a href="#symbol-declarations">Symbol Declarations</a> section.</p>
<p>Pure 0.41 added support for optimization of indirect tail calls, so that any previous restrictions on the use of tail recursion in indirect function calls and mutually recursive globals have been removed. Moreover, the logical operators <code>&amp;&amp;</code> and <code>||</code> are now tail-recursive in their second operand and can also be extended with user-defined equations, just like the other builtins. Note that this implies that the values returned by <code>&amp;&amp;</code> and <code>||</code> aren’t normalized to the values 0 and 1 any more (this isn’t possible with tail call semantics). If you need this then you’ll have to make sure that either the operands are already normalized, or you’ll have to normalize the result yourself.</p>
<p>Also, as of Pure 0.41 the batch compiler produces stripped executables by default. To create unstripped executables you now have to use the <a href="#cmdoption-pure-u"><code>-u</code></a> option, see <a href="#options-affecting-code-size">Options Affecting Code Size</a> for details. The <a href="#cmdoption-pure-s"><code>-s</code></a> option to produce stripped executables is still provided for backward compatibility, but it won’t have any effect unless you use it to override a previous <a href="#cmdoption-pure-u"><code>-u</code></a> option.</p>
<p>Pure 0.43 changed the rules for looking up symbols in user-defined namespaces. Unqualified symbols are now created in the current (rather than the global) namespace by default, see <a href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a> for details. The <a href="#cmdoption-pure-w"><code>-w</code></a> option can be used to get warnings about unqualified symbols which are resolved to a different namespace than previously. It also provides a means to check your scripts for implicit declarations which might indicate missing or mistyped function symbols.</p>
<p>Pure 0.45 added support for checking arbitrary pointer types in the C interface, so that you don’t have to worry about passing the wrong kinds of pointers to system and library routines any more. Moreover, the interpretation of numeric pointer arguments (<code>int*</code> etc.) was changed to bring them in line with the other new numeric matrix conversions (<code>int**</code> etc.). In particular, the matrix data can now be modified in-place and type checking is more strict (<code>int*</code> requires an int matrix, etc.). Also, there’s now support for <code>argv</code>-style vector arguments (<code>char**</code> and <code>void**</code>). Please see the <a href="#c-types">C Types</a> section for details.</p>
<p>Pure 0.47 added a bunch of new features which have been on the wishlist for the forthcoming 1.0 release:</p>
<ul>
<li>You can now define your own interactive commands by placing suitable function definitions in the special <code>__cmd__</code> namespace; see <a href="#user-defined-commands">User-Defined Commands</a> for details.</li>
<li>The syntax used to denote <a href="#inline-code">inline code</a> sections was changed from <code>%{...%}</code> to <code>%&lt;...%&gt;</code>. This resolves an ambiguity in the syntax (note that <code>%{</code> is legal Pure syntax; it could denote a <code>%</code> operator followed by a matrix value), and also makes it easier to properly support this construct in Emacs Pure mode.</li>
<li>It is now possible to declare variadic externs, so that functions like <code>printf</code> can be called without much ado; see <a href="#variadic-c-functions">Variadic C Functions</a>.</li>
<li>Support for simple kinds of matrix <a href="#patterns">patterns</a> like <code>{x,y}</code>, <code>{x::int,y}</code>, <code>{x,y;z,t}</code>, <code>{{x,y},z}</code> was added.</li>
<li>The meaning of quoted specials such as lambdas and local definitions was changed. Previously these would be evaluated even in the middle of a quoted expression. Now they will produce a special meta representation in terms of built-in macros, in order to support the advanced metaprogramming capabilities discussed in <a href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a> and <a href="#reflection">Reflection</a>.</li>
<li>Last but not least, Pure 0.47 sports a new, more flexible type tag feature which defines type tags as unary predicates implemented using normal rewriting rules; cf. section <a href="#type-rules">Type Rules</a> for details. To these ends, a new keyword <a href="#type"><code>type</code></a> was added (if you used this as an ordinary identifier, you will have to rename these). Note that the old-style type tags, which were just a syntactic shortcut for “as” patterns involving unary constructor symbols, aren’t supported any more, so you’ll have to fix up your old scripts accordingly. To assist with this, the Pure interpreter can be run with the <a href="#cmdoption-pure-w"><code>-w</code></a> option in order to identify occurrences of undefined (presumably old-style) type tags. You should either change these to the corresponding “as” pattern (i.e., <code>x::foo</code> to <code>x@(foo _)</code>), or just add a proper type definition for the tag (like <code>type foo (foo _);</code>).</li>
</ul>
<p>Pure 0.48 moved pointer arithmetic and the regex functions into separate <a href="purelib.html#module-pointers">pointers</a> and <a href="purelib.html#module-regex">regex</a> modules, so you now have to import these modules if you need this functionality. It also introduced the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragma which lets you have “defined” functions in Pure which throw an exception if they can’t be applied, e.g., because they are invoked with the wrong arguments.</p>
<p>Pure 0.49 introduced the <a href="#conditional-compilation">conditional compilation</a> pragmas, so that simple version and system dependencies can now be handled in a more convenient way.</p>
<p>Pure 0.50 introduced the declaration of <a href="#interface-types">interface types</a>, which make it possible to create the definition of a type from a description of its operations. To these ends, a new keyword <a href="#interface"><code>interface</code></a> was added to the language.</p>
<p>Pure 0.55 changed the default compilers for inline C, C++ and Fortran code to clang, clang++ and gfortran (with the dragonegg plugin), respectively. This was done in order to support LLVM 3.x which does not have llvm-gcc (the previous default) any more. If you’re still running an older LLVM version and would like to keep using llvm-gcc, you will have to set some environment variables; please see the <a href="install.html">installation instructions</a> for details.</p>
<p>Pure 0.56 fixed the meaning of patterns in comprehensions so that unmatched elements are now filtered out automatically, like in Haskell. The previous behaviour of raising an exception in such cases offered no real benefits and was in fact very inconvenient in most situations. Pure 0.56 also enables stack checks by default (see <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> for details), and interactive commands can optionally be escaped by prefixing them with a special character (see <a href="#command-syntax">Command Syntax</a>). The <a href="purelib.html#true"><code>true</code></a> and <a href="purelib.html#false"><code>false</code></a> constants are now declared as <a href="#nonfix"><code>nonfix</code></a> symbols in the prelude so that they can be used in patterns.</p>
<p>Pure 0.58 made the <a href="#cmdoption-pure-x"><code>-x</code></a> option optional, so that a script can now be invoked with arguments simply as <code>pure script arg1 arg2 ...</code>, which matches the default behaviour of most other command language interpreters. This also has the advantage that shebangs like <code>#!/usr/bin/env pure</code> can now be used without any caveats. If you do want to execute multiple script files in batch mode then you now have to explicitly indicate this with the new <a href="#cmdoption-pure-b"><code>-b</code></a> option; please see <a href="#invoking-pure">Invoking Pure</a> for details. Pure 0.58 also adds two new code generation options <a href="#cmdoption-pure--symbolic"><code>--symbolic</code></a> and <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> to set the default evaluation mode of global functions; these are discussed in <a href="#defined-functions">Defined Functions</a> below.</p>
<h3 id="error-recovery">Error Recovery</h3>
<p>The parser uses a fairly simplistic panic mode error recovery which tries to catch syntax errors at the toplevel only. This seems to work reasonably well, but might catch some errors much too late. Unfortunately, Pure’s terseness makes it rather difficult to design a better scheme. As a remedy, the parser accepts an empty definition (just <code>;</code> by itself) at the toplevel only. Thus, in interactive usage, if the parser seems to eat away your input without doing anything, entering an extra semicolon or two should break the spell, putting you back at the toplevel where you can start typing the definition again.</p>
<h3 id="splicing-tuples-and-matrices">Splicing Tuples and Matrices</h3>
<p>The “splicing” of tuples and matrices is probably one of Pure’s most controversial features. By this we mean that tuples and matrices get flattened out when they are combined. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>),<span class="dv">4</span>,(<span class="dv">5</span>,<span class="dv">6</span>);
<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>
&gt; {{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>},<span class="dv">4</span>,{<span class="dv">5</span>,<span class="dv">6</span>}};
{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>}
&gt; {{a,b;c,d},{x;y}}
{a,b,x;c,d,y}</code></pre></div>
<p>This kind of behaviour is also known from Perl and MATLAB/Octave. Users familiar with these languages often find it convenient, but it certainly gets in the way if you want to nest these structures. Fortunately, there are some remedies for the most common cases where you’d want to do this. Specifically, for the case of vectors the prelude defines the <a href="purelib.html#non-splicing">non-splicing vector brackets</a> which make it easy to construct nested vectors; these are often used to represent multi-dimensional indexable collections in Pure. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; {|{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>},<span class="dv">4</span>,{<span class="dv">5</span>,<span class="dv">6</span>}|};
{{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>},<span class="dv">4</span>,{<span class="dv">5</span>,<span class="dv">6</span>}}
&gt; {|{a,b;c,d},{x;y}|};
{{a,b;c,d},{x;y}}
&gt; ans!<span class="dv">0</span>!(<span class="dv">1</span>,<span class="dv">1</span>);
d</code></pre></div>
<p>Nothing like this is available for tuples, though, so you’ll have to use lists instead if you need nestability. Note that the deeper reason behind the non-nestability of tuples is the right-recursive nature of tuples combined with the fact that there aren’t any real 1-tuples in Pure (<code>(x)</code> is just <code>x</code>). This implies that you can’t have a nested tuple in the last component of a tuple, no matter how hard you try to prevent the splicing, e.g., by quoting. <code>x,(y,z)</code> is always just the triple <code>x,y,z</code>.</p>
<p>One might consider this a defect in Pure’s tuple data structure. But Pure already has a nestable kind of tuples (lists), so it would be rather pointless to have yet another isomorphic data structure with just slightly different syntax. Instead Pure gives you the choice between two kinds of list-like data structures, one which nests, and one which doesn’t but has other interesting properties.</p>
<h3 id="with-and-when">With and when</h3>
<p>Another common source of confusion is that Pure provides two different constructs to bind local function and variable symbols, respectively. This distinction is necessary because Pure does not segregate defined functions and constructors, and thus there is no magic to figure out whether an equation like <code>foo x = y</code> by itself is meant as a definition of a function <code>foo</code> with formal parameter <code>x</code> and return value <code>y</code>, or a pattern binding defining the local variable <code>x</code> by matching the pattern <code>foo x</code> against the value of <code>y</code>. The <a href="#with"><code>with</code></a> construct does the former, <a href="#when"><code>when</code></a> the latter.</p>
<p>Also note that the function definitions in a <a href="#with"><code>with</code></a> clause are all done simultaneously (and can thus be mutually recursive), while the individual variable definitions and expressions in a <a href="#when"><code>when</code></a> clause are executed in order. This works in exactly the same fashion as <code>letrec</code> and <code>let</code> in Scheme. (As a mnemonic, consider that <a href="#when"><code>when</code></a> conveys a sense of time, so its parts are “executed in sequence”.)</p>
<p>The sequential execution aspect of <a href="#when"><code>when</code></a> is rather important in Pure, because it enables you to do a series of “actions” (variable bindings and expression evaluations) in sequence by simply enclosing it in a <a href="#when"><code>when</code></a> clause. This provides the Pure programmer with a useful and familiar bit of imperative “look and feel” (even though the <a href="#when"><code>when</code></a> clause itself works in a purely functional way). For instance, suppose that we’d like to define a function which opens a file, checks that the file was opened successfully and throws an exception otherwise, outputs a message to indicate which file was opened, and finally returns the contents of the file as a string. The easiest way to do this in Pure is as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;

read_file name::<span class="dt">string</span> = s <span class="kw">when</span>
  fp = fopen name <span class="st">&quot;r&quot;</span>;
  pointerp fp || <span class="fu">throw</span> (sprintf <span class="st">&quot;%s: %s&quot;</span> (name,strerror errno));
  printf <span class="st">&quot;opened file %s</span><span class="ch">\n</span><span class="st">&quot;</span> name;
  s = fget fp;
<span class="kw">end</span>;</code></pre></div>
<p>Another bit of syntax that may take getting used to is that <a href="#with"><code>with</code></a> and <a href="#when"><code>when</code></a> clauses are tacked on to the end of the expression they belong to. This mimics mathematical language and supposedly makes it easier to read and understand a definition, because you’re told right up front <em>what</em> is to be computed, before going into the details of <em>how</em> the computation is performed. Unfortunately, this style differs considerably from other block-structured programming languages, which often place local definitions in front of the code they apply to. Pure doesn’t offer any special syntax for this, but note that you can always write a <a href="#when"><code>when</code></a> or <a href="#with"><code>with</code></a> clause in the following style which places the “body” at the bottom:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">result <span class="kw">when</span>
  y = foo (x+<span class="dv">1</span>);
  z = bar y;
  result = baz z;
<span class="kw">end</span>;</code></pre></div>
<p>This can be read and written more or less like a <code>let</code> expression in Scheme or ML, except that the name of the result is given explicitly at the beginning. However, this style doesn’t really save you either if you need several sections with both local functions and variables. In this case you’ll just have to bite the bullet and arrange the <a href="#with"><code>with</code></a> and <a href="#when"><code>when</code></a> clauses the way that Pure wants them. That is, first come the local variables used in the right-hand side, then the local functions needed to compute those variables, then maybe another section with local variables needed by those functions, etc. When looking at such a complicated series of definitions, it sometimes helps to read the <a href="#with"><code>with</code></a> and <a href="#when"><code>when</code></a> blocks “in reverse”, i.e., from bottom to top, which is the order in which they will actually be executed.</p>
<h3 id="non-linear-patterns">Non-Linear Patterns</h3>
<p>As explained in section <a href="#patterns">Patterns</a>, Pure allows multiple occurrences of the same variable in a pattern (so-called non-linearities):</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x x = x;</code></pre></div>
<p>This rule will only be matched if both occurrences of <code>x</code> are bound to the same value. More precisely, the two instances of <code>x</code> will be checked for syntactic equality during pattern matching, using the <a href="purelib.html#same"><code>same</code></a> primitive provided by the prelude. This may need time proportional to the sizes of both argument terms, and thus become quite costly for big terms. In fact, <a href="purelib.html#same"><code>same</code></a> might not even terminate at all if the compared terms are both infinite lazy data structures, such as in <code>foo (1..inf) (1..inf)</code>. So you have to be careful to avoid such uses.</p>
<p>When using non-linearities in conjunction with “as” patterns, you also have to make sure that the “as” variable does not occur inside the corresponding subpattern. Thus a definition like the following is illegal:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo xs@(x:xs) = x;
&lt;stdin&gt;, line <span class="dv">1</span>: error in pattern (recursive variable &#39;xs&#39;)</code></pre></div>
<p>The explanation is that such a pattern couldn’t possibly be matched by a finite list anyway. Indeed, the only match for <code>xs@(x:xs)</code> would be an infinite list of <code>x</code>’s, and there’s no way that this condition could be verified in a finite amount of time. Therefore the interpreter reports a “recursive variable” error in such situations.</p>
<h3 id="as-patterns">“As” Patterns</h3>
<p>In the current implementation, “as” patterns cannot be placed on the “spine” of a function definition. Thus rules like the following, which have the pattern somewhere in the head of the left-hand side, will all provoke an error message from the compiler:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">a@foo x y   = a,x,y;
a@(foo x) y = a,x,y;
a@(foo x y) = a,x,y;</code></pre></div>
<p>This is because the spine of a function application is not available when the function is called at runtime. “As” patterns in pattern bindings (<a href="#let"><code>let</code></a>, <a href="#const"><code>const</code></a>, <a href="#case"><code>case</code></a>, <a href="#when"><code>when</code></a>) are not affected by this restriction since the entire value to be matched is available at runtime. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">case</span> bar <span class="dv">99</span> <span class="kw">of</span> y@(bar x) = y,x+<span class="dv">1</span>; <span class="kw">end</span>;
bar <span class="dv">99</span>,<span class="dv">100</span></code></pre></div>
<h3 id="head-function-pitfalls">“Head = Function” Pitfalls</h3>
<p><a href="#the-head-function-rule">The “head = function” rule</a> stipulates that the head symbol <code>f</code> of an application <code>f x1 ... xn</code> occurring on (or inside) the left-hand side of an equation, variable binding, or pattern-matching lambda expression, is always interpreted as a literal function symbol (not a variable). This implies that you cannot match the “function” component of an application against a variable, at least not directly. An anonymous “as” pattern like <code>f@_</code> does the trick, however, since the anonymous variable is always recognized, even if it occurs as the head symbol of a function application. Here’s a little example which demonstrates how you can convert a function application to a list containing the function and all arguments:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x = a [] x <span class="kw">with</span> a xs (x@_ y) = a (y:xs) x; a xs x = x:xs <span class="kw">end</span>;
&gt; foo (a b c d);
[a,b,c,d]</code></pre></div>
<p>This may seem a little awkward, but as a matter of fact the “head = function” rule is quite convenient, since it covers the common cases without forcing the programmer to declare variable or constructor symbols (other than nonfix symbols). On the other hand, generic rules operating on arbitrary function applications are not all that common, so having to “escape” a variable using the anonymous “as” pattern trick is a small price to pay for that convenience.</p>
<p>Sometimes you may also run into the complementary problem, i.e., to match a function argument against a given function. Consider this code fragment:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foo x = x+<span class="dv">1</span>;
foop f = <span class="kw">case</span> f <span class="kw">of</span> foo = <span class="dv">1</span>; _ = <span class="dv">0</span> <span class="kw">end</span>;</code></pre></div>
<p>You might expect <code>foop</code> to return true for <code>foo</code>, and false on all other values, but in reality <code>foop</code> will always return true! In fact, the Pure compiler will warn you about the second rule of the <a href="#case"><code>case</code></a> expression not being used at all:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foop <span class="dv">99</span>;
warning: rule never reduced: _ = <span class="dv">0</span>;
<span class="dv">1</span></code></pre></div>
<p>This is again due to the “head = function” rule; <code>foo</code> is neither the head symbol of a function application nor a <a href="#nonfix"><code>nonfix</code></a> symbol here, so it is considered a variable, even though it is defined as a global function elsewhere. (As a matter of fact, this is rather useful, since otherwise a rule like <code>f g = g+1</code> would suddenly change meaning if you happen to add a definition like <code>g x = x-1</code> somewhere else in your program, which certainly isn’t desirable.)</p>
<p>A possible workaround is to “escape” the function symbol using an empty namespace qualifier:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">foop f = <span class="kw">case</span> f <span class="kw">of</span> ::foo = <span class="dv">1</span>; _ = <span class="dv">0</span> <span class="kw">end</span>;</code></pre></div>
<p>This trick works in <a href="#case"><code>case</code></a> expressions and function definitions, but fails in circumstances in which qualified variable symbols are permitted (i.e., in variable and constant definitions). A better solution is to employ the syntactic equality operator <code>===</code> defined in the prelude to match the target value against the function symbol. This allows you to define the <code>foop</code> predicate as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foop f = f===foo;
&gt; foop foo, foop <span class="dv">99</span>;
<span class="dv">1</span>,<span class="dv">0</span></code></pre></div>
<p>Another way to deal with the situation would be to just declare <code>foo</code> as a nonfix symbol. However, this makes the <code>foo</code> symbol “precious”, i.e., after such a declaration it cannot be used as a local variable anymore. It’s usually a good idea to avoid that kind of thing, at least for generic symbols, so the above solution is preferred in this case.</p>
<h3 id="defined-functions">Defined Functions</h3>
<p>As explained in <a href="#definitions-and-expression-evaluation">Definitions and Expression Evaluation</a>, Pure doesn’t really distinguish “constructors” from “defined functions” and thus allows any function symbol to become part of a normal form expression yielded by an evaluation. This behaviour follows the usual semantics of (typeless) term rewriting and is essential if you also want to evaluate expressions symbolically.</p>
<p>However, this becomes a nuisance if you really expect the given function to reduce to something else, and just accidentally supplied the wrong arguments to the function. Especially annoying in this respect are functions involving side effects:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> system;
&gt; puts <span class="dv">99</span>;
puts <span class="dv">99</span></code></pre></div>
<p>Here we accidentally specified a number (rather than a string) as the argument of the <a href="purelib.html#puts"><code>puts</code></a> function. This kind of error can easily be spotted if the function is invoked interactively, but it may well go unnoticed if the call is buried deeply in a big program which runs unattended (in batch mode).</p>
<p>As a remedy, Pure 0.48 introduces the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragma (cf. <a href="#code-generation-options">Code Generation Options</a>) which allows you to explicitly declare a function symbol as a “defined” function, so that it will raise a proper exception when the defining equations (or, as it were, the external definition) of the function are not applicable to the subject expression:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --defined puts
&gt; puts <span class="dv">99</span>;
&lt;stdin&gt;, line <span class="dv">4</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;puts <span class="dv">99</span>&#39;</code></pre></div>
<p>This is the same kind of <a href="purelib.html#failed_match"><code>failed_match</code></a> exception that you’ll get, e.g., if the subject term fails to match all patterns in a <a href="#case"><code>case</code></a> construct, cf. <a href="#exception-handling">Exception Handling</a>.</p>
<p>Note that the <a href="#cmdoption-purepragma%20--defined"><code>--defined</code></a> pragma only has an effect on global functions; local functions in a <a href="#with"><code>with</code></a> expression will always be evaluated in Pure’s default symbolic mode. Thus, if you need the above behaviour with a local function then you’ll either have to add the exception handling yourself or turn the local function into a global one.</p>
<p>Also note that an exception will only be generated if the symbol actually has any defining equations, so a “pure constructor” (i.e., a symbol without defining equations) will still return a normal form even if it is also declared <a href="#cmdoption-purepragma%20--defined"><code>--defined</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --defined foo
&gt; foo bar;
foo bar</code></pre></div>
<p>Nevertheless, the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragma will be recorded and take effect as soon as you add an equation for the function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; foo x::<span class="dt">int</span> = x+<span class="dv">1</span>;
&gt; foo bar;
&lt;stdin&gt;, line <span class="dv">4</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;foo bar&#39;</code></pre></div>
<p>There’s also a <a href="#cmdoption-pure-pragma--nodefined"><code>--nodefined</code></a> pragma which reverts the function to the default behaviour of returning normal forms:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --nodefined foo
&gt; foo bar;
foo bar</code></pre></div>
<p>As indicated, the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> and <a href="#cmdoption-pure-pragma--nodefined"><code>--nodefined</code></a> pragmas can be invoked freely at any time, and the interpreter takes care that the affected function is recompiled automatically as needed.</p>
<p>Pure 0.58 and later also provide a <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> compilation option which lets you switch the interpreter to the non-symbolic mode of operation, so that <em>every</em> global function with equations becomes a defined function. This option is most commonly used as a pragma to delineate code sections with defined functions, so that you don’t have to write out the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> pragmas for each function. The <a href="#cmdoption-pure--symbolic"><code>--symbolic</code></a> pragma is then used to switch back to the default symbolic mode. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; run
&gt; #! --nosymbolic
&gt; <span class="kw">extern</span> <span class="dt">int</span> puts(<span class="dt">char</span>*);
&gt; foo x::<span class="dt">int</span> = x+<span class="dv">1</span>;
&gt; puts <span class="dv">99</span>;
&lt;stdin&gt;, line <span class="dv">4</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;puts <span class="dv">99</span>&#39;
&gt; foo bar;
&lt;stdin&gt;, line <span class="dv">5</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;foo bar&#39;
&gt; #! --symbolic
&gt; bar x::<span class="dt">int</span> = x-<span class="dv">1</span>;
&gt; bar foo;
bar foo</code></pre></div>
<p>Note that these pragmas only adjust the default behaviour of functions. It is still possible to change the status of individual functions with the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> and <a href="#cmdoption-pure-pragma--nodefined"><code>--nodefined</code></a> pragmas:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --nodefined foo
&gt; foo bar;
foo bar
&gt; #! --defined bar
&gt; bar foo;
&lt;stdin&gt;, line <span class="dv">12</span>: unhandled exception &#39;failed_match&#39; while evaluating &#39;bar foo&#39;</code></pre></div>
<p>You can even invoke the interpreter with the <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> command line option so that the non-symbolic mode becomes the global default. However, this affects <em>all</em> functions in a program, including the library functions used by your program. It isn’t really advisable to do this, because at the time of this writing many library modules still assume Pure’s default mode of symbolic evaluation, and so a global switch to <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> may well break some of these functions.</p>
<p>At this time, the <a href="#cmdoption-pure-pragma--defined"><code>--defined</code></a> and <a href="#cmdoption-pure--nosymbolic"><code>--nosymbolic</code></a> pragmas are still considered experimental. They interfere with Pure’s symbolic evaluation capabilities, so they aren’t currently used in the standard library and we recommend that programmers shouldn’t use them in a careless fashion either. However, while most error conditions stemming from unexpected normal forms can also be caught with diligent unit testing, these pragmas can save you time and trouble, especially when testing programs which are to be executed mostly in batch mode. Future versions of the interpreter might also make good use of these pragmas for static checks and optimization purposes.</p>
<h3 id="stack-size-and-tail-recursion">Stack Size and Tail Recursion</h3>
<p>Pure programs may need a considerable amount of stack space to handle recursive function and macro calls, and the interpreter itself also takes its toll. So you should configure your system accordingly (8 MB of stack space is recommended for 32 bit systems, systems with 64 bit pointers probably need more). The interpreter automatically performs advisory stack checks on function entry and raises a Pure exception if the current stack size exceeds a given limit. A reasonable default for the stack limit is defined by the implementation, please check the description of the <a href="#envvar-PURE_STACK"><code>PURE_STACK</code></a> environment variable for details.</p>
<p>You can also change this limit if needed, by setting the <a href="#envvar-PURE_STACK"><code>PURE_STACK</code></a> environment variable accordingly. The value of <a href="#envvar-PURE_STACK"><code>PURE_STACK</code></a> should be the maximum stack size in kilobytes. Please note that this is only an advisory limit which does not change the program’s physical stack size, so you can set this to any value that seems appropriate. (You can also set <a href="#envvar-PURE_STACK"><code>PURE_STACK</code></a> to zero to completely disable the checks, but this isn’t recommended.) Your operating system should supply you with a command such as ulimit(1) to set the real process stack size. (The <a href="#envvar-PURE_STACK"><code>PURE_STACK</code></a> limit should be a little less than that, to account for temporary stack usage by the interpreter itself.)</p>
<p>Like Scheme, Pure does proper tail calls (if LLVM provides that feature on the platform at hand), so tail-recursive definitions should work fine in limited stack space. For instance, the following little program will loop forever if your platform supports the required optimizations:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">loop <span class="kw">with</span> loop = loop <span class="kw">end</span>;</code></pre></div>
<p>This also works if your definition involves function parameters, guards and multiple equations, of course. Moreover, conditional expressions (<a href="#if"><code>if</code></a>-<a href="#then"><code>then</code></a>-<a href="#else"><code>else</code></a>) are tail-recursive in both branches, and the logical operators <a href="#&amp;&amp;/special"><code>&amp;&amp;</code></a> and <a href="#%7C%7C/special"><code>||</code></a>, as well as the sequence operator <a href="#$$"><code>$$</code></a>, are tail-recursive in their second operand.</p>
<p>In addition, the Pure compiler also does a specialized form of tail recursion optimization for type definition rules. Due to the special way in which type tags are processed, however, the amount of optimization performed in this case is somewhat limited; see <a href="#recursive-types">Recursive Types</a> below.</p>
<p>Finally, note that tail call optimization is <em>always</em> disabled if the debugger is enabled (-g). This makes it much easier to debug programs, but means that you may run into stack overflows when debugging a program that does deep tail recursion.</p>
<h3 id="handling-of-asynchronous-signals">Handling of Asynchronous Signals</h3>
<p>As described in section <a href="#exception-handling">Exception Handling</a>, signals delivered to the process can be caught and handled with Pure’s exception handling facilities. This has its limitations, however. Since Pure code cannot be executed directly from a C signal handler, checks for pending signals are only done on function entry. This means that in certain situations (such as the execution of an external C routine), delivery of a signal may be delayed by an arbitrary amount of time. Moreover, if more than one signal arrives between two successive signal checks, only the last one will be reported in the current implementation.</p>
<p>When delivering a signal which has been remapped to a Pure exception, the corresponding exception handler (if any) will be invoked as usual. Further signals are blocked while the exception handler is being executed.</p>
<p>A fairly typical case is that you have to handle signals in a tail-recursive function. This can be done with code like the following:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">using</span> system;

<span class="co">// Remap some common POSIX signals.</span>
do (trap SIG_TRAP) [SIGHUP, SIGINT, SIGTERM];

loop = <span class="fu">catch</span> handler process $$ loop
<span class="kw">with</span> handler (signal k) = printf <span class="st">&quot;Hey, I got signal %d.</span><span class="ch">\n</span><span class="st">&quot;</span> k <span class="kw">end</span>;
process = sleep <span class="dv">1</span>; <span class="co">// do something</span></code></pre></div>
<p>Running the above <code>loop</code> function enters an endless loop reporting all signals delivered to the process. Note that to make this work, the tail-recursive invocation of <code>loop</code> must immediately follow the signal-handling code, so that signals don’t escape the exception handler.</p>
<p>Of course, in a real application you’d probably want the <code>loop</code> function to carry around some data to be processed by the <code>process</code> routine, which then returns an updated value for the next iteration. This can be implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">loop x = loop (<span class="fu">catch</span> handler (process x))
<span class="kw">with</span> handler (signal k) = printf <span class="st">&quot;Hey, I got signal %d.</span><span class="ch">\n</span><span class="st">&quot;</span> k $$ <span class="dv">0</span> <span class="kw">end</span>;
process x = printf <span class="st">&quot;counting: %d</span><span class="ch">\n</span><span class="st">&quot;</span> x $$ sleep <span class="dv">1</span> $$ x+<span class="dv">1</span>;</code></pre></div>
<h3 id="recursive-types">Recursive Types</h3>
<p>Using the facilities described in <a href="#type-rules">Type Rules</a>, type tags can easily be defined in a recursive fashion. In simple cases, the compiler can optimize such definitions so that they are executed in constant stack space, just like ordinary tail-recursive functions. The main difference here is that the recursion already takes place during <em>matching</em>, i.e., on the <em>left-hand</em> side of a rule, since this is where type predicates are normally invoked. This also limits the amount of tail recursion optimization available on type rules, as detailed below.</p>
<p>For instance, the following <a href="purelib.html#rlist/type"><code>rlist</code></a> type from the prelude is defined in such a way that it only matches “proper” lists which have list values in all their tails (and are thus terminated by the empty list).</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> rlist [] | rlist (x : xs::rlist);</code></pre></div>
<p>Note that this type definition recurses in the <em>last</em> <a href="purelib.html#rlist/type"><code>rlist</code></a> tag of the <em>last</em> rule of the type. If tail calls are supported by the host implementation (cf. <a href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>), the compiler makes sure that such definitions are safe to use even if the recursion may go arbitrarily deep. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; typep rlist (<span class="dv">1</span>..<span class="dv">10000000</span>);
<span class="dv">1</span></code></pre></div>
<p>The precise rules for tail-recursive type definitions are as follows:</p>
<ul>
<li>The <em>last</em> rule of the type must have a trivial right-hand side (either just <a href="purelib.html#true"><code>true</code></a> or missing) and must be <em>directly</em> recursive in the <em>last</em> type tag on the left-hand side of the rule.</li>
<li>The rule may not contain any non-linearities. (That’s because these are always checked <em>after</em> the type guards for efficiency.)</li>
</ul>
<p>While these are rather strict requirements, they work reasonably well for simple recursive types such as the recursive list type above. More general recursion in types will not be optimized by the compiler, however, and may thus be subject to stack overflows. For instance, consider the following binary tree type:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">nonfix</span> nil;
<span class="kw">type</span> tree nil | tree (bin x l::tree r::tree);</code></pre></div>
<p>This is a perfectly legal type definition, and the recursion in the last <code>tree</code> tag of the second rule will indeed be optimized away. However, the second rule also recurses on the <em>first</em> <code>tree</code> tag which will cause trouble if there are long chains of left branches in a tree. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; mktree xs = foldr (\x t-&gt;bin x t nil) nil xs;
&gt; mktree [];
nil
&gt; mktree [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>];
bin <span class="dv">1</span> (bin <span class="dv">2</span> (bin <span class="dv">3</span> nil nil) nil) nil
&gt; typep tree (mktree []);
<span class="dv">1</span>
&gt; typep tree (mktree [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]);
<span class="dv">1</span>
&gt; typep tree (mktree (<span class="dv">1</span>..<span class="dv">10000</span>));
&lt;stdin&gt;, line <span class="dv">6</span>: unhandled exception &#39;stack_fault&#39; while evaluating
&#39;typep tree (mktree (<span class="dv">1</span>..<span class="dv">10000</span>))&#39;</code></pre></div>
<p>To avoid deep recursion in such cases it is necessary to implement the type using a general predicate, which handles the recursion by transforming it into a tail-recursive form using a technique like <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing</a>.</p>
<p>There’s yet another important issue with recursive type definitions, namely the <em>time</em> it takes to check the definition. In the above example, checking <a href="purelib.html#rlist/type"><code>rlist</code></a> takes <span class="math inline"><em>O</em>(<em>n</em>)</span> time, where n is the size of the list. This will have dire consequences if you do this check repeatedly while traversing a list, as in the following <code>sum</code> function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum xs::rlist = <span class="kw">if</span> null xs <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> head xs+sum (tail xs);</code></pre></div>
<p>As this function repeatedly checks its entire argument, the total time it takes to compute the sum of a list this way becomes <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>. To see how slow this function is, just try it on successively larger lists <code>1..1000</code>, <code>1..2000</code>, etc. One way to work around this is to write a “wrapper” function which simply checks the type of its argument in advance and then invokes a “worker” function to do the actual computation:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">sum xs::rlist = sum xs <span class="kw">with</span>
  sum xs = <span class="kw">if</span> null xs <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> head xs+sum (tail xs);
<span class="kw">end</span>;</code></pre></div>
<p>This “wrapper-worker” design is quite common and useful in many situations, but it is a bit cumbersome in this specific case. An easier way is to just do the type checking in a piecemeal fashion, as the list is being traversed. To these ends, the prelude also provides a basic <a href="purelib.html#list/type"><code>list</code></a> type which is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">type</span> list [] | list (x:xs);</code></pre></div>
<p>Note that the recursion is missing here and thus this type can always be checked in <span class="math inline"><em>O</em>(1)</span> time, performing just a single pattern match, which is efficient. Hence, if we replace <a href="purelib.html#rlist/type"><code>rlist</code></a> with the <a href="purelib.html#list/type"><code>list</code></a> type in our original definition then <code>sum</code> will now run in <span class="math inline"><em>O</em>(<em>n</em>)</span> time, as desired. On the other hand, this approach also has its drawbacks. For instance, consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sum xs::list = <span class="kw">if</span> null xs <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> head xs+sum (tail xs);
&gt; sum (<span class="dv">1</span>:<span class="dv">2</span>:<span class="dv">3</span>);
<span class="dv">1</span>+(<span class="dv">2</span>+sum <span class="dv">3</span>)</code></pre></div>
<p>In contrast, our wrapper-worker definition of <code>sum</code> from above returns a somewhat prettier normal form instead:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear sum
&gt; sum xs::rlist = sum xs <span class="kw">with</span>
&gt;   sum xs = <span class="kw">if</span> null xs <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> head xs+sum (tail xs);
&gt; <span class="kw">end</span>;
&gt; sum (<span class="dv">1</span>:<span class="dv">2</span>:<span class="dv">3</span>);
sum (<span class="dv">1</span>:<span class="dv">2</span>:<span class="dv">3</span>)</code></pre></div>
<p>Thus the wrapper-worker approach also has its merits, and whether to use one or the other depends on the situation. Similar techniques and tradeoffs also apply to other recursive types such as trees.</p>
<h3 id="interfaces">Interfaces</h3>
<p>Pure’s implementation of <a href="#interface-types">interface types</a> has some notable differences to interfaces in a statically typed language like <a href="#go">Go</a>. These are mostly due to Pure’s dynamically typed nature.</p>
<ul>
<li>Nothing is known about the <em>return type</em> of an interface operation, but this is no real impediment since Pure types are all about restricting the kind of <em>arguments</em> which can be passed to a function, not their result types, so return types are irrelevant to Pure’s interface types anyway.</li>
<li>Pure interfaces aren’t based on the notion of “methods” and therefore don’t provide any kind of “method dispatch”. Interface operations are just ordinary Pure functions which rely on Pure’s usual pattern-matching mechanism to do the dynamic dispatch.</li>
<li>Membership in interface types is decided by considering the left-hand sides of the definitions of the interface functions only. Guards are not taken into account, and thus there’s no real guarantee that a member of an interface type will always be valid input to an interface function.</li>
<li><p>Interface types work best if all interface operations are completely defined on the target data domain. This may sometimes force you to add default or error rules raising exceptions, as shown in the <a href="#interface-types">Interface Types</a> section, which may interfere with symbolic evaluation (cf. <a href="#exception-handling">Exception Handling</a> and <a href="#defined-functions">Defined Functions</a>). If this is not desirable, you can also just include the missing members manually. To these ends, Pure allows an interface type to be augmented with ordinary type rules as described in <a href="#type-rules">Type Rules</a>. For instance, we might also have implemented the stack type discussed in the <a href="#interface-types">Interface Types</a> section as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> stack <span class="kw">with</span>
  push s::stack x;
  pop s::stack;
  top s::stack;
<span class="kw">end</span>;

<span class="kw">type</span> stack [];

push xs@[] x | push xs@(_:_) x = x:xs;
pop (x:xs) = xs;
top (x:xs) = x;</code></pre></div></li>
</ul>
<p>Pure’s interface types are really a compromise between theoretical soundness and practicality. From the theoretical point of view, we’d like an interface type to be the <em>intersection</em> of the interface types for the individual interface functions. Unfortunately, the pattern set for such an intersection type might well be exponential in size. Hence the approach taken in Pure is to eliminate those candidate patterns which aren’t supported by all interface functions. This can be done much more efficiently, but will in general only produce a subtype of the intersection type. (On the other hand, this method also has the advantage that the compiler can warn about potentially missing rules in some of the interface operations. We’ve seen in the <a href="#interface-types">Interface Types</a> section that this can be fairly useful at times.)</p>
<p>Another issue arises with interface operations which allow the interface type in multiple arguments. A typical example are operators:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> addable <span class="kw">with</span> x::addable + y::addable; <span class="kw">end</span>;</code></pre></div>
<p>In the present implementation, the pattern set will be the <em>union</em> of the pattern sets for each argument, so the above definition is in fact equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">interface</span> addable <span class="kw">with</span> x::addable + y; x + y::addable; <span class="kw">end</span>;</code></pre></div>
<p>This makes sense in many situations, but of course this depends on the particular operation. In some cases, you might have to decide on which argument you want to place the interface type tag, or even have different types for each possible argument position.</p>
<h3 id="numeric-calculations">Numeric Calculations</h3>
<p>If possible, you should decorate numeric variables on the left-hand sides of function definitions with the appropriate type tags, like <code>int</code> or <code>double</code>. This often helps the compiler to generate better code and makes your programs run faster. The <code>|</code> syntax makes it easy to add the necessary specializations of existing rules to your program. E.g., taking the polymorphic implementation of the factorial as an example, you only have to add a left-hand side with the appropriate type tag to make that definition go as fast as possible for the special case of machine integers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fact n::<span class="dt">int</span>    |
fact n         = n*fact(n-<span class="dv">1</span>) <span class="kw">if</span> n&gt;<span class="dv">0</span>;
               = <span class="dv">1</span> <span class="kw">otherwise</span>;</code></pre></div>
<p>(This obviously becomes unwieldy if you have to deal with several numeric arguments of different types, however, so in this case it is usually better to just use a polymorphic rule.)</p>
<p>Also note that int (the machine integers), bigint (the GMP “big” integers) and double (floating point numbers) are all different kinds of objects. While they can be used in mixed operations (such as multiplying an int with a bigint which produces a bigint, or a bigint with a double which produces a double), the <code>int</code> tag will only ever match a machine int, <em>not</em> a bigint or a double. Likewise, <code>bigint</code> only matches bigints (never int or double values), and <code>double</code> only doubles. Thus, if you want to define a function operating on different kinds of numbers, you’ll also have to provide equations for all the types that you need (or a polymorphic rule which catches them all). This also applies to equations matching against constant values of these types. In particular, a small integer constant like <code>0</code> only matches machine integers, not bigints; for the latter you’ll have to use the “big L” notation <code>0L</code>. Similarly, the constant <code>0.0</code> only matches doubles, but not ints or bigints.</p>
<h3 id="constant-definitions">Constant Definitions</h3>
<p>Constants differ from variables in that they cannot be redefined (that’s their main purpose after all) so that their values, once defined, can be substituted into other definitions which use them. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">const</span> c = <span class="dv">2</span>;
&gt; foo x = c*x;
&gt; show foo
foo x = <span class="dv">2</span>*x;
&gt; foo <span class="dv">99</span>;
<span class="dv">198</span></code></pre></div>
<p>While a variable can be rebound to a new value at any time, you will get an error message if you try to do this with a constant:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">const</span> c = <span class="dv">3</span>;
&lt;stdin&gt;, line <span class="dv">5</span>: symbol &#39;c&#39; is already defined as a constant</code></pre></div>
<p>Note that in interactive mode you can work around this by purging the old definition with the <code>clear</code> command. However, this won’t affect any earlier uses of the symbol:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; clear c
&gt; <span class="kw">const</span> c = <span class="dv">3</span>;
&gt; bar x = c*x;
&gt; show foo bar
bar x = <span class="dv">3</span>*x;
foo x = <span class="dv">2</span>*x;</code></pre></div>
<p>(You’ll also have to purge any existing definition of a variable if you want to redefine it as a constant, or vice versa, since Pure won’t let you redefine an existing constant or variable as a different kind of symbol. The same also holds if a symbol is currently defined as a function or a macro.)</p>
<p>Constants can also be used in patterns (i.e., on the left-hand side of a rule in a definition or a <a href="#case"><code>case</code></a> expression), but only if they’re also declared as <a href="#nonfix"><code>nonfix</code></a>. The prelude already does this for the truth values <a href="purelib.html#true"><code>true</code></a> and <a href="purelib.html#false"><code>false</code></a> (which are in fact just <code>1</code> and <code>0</code>), so that you can write, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; check false = <span class="st">&quot;no&quot;</span>; check true = <span class="st">&quot;yes&quot;</span>;
&gt; show check
check <span class="dv">0</span> = <span class="st">&quot;no&quot;</span>;
check <span class="dv">1</span> = <span class="st">&quot;yes&quot;</span>;
&gt; check (<span class="dv">5</span>&gt;<span class="dv">0</span>);
<span class="st">&quot;yes&quot;</span></code></pre></div>
<p>Note that if <a href="purelib.html#true"><code>true</code></a> and <a href="purelib.html#false"><code>false</code></a> weren’t <a href="#nonfix"><code>nonfix</code></a>, the above definition of <code>check</code> wouldn’t work as intended, because the <a href="purelib.html#true"><code>true</code></a> and <a href="purelib.html#false"><code>false</code></a> symbols on the left-hand side of the two equations would be interpreted as local variables. Also note that <a href="purelib.html#true"><code>true</code></a> and <a href="purelib.html#false"><code>false</code></a> are really an exceptional case; they aren’t likely to be used as variables, so the prelude can make them <a href="#nonfix"><code>nonfix</code></a> by default. In most cases the standard library refrains from declaring constant symbols as <a href="#nonfix"><code>nonfix</code></a>, so that they don’t accidentally clobber variables in user code. This is the case, in particular, for constants in the <a href="purelib.html#module-math">math</a> module such as <a href="purelib.html#e"><code>e</code></a>, <a href="purelib.html#pi"><code>pi</code></a> and <a href="purelib.html#i"><code>i</code></a> which are much more likely to be used as variable symbols.</p>
<p>As the value of a constant is known at compile time, the compiler can apply various optimizations to uses of such values. In particular, the Pure compiler inlines constant scalars (numbers, strings and pointers) by literally substituting their values into the output code. It also precomputes simple constant expressions involving only (machine) integer and double values. (The latter is called <strong>constant folding</strong> and can also be disabled, see the description of the <a href="#cmdoption-pure--fold"><code>--fold</code></a> and <a href="#cmdoption-pure--nofold"><code>--nofold</code></a> pragmas for details.) Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">double</span> atan(<span class="dt">double</span>);
&gt; <span class="kw">const</span> pi = <span class="dv">4</span>*atan <span class="dv">1.0</span>;
&gt; show pi
<span class="kw">const</span> pi = <span class="dv">3.14159265358979</span>;
&gt; foo x = <span class="dv">2</span>*pi*x;
&gt; show foo
foo x = <span class="dv">6.28318530717959</span>*x;</code></pre></div>
<p>Constant folding also works with conditional expressions. E.g., consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">const</span> win = index sysinfo <span class="st">&quot;mingw32&quot;</span> &gt;= <span class="dv">0</span>;
check boy = <span class="kw">if</span> win <span class="kw">then</span> bad boy <span class="kw">else</span> good boy;</code></pre></div>
<p>On a Linux system, this gives:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show check
check boy = good boy;</code></pre></div>
<p>By these means, you can employ a constant to configure your code for different environments, without any runtime penalties. Note that this only works with conditional expressions, not with guarded equations. However, in the latter case the LLVM backend still eliminates dead code automatically, so the <code>check</code> function from above could also be defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">check boy = bad boy <span class="kw">if</span> win;
          = good boy <span class="kw">otherwise</span>;</code></pre></div>
<p>In this case the code for one of the branches of <code>check</code> will be completely eliminated, depending on the outcome of the configuration check. (The interpreter will still print both equations if you type <code>show check</code>, but only one of the branches will actually be present in the assembler code of the function; you can verify this with <code>show -d check</code>.)</p>
<p>For efficiency, constant aggregates (lists, tuples, matrices and other kinds of non-scalar terms) receive special treatment. Here, the constant is computed once and stored in a read-only variable which then gets looked up at runtime, just like an ordinary global variable. However, there’s an important difference: If a script is batch-compiled (cf. <a href="#batch-compilation">Batch Compilation</a>), the constant value is normally computed <em>at compile time only</em>; when running the compiled executable, the constant value is simply reconstructed, which is often much more efficient than recomputing its value. For instance, you might use this to precompute a large table whose computation may be costly or involve functions with side effects:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">const</span> table = [foo x | x = <span class="dv">1</span>..<span class="dv">1000000</span>];
process table;</code></pre></div>
<p>Note that this only works with <a href="#const"><code>const</code></a> values which are completely determined at compile time. If a constant contains run time objects such as (non-null) pointers and (local) functions, this is impossible, and the batch compiler will instead create code to recompute the value of the constant at run time. For instance, consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">const</span> p = malloc <span class="dv">100</span>;
foo p;</code></pre></div>
<p>Here, the value of the pointer <code>p</code> of course critically depends on its computation (involving a side effect which sets aside a corresponding chunk of memory). It would become unusable without actually executing the initialization, so the compiler generates the appropriate run time initialization code in this case. For all practical purposes, this turns the constant into a read-only variable. (There’s also a code generation option to force this behaviour even for “normal” constants for which it’s not strictly necessary, in order to create smaller executables; see <a href="#options-affecting-code-size">Options Affecting Code Size</a> for details.)</p>
<h3 id="external-c-functions">External C Functions</h3>
<p>The interpreter always takes your <a href="#extern"><code>extern</code></a> declarations of C routines at face value. It will not go and read any C header files to determine whether you actually declared the function correctly! So you have to be careful to give the proper declarations, otherwise your program might well give a segfault when calling the function. This problem can to some extent be alleviated by using the bitcode interface, see <a href="#importing-llvm-bitcode">Importing LLVM Bitcode</a> and <a href="#inline-code">Inline Code</a> in the <a href="#c-interface">C Interface</a> section. However, you always have to be careful when calling <a href="#variadic-c-functions">variadic C functions</a>, as the compiler has no way of checking which combinations of extra parameters a function like <code>printf</code> is to be invoked with. (As a remedy, the standard library provides safe implementations of <a href="purelib.html#printf"><code>printf</code></a> and other commonly used variadic functions from the C library, see the <a href="purelib.html">Pure Library Manual</a> for details.)</p>
<p>Another limitation of the C interface is that it does not offer any special support for C structs and C function parameters. However, an optional addon module is available which interfaces to the <a href="http://sourceware.org/libffi/">libffi</a> library to provide that kind of functionality, please see <a href="pure-ffi.html">pure-ffi</a> for details.</p>
<p>Last but not least, to make it easier to create Pure interfaces to large C libraries, there’s a separate pure-gen program available at the Pure website. This program takes a C header (.h) file and creates a corresponding Pure module with definitions and <a href="#extern"><code>extern</code></a> declarations for the constants and functions declared in the header. Please refer to <a href="pure-gen.html">pure-gen: Pure interface generator</a> for details.</p>
<h3 id="calling-special-forms">Calling Special Forms</h3>
<p>Special forms are recognized at compile time only. Thus the <a href="#catch"><code>catch</code></a> function, as well as <a href="#quote"><code>quote</code></a> and the operators <a href="#&amp;&amp;/special"><code>&amp;&amp;</code></a>, <a href="#%7C%7C/special"><code>||</code></a>, <a href="#$$"><code>$$</code></a> and <a href="#&amp;"><code>&amp;</code></a>, are only treated as special forms in direct (saturated) calls. They can still be used if you pass them around as function values or in partial applications, but in this case they lose all their special call-by-name argument processing.</p>
<h3 id="laziness">Laziness</h3>
<p>Pure does lazy evaluation in the same way as <a href="#alice-ml">Alice ML</a>, providing an explicit operation (<a href="#&amp;"><code>&amp;</code></a>) to defer evaluation and create a “future” which is called by need. However, note that like any language with a basically eager evaluation strategy, Pure cannot really support lazy evaluation in a fully automatic way. That is, coding an operation so that it works with infinite data structures usually requires additional thought, and sometimes special code will be needed to recognize futures in the input and handle them accordingly. This can be hard, but of course in the case of the prelude operations this work has already been done for you, so as long as you stick to these, you’ll never have to think about these issues. (It should be noted here that lazy evaluation has its pitfalls even in fully lazy FPLs, such as hidden memory leaks and other kinds of subtle inefficiencies or non-termination issues resulting from definitions being too lazy or not lazy enough. You can read about that in any good textbook on Haskell.)</p>
<p>The prelude goes to great lengths to implement all standard list operations in a way that properly deals with streams (a.k.a. lazy lists). What this all boils down to is that all list operations which can reasonably be expected to operate in a lazy way on streams, will do so. (Exceptions are inherently eager operations such as <a href="purelib.html##"><code>#</code></a>, <a href="purelib.html#reverse"><code>reverse</code></a> and <a href="purelib.html#foldl"><code>foldl</code></a>.) Only those portions of an input stream will be traversed which are strictly required to produce the result. For most purposes, this works just like in fully lazy FPLs such as Haskell. However, there are some notable differences:</p>
<ul>
<li>Since Pure uses dynamic typing, some of the list functions may have to peek ahead one element in input streams to check their arguments for validity, meaning that these functions will be slightly more eager than their Haskell counterparts.</li>
<li>Pure’s list functions never produce truly cyclic list structures such as the ones you get, e.g., with Haskell’s <code>cycle</code> operation. (This is actually a good thing, because the current implementation of the interpreter cannot garbage-collect cyclic expression data; please see the corresponding remarks in <a href="purelib.html#expression-references">Expression References</a> for details.) Cyclic streams such as <code>cycle [1]</code> or <code>fix (1:)</code> will of course work as expected, but, depending on the algorithm, memory usage may increase linearly as they are traversed.</li>
<li>Pattern matching is always refutable (and therefore eager) in Pure. If you need something like Haskell’s irrefutable matches, you’ll have to code them explicitly using futures. See the definition of the <a href="purelib.html#unzip"><code>unzip</code></a> function in the prelude for an example showing how to do this.</li>
</ul>
<p>There are two other pitfalls with lazy data structures that you should be aware of:</p>
<ul>
<li><p>Laziness and side effects don’t go well together, as most of the time you can’t be sure when a given thunk will be executed. So as a general guideline you should avoid side effects in thunked data structures. If you can’t avoid them, then at least make sure that all accesses to the affected resources are done through a single instance of the thunked data structure. E.g., the following definition lets you create a stream of random numbers:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">using</span> math;
&gt; <span class="kw">let</span> xs = [random | _ = <span class="dv">1</span>..inf];</code></pre></div>
<p>This works as expected if only a single stream created with <a href="purelib.html#random"><code>random</code></a> exists in your program. However, as the <a href="purelib.html#random"><code>random</code></a> function in the <a href="purelib.html#module-math">math</a> module modifies an internal data structure to produce a sequence of pseudorandom numbers, using two or more such streams in your program will in fact modify the same underlying data structure and thus produce two disjoint subsequences of the same underlying pseudorandom sequence which might not be distributed uniformly any more.</p></li>
<li><p>You should avoid keeping references to potentially big (or even infinite) thunked data structures when traversing them (unless you specifically need to memoize the entire data structure). In particular, if you assign such a data structure to a local variable, the traversal of the data structure should then be invoked as a tail call. If you fail to do this, it forces the entire memoized part of the data structure to stay in main memory while it is being traversed, leading to rather nasty memory leaks. Please see the <code>all_primes</code> function in <a href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a> for an example.</p></li>
</ul>
<h3 id="name-capture">Name Capture</h3>
<p>As explained in the <a href="#macro-hygiene">Macro Hygiene</a> section, Pure macros are lexically scoped and thus “hygienic”. So in principle Pure macros are not susceptible to name capture. However, this principle only applies to “real” block constructs, not their quoted “placeholder” representations described in <a href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a>. One (rather obscure) case which deserves special attention is the case of macros involving free variables which are being called inside quoted block constructs. Note that this corresponds to the “mild” first form of name capture described in the <a href="#macro-hygiene">Macro Hygiene</a> section. For instance, consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">def</span> G x = x+y;
&gt; &#39;(G <span class="dv">10</span> <span class="kw">when</span> y = <span class="dv">99</span> <span class="kw">end</span>);
G <span class="dv">10</span> __when__ [y--&gt;<span class="dv">99</span>]
&gt; eval ans;
<span class="dv">109</span></code></pre></div>
<p>Here the free <code>y</code> variable of the macro <code>G</code> got captured by the quoted <a href="#when"><code>when</code></a> clause when the quoted expression is evaluated. This happens because, using call by value, the call <code>G 10</code> gets evaluated before the <a href="#__when__"><code>__when__</code></a> macro. So the behaviour of the macro evaluator in this case is in fact correct; the only remedy here is to avoid macros involving free variables inside a quoted block construct. The same applies to “<a href="#cmdoption-pure-pragma--quoteargs"><code>quoteargs</code></a>” macros which quote their arguments automatically, as described in <a href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a>. On the other hand, the described behaviour might even be useful at times, to forcibly rebind a free macro variable. The following little helper macro illustrates this trick:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; #! --quoteargs invoke
&gt; <span class="kw">def</span> invoke x = x;
&gt; foo = invoke (G <span class="dv">10</span> <span class="kw">when</span> y = <span class="dv">99</span> <span class="kw">end</span>);
&gt; show foo
foo = <span class="dv">10</span>+y <span class="kw">when</span> y = <span class="dv">99</span> <span class="kw">end</span>;
&gt; foo;
<span class="dv">109</span></code></pre></div>
<p>Besides the above form of real name capture in quoted specials, there’s also a case of apparent name capture in the expression printer which isn’t actually real name capture, but just looks like it was. The reason for this is that the expression printer currently doesn’t check for different bindings of the same variable identifier when it prints a (compile time) expression. For instance, consider:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">def</span> F x = x+y <span class="kw">when</span> y = x+<span class="dv">1</span> <span class="kw">end</span>;
&gt; foo y = F y;
&gt; show foo
foo y = y+y <span class="kw">when</span> y = y+<span class="dv">1</span> <span class="kw">end</span>;</code></pre></div>
<p>This <em>looks</em> as if <code>y</code> got captured, but in fact it’s not, it’s just the <code>show</code> command which displays the definition in an incorrect way. You can add the <code>-e</code> option to <code>show</code> which prints the deBruijn indices of locally bound symbols, then you see that the actual bindings are all right anyway:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; show -e foo
foo y<span class="co">/*0:1*/</span> = y<span class="co">/*1:1*/</span>+y<span class="co">/*0:*/</span> <span class="kw">when</span> y<span class="co">/*0:*/</span> = y<span class="co">/*0:1*/</span>+<span class="dv">1</span> <span class="kw">end</span>;</code></pre></div>
<p>Note that the number before the colon is the actual deBruijn index, the sequence of bits behind it is the subterm path. Thus the first instance of <code>y</code> in <code>y+y</code> (which has a deBruijn index of 1, indicating “one environment up”) actually refers to the <code>y</code> in the left-hand side <code>foo y</code>, while the second instance refers to the local binding <code>y = y+1</code> in the <a href="#when"><code>when</code></a> clause.</p>
<p>Alas, this means that if you use <code>dump</code> to write such a definition to a text file and read it back with <code>run</code> later, then the apparent name capture becomes a real one and you’ll get the wrong definition. This is an outright bug in the expression printer which will hopefully be fixed some time. But for the time being you will have to correct such glitches manually.</p>
<h2 id="author">Author</h2>
<p>Albert Gräf &lt;<a href="mailto:aggraef@gmail.com">aggraef@gmail.com</a>&gt;, Dept. of Computer Music, Johannes Gutenberg University of Mainz, Germany.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Pure wouldn’t be what it is without its users and other people interested in the language. In particular, I’d like to thank Scott E. Dillard, Rooslan S. Khayrov, Jim Pryor, Eddie Rucker, Libor Spacek, Jiri Spitz, Peter Summerland and Sergei Winitzki for their significant contributions of code, patches and documentation. Thanks are also due to Björn Lindig, Michel Salim, Ryan Schmidt and Zhihao Yuan who maintain the Arch Linux, Fedora, OSX and FreeBSD packages and ports, as well as to Vili Aapro, Jason E. Aten, Alvaro Castro Castilla, John Cowan, Chris Double, Tim Haynes, Wm Leler, John Lunney, Roman Neuhauser and Max Wolf for suggesting improvements and pointing out shortcomings, misfeatures and outright bugs. If it wasn’t for all these people and others who contribute to the lively discussions on the mailing list, this project probably wouldn’t have got anywhere.</p>
<p>Last but not least, a big thank you goes to Chris Lattner and the entire LLVM team. <a href="#llvm">LLVM</a> really changed the game for us compiler writers, as we can now stop worrying about all the nitty-gritty details of code generation and concentrate on the design and implementation of the programming language at hand.</p>
<h2 id="copying">Copying</h2>
<p>(The following explanations are not legal advice. Please read the full text of the licenses and consult qualified professional counsel for an interpretation of the license terms as they apply to you.)</p>
<p>Pure comes with a fairly liberal license which lets you distribute your own Pure programs and extensions under a license of your choice and permits linking of commercial applications against the Pure runtime and the Pure standard library without requiring special permission. The Pure interpreter (the <code>pure</code> main program), the Pure runtime library (<code>libpure</code>) and the Pure standard library (the Pure scripts in the <code>lib</code> folder distributed with the software) are distributed as free software, and you are welcome to modify and redistribute them under the appropriate license terms, as detailed below.</p>
<p>The <em>Pure interpreter</em> is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>The <em>Pure runtime library</em> and the <em>Pure standard library</em> are also free software: you can redistribute them and/or modify them under the terms of the GNU <em>Lesser</em> General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>Pure is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p>One thing to note here is that the interpreter program is distributed under the <a href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> and is thus subject to stricter license terms than the runtime library and the standard library which are licensed under the <a href="http://www.gnu.org/copyleft/lgpl.html">GNU Lesser General Public License</a>. The main reason for these conditions is that the interpreter program includes support for the readline library which is GPL-licensed software. If this is a problem for your application then you’re welcome to use pure_norl.cc instead. This is a readline-free replacement for the interpreter main program included in the distribution, which is licensed under a 3-clause BSD-style license.</p>
<p>Please see the <a href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> and the <a href="http://www.gnu.org/copyleft/lgpl.html">GNU Lesser General Public License</a> for the precise license terms. You can also find the license conditions in the COPYING and COPYING.LESSER files accompanying the software. Also, please see the source code for the copyright and license notes pertaining to individual source files which are part of this software.</p>
<p>Third party software licensing notes:</p>
<p>Pure uses <a href="#llvm">LLVM</a> as its compiler backend. LLVM is under Copyright (c) 2003-2016 by the University of Illinois at Urbana-Champaign, and is licensed under a 3-clause BSD-style license, please read COPYING.LLVM included in the distribution for the exact licensing terms. You can also find the LLVM license at the <a href="#llvm">LLVM</a> website.</p>
<h2 id="references-and-links">References and Links</h2>
<p><a name="aardappel"></a></p>
<dl>
<dt>Aardappel</dt>
<dd><p>Wouter van Oortmerssen’s functional programming language based on term rewriting, <a href="http://wouter.fov120.com/aardappel" class="uri">http://wouter.fov120.com/aardappel</a>.</p>
</dd>
</dl>
<p><a name="alice-ml"></a></p>
<dl>
<dt>Alice ML</dt>
<dd><p>A version of ML (see below) from which Pure borrows its model of lazy evaluation, <a href="http://www.ps.uni-sb.de/alice" class="uri">http://www.ps.uni-sb.de/alice</a>.</p>
</dd>
</dl>
<p><a name="ats"></a></p>
<dl>
<dt>ATS</dt>
<dd><p>“Applied Type System”, a statically typed, ML-like programming language which unifies implementation with formal specification, <a href="http://www.ats-lang.org/" class="uri">http://www.ats-lang.org/</a>.</p>
</dd>
</dl>
<p><a name="baader-and-nipkow"></a></p>
<dl>
<dt>Franz Baader and Tobias Nipkow</dt>
<dd><p><em>Term Rewriting and All That.</em> Cambridge University Press, Cambridge, 1998.</p>
</dd>
</dl>
<p><a name="bertrand"></a></p>
<dl>
<dt>Bertrand</dt>
<dd><p>Wm Leler’s constraint programming language based on term rewriting, <a href="http://groups.google.com/group/bertrand-constraint" class="uri">http://groups.google.com/group/bertrand-constraint</a>. See Wm Leler: <em>Constraint Programming Languages: Their Specification and Generation.</em> Addison-Wesley, 1988.</p>
</dd>
</dl>
<p><a name="clang"></a></p>
<dl>
<dt>Clang</dt>
<dd><p>The new C/C++/Objective C compiler designed specifically to work on top of LLVM, <a href="http://clang.llvm.org" class="uri">http://clang.llvm.org</a>. Clang provides a comparatively light-weight alternative to gcc which is faster and has better and more friendly diagnostics.</p>
</dd>
</dl>
<p><a name="dragonegg"></a></p>
<dl>
<dt>DragonEgg</dt>
<dd><p>An LLVM backend for gcc 4.5 and later, <a href="http://dragonegg.llvm.org" class="uri">http://dragonegg.llvm.org</a>. In contrast to <a href="#llvm-gcc">llvm-gcc</a>, DragonEgg is implemented as a plugin which hooks into your system compiler.</p>
</dd>
</dl>
<p><a name="faust"></a></p>
<dl>
<dt>Faust</dt>
<dd><p>Grame’s functional DSP programming language, <a href="http://faust.grame.fr" class="uri">http://faust.grame.fr</a>.</p>
</dd>
</dl>
<p><a name="gmp"></a></p>
<dl>
<dt>GNU Multiprecision Library</dt>
<dd><p>Free library for arbitrary precision arithmetic, <a href="http://gmplib.org" class="uri">http://gmplib.org</a>.</p>
</dd>
</dl>
<p><a name="octave"></a></p>
<dl>
<dt>GNU Octave</dt>
<dd><p>A popular high-level language for numeric applications and free MATLAB replacement, <a href="http://www.gnu.org/software/octave" class="uri">http://www.gnu.org/software/octave</a>.</p>
</dd>
</dl>
<p><a name="gsl"></a></p>
<dl>
<dt>GNU Scientific Library</dt>
<dd><p>A free software library for numeric applications, can be used with Pure’s numeric matrices, <a href="http://www.gnu.org/software/gsl" class="uri">http://www.gnu.org/software/gsl</a>.</p>
</dd>
</dl>
<p><a name="go"></a></p>
<dl>
<dt>Go</dt>
<dd><p>Google’s Go programming language, <a href="http://golang.org" class="uri">http://golang.org</a>.</p>
</dd>
</dl>
<p><a name="haskell"></a></p>
<dl>
<dt>Haskell</dt>
<dd><p>A popular non-strict FPL, <a href="http://www.haskell.org" class="uri">http://www.haskell.org</a>.</p>
</dd>
</dl>
<p><a name="llvm"></a></p>
<dl>
<dt>LLVM</dt>
<dd><p>The LLVM code generator framework, <a href="http://llvm.org" class="uri">http://llvm.org</a>.</p>
</dd>
</dl>
<p><a name="llvm-gcc"></a></p>
<dl>
<dt>LLVM-GCC</dt>
<dd><p>An LLVM-capable compiler based on gcc, see <a href="http://llvm.org" class="uri">http://llvm.org</a>. This is based on a fairly old gcc version (4.2) and has been replaced by the <a href="#dragonegg">DragonEgg</a> plugin in the LLVM 3.x series.</p>
</dd>
</dl>
<p><a name="miranda"></a></p>
<dl>
<dt>Miranda</dt>
<dd><p>David Turner’s non-strict FPL, <a href="http://miranda.org.uk" class="uri">http://miranda.org.uk</a>. Miranda was fairly successful in its time and one of the forerunners of <a href="#haskell">Haskell</a>.</p>
</dd>
</dl>
<p><a name="ml"></a></p>
<dl>
<dt>ML</dt>
<dd><p>A popular strict FPL. See Robin Milner, Mads Tofte, Robert Harper, D. MacQueen: <em>The Definition of Standard ML (Revised).</em> MIT Press, 1997.</p>
</dd>
</dl>
<p><a name="michael-odonnell"></a></p>
<dl>
<dt>Michael O’Donnell</dt>
<dd><p><em>Equational Logic as a Programming Language.</em> Series in the Foundations of Computing. MIT Press, Cambridge, Mass., 1985.</p>
</dd>
</dl>
<p><a name="q"></a></p>
<dl>
<dt>Q</dt>
<dd><p>Another term rewriting language by yours truly, <a href="http://q-lang.sf.net" class="uri">http://q-lang.sf.net</a>.</p>
</dd>
</dl>
<p><a name="texmacs"></a></p>
<dl>
<dt>TeXmacs</dt>
<dd><p>A powerful editor for scientific documents. With the appropriate plugin (inluded in the Pure distribution as of Pure 0.56) it can also run Pure sessions. See <a href="http://www.texmacs.org" class="uri">http://www.texmacs.org</a>.</p>
</dd>
</dl>
</body>
</html>
