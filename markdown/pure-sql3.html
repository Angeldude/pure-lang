<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="modern.css" type="text/css" />
</head>
<body>
<p><a name="doc-pure-sql3"></a></p>
<h1 id="pure-sql3">Pure-Sql3</h1>
<p><a name="module-sql3"></a></p>
<p>Version 0.5, March 06, 2017</p>
<div style="white-space: pre-line;">Peter Summerland &lt;<a href="mailto:p.summerland@gmail.com">p.summerland@gmail.com</a>&gt;
Albert Graef &lt;<a href="mailto:aggraef@gmail.com">aggraef@gmail.com</a>&gt;</div>
<p>This document describes <strong>Sql3</strong>, a <a href="http://www.sqlite.org">SQLite</a> module for the <a href="http://purelang.bitbucket.org">Pure</a> programming language.</p>
<h2 id="introduction">Introduction</h2>
<p>SQLite is a software library that implements an easy to use, self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is not intended to be an enterprise database engine like Oracle or PostgreSQL. Instead, SQLite strives to be small, fast, reliable, and above all simple. See <a href="http://www.sqlite.org/whentouse.html">Appropriate Uses For SQLite</a>.</p>
<p>Sql3 is a wrapper around SQLite’s C interface that provides Pure programmers access to almost all of SQLite’s features, including many that are not available through Pure’s generic ODBC interface.</p>
<h3 id="simple-example">Simple Example</h3>
<p>Here is a simple example that opens a database file “readme.db” (creating it if it does not exist), adds a table “RM”, populates “RM” and executes a query.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">pure-sql3$&gt; pure -q
&gt; 

&gt; <span class="kw">using</span> sql3; <span class="kw">using</span> <span class="kw">namespace</span> sql3;

&gt; <span class="kw">let</span> dbp = open <span class="st">&quot;readme.db&quot;</span>;

&gt; exec dbp <span class="st">&quot;create table if not exists RM (name text, age integer)&quot;</span>;

&gt; exec dbp <span class="st">&quot;delete from RM&quot;</span>;

&gt; <span class="kw">let</span> sp1 = prep dbp <span class="st">&quot;ci&quot;</span> <span class="st">&quot;insert into RM values (?,?)&quot;</span>;

&gt; exec sp1 (<span class="st">&quot;Sam&quot;</span>,<span class="dv">20</span>);

&gt; exec sp1 (<span class="st">&quot;Fred&quot;</span>,<span class="dv">22</span>);

&gt; <span class="kw">let</span> sp2 = prep dbp <span class="st">&quot;ci:i&quot;</span> <span class="st">&quot;select * from RM where age &gt; ?&quot;</span>;

&gt; exec sp2 <span class="dv">18</span>;
[[<span class="st">&quot;Sam&quot;</span>,<span class="dv">20</span>],[<span class="st">&quot;Fred&quot;</span>,<span class="dv">22</span>]]</code></pre></div>
<p>The Sql3 functions, <a href="#sql3::open"><code>open</code></a>, <a href="#sql3::prep"><code>prep</code></a> and <a href="#sql3::exec"><code>exec</code></a> encapsulate the core functionality of SQLite, and in many cases are all you need to use SQLite effectively.</p>
<h3 id="more-examples">More Examples</h3>
<p>The examples subdirectory of pure-Sql3 contains several files that further illustrate basic usage as well as some of Sql3’s more sophisticated features. These include readme.pure, a short file that contains the examples included herein. If you are using emacs pure-mode you can load readme.pure into a buffer and execute the examples line by line (pressing C-c C-c) (as well as experiment as you go).</p>
<h3 id="sqlite-documentation">SQLite Documentation</h3>
<p>SQLite’s home page provides excellent documentation regarding its SQL dialect as well as its C interface. Comments in this document regarding SQLite are not meant to be a substitute for the actual documentation and should not be relied upon, other than as general observations which may or may not be accurate. The best way to use Sql3 is to get familiar with SQLite and its C interface and go directly to the <a href="http://www.sqlite.org/sitemap.html">SQLite Site Map</a> for authoritative answers to any specific questions that you might have.</p>
<p>In the rest of this document, it is assumed the reader has some familiarity with SQLite and has read <a href="#an-introduction-to-the-sqlite-cc-interface">An Introduction To The SQLite C/C++ Interface</a>.</p>
<dl>
<dt><a name="an-introduction-to-the-sqlite-cc-interface"></a></dt>
<dd><p><a href="http://www.sqlite.org/cintro.html" class="uri">http://www.sqlite.org/cintro.html</a></p>
</dd>
</dl>
<h3 id="sqlite3---the-sqlite-command-line-utility">Sqlite3 - The SQLite Command-Line Utility</h3>
<p>The SQLite library includes a really nice command-line utility named sqlite3 (or sqlite3.exe on Windows) that allows the user to manually enter and execute SQL statements against a SQLite database (and much more).</p>
<p>This tool is an invaluable aid when working with SQLite in general and with Sql3 in the Pure interpreter in particular. For example, after entering the Pure statements from the Simple Example above, you could start a new terminal, cd to pure-sql3, type “sqlite3 readme.db” at the prompt, and see the effect the Pure statements had on the database:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql">pure-sql3$&gt; sqlite3 readme.db
SQLite version <span class="fl">3.6</span>.<span class="dv">16</span>
Enter <span class="ot">&quot;.help&quot;</span> <span class="kw">for</span> instructions
Enter SQL statements terminated <span class="kw">with</span> a <span class="ot">&quot;;&quot;</span>

sqlite&gt; <span class="kw">select</span> * <span class="kw">from</span> RM;
Sam|<span class="dv">20</span>
Fred|<span class="dv">22</span></code></pre></div>
<p>For bottom up REPL development, sqlite3 and Pure are an excellent combination.</p>
<h2 id="copying">Copying</h2>
<div style="white-space: pre-line;">Copyright (c) 2010 by Peter Summerland &lt;<a href="mailto:p.summerland@gmail.com">p.summerland@gmail.com</a>&gt;.
Copyright (c) 2010 by Albert Graef &lt;<a href="mailto:aggraef@gmail.com">aggraef@gmail.com</a>&gt;.</div>
<p>All rights reserved.</p>
<p>Sql3 is free software: you can redistribute it and/or modify it under the terms of the New BSD License, often referred to as the 3 clause BSD license. Sql3 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>
<p>Please see the COPYING file for the actual license applicable to Sql3.</p>
<h2 id="installation">Installation</h2>
<p>Get the latest source from <a href="https://bitbucket.org/purelang/pure-lang/downloads/pure-sql3-0.5.tar.gz" class="uri">https://bitbucket.org/purelang/pure-lang/downloads/pure-sql3-0.5.tar.gz</a>.</p>
<p>Unless you already have them on your machine, download SQLite and sqlite3 from the SQLite website and install as indicated. To install Sql3, cd to the pure-sql3 directory, run <code>make</code>, and then run <code>sudo make install</code> (on Linux).</p>
<h2 id="data-structure">Data Structure</h2>
<p>From a client’s perspective, the most important of SQLite’s data structures are the database connection object “sqlite3” and the prepared statement object “sqlite3_stmt”. These are opaque data structures that are made available to users of SQLite’s C interface via pointers, sqlite3* and sqlite3_stmt*. At appropriate times, Sql3 creates “cooked” versions of these pointers that can be used (with care) to call native C functions exposed by SQLite’s C interface.</p>
<p>Sql3 introduces two new data types, “db_ptr” and “stmt_ptr” which refer to the cooked versions of sqlite3* and sqlite3_stmt*, respectively. These two new data types are defined using <a href="#sql3::type"><code>type</code></a>, and therefore can be used as type tags in rule patterns or as the first parameter passed to in the typep function. It follows that all db_ptrs are sqlite3* pointers and all stmt_ptrs are sqlite3_stmt* pointers. Thus, using dbp and sp1 from the introductory example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; typep db_ptr dbp, pointer_type dbp;
<span class="dv">1</span>, <span class="st">&quot;sqlite3*&quot;</span>

&gt; typep stmt_ptr sp1, pointer_type sp1;
<span class="dv">1</span>, <span class="st">&quot;sqlite3_stmt*&quot;</span></code></pre></div>
<p>The converse, of course, is not true, as SQLite knows nothing about Sql3, and db_ptrs and stmt_ptrs carry other information in addtion to the underlying pointers provided to them by SQLite.</p>
<h2 id="core-database-operations">Core Database Operations</h2>
<p>The core database operations are (a) opening and closing database connections and (b) preparing, executing and closing prepared statements.</p>
<h3 id="database-connections">Database Connections</h3>
<p>Generally speaking, the first step in accessing a database is to obtain a db_ptr that references a database connection object. Once the db_ptr is obtained, it can be used to construct prepared statements for updating and querying the underlying database. The last step is usually to close the database connection (although this is will be done automatically by Sql3 when the db_ptr goes out of scope).</p>
<h4 id="opening-a-database-connection">Opening a Database Connection</h4>
<p>In Sql3 <a href="#sql3::open"><code>open</code></a> constructs a database connection and returns a db_ptr that refers to the connection.</p>
<dl>
<dt><a name="sql3::open"></a><code>sql3::open (file_path::string [,access_mode::int[,custom_bindings]])</code></dt>
<dd>opens a SQLite database file whose name is given by the file_path argument and returns a db_ptr for the associated database connection object created by SQLite.
</dd>
</dl>
<!-- -->
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt;  <span class="kw">let</span> dbp2 = open <span class="st">&quot;abc.db&quot;</span>; dbp2;
#&lt;<span class="dt">pointer</span> <span class="dv">0x992dff8</span>&gt;</code></pre></div>
<p>If the filename is “:memory:” a private, temporary in-memory database is created for the connection.</p>
<p>The basic access modes are:</p>
<ul>
<li>SQLITE_OPEN_READONLY - the database is opened in read-only mode. If the database does not already exist, an error is returned.</li>
<li>SQLITE_OPEN_READWRITE - the database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</li>
<li>SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE - the database is opened for reading and writing, and is creates it if it does not already exist. This is the default value that is used if the flags argument is omitted.</li>
<li>SQLITE_OPEN - an alias for SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE provided by Sql3.</li>
</ul>
<p>These flags can be combined with SQLITE_OPEN_NOMUTEX SQLITE_OPEN_FULLMUTEX SQLITE_OPEN_SHAREDCACHE SQLITE_OPEN_PRIVATECACHE to control SQLite’s threading and shared cache features. All of these flags are exported by Sql3.</p>
<p>The optional custom_bindings argument allows the user to set up customized binding and fetching behavior for prepared statements associated with the returned db_ptr. (See <a href="#custom-binding-types-for-prepared-statements">Custom Binding Types for Prepared Statements</a>)</p>
<h4 id="failure-to-open-a-database-connection">Failure to Open a Database Connection</h4>
<p>If SQLite cannot open the connection, it still returns a pointer to a database connection object that must be closed. In this case, <a href="#sql3::open"><code>open</code></a> automatically closes the the connection object and then throws an exception. E.g.,:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="fu">catch</span> error (open (<span class="st">&quot;RM_zyx.db&quot;</span>,SQLITE_OPEN_READONLY));
error (sql3::db_error <span class="dv">14</span> <span class="st">&quot;unable to open database file [open RM_zyx.db]&quot;</span>)</code></pre></div>
<p>Apparently, SQLite does not verify that a file is a valid SQLite database when it opens a connection. However, if the file is corrupted SQLite will return an error when the connection is used.</p>
<h4 id="testing-a-db_ptr">Testing a db_ptr</h4>
<p>You can test any object to see if it is a db_ptr using (typep db_ptr):</p>
<dl>
<dt><a name="typep/sql3dbptr"></a><code>typep db_ptr x</code></dt>
<dd>returns 1 if x is a db_ptr returned by open, and 0 if it is not.
</dd>
</dl>
<!-- -->
<p>You can also determine if a db_ptr’s data connection is open.</p>
<dl>
<dt><a name="sql3::is_open"></a><code>sql3::is_open dbp::db_ptr</code></dt>
<dd>returns 1 if the database connection referenced by dbp is open.
</dd>
</dl>
<!-- -->
<h4 id="closing-a-database-connection">Closing a Database Connection</h4>
<p>When a database connection object is no longer needed, it should be closed so that SQLite can free the associated resources.</p>
<dl>
<dt><a name="sql3::close"></a><code>sql3::close dbp::db_ptr</code></dt>
<dd>if the database connection referenced by the db_ptr dbp is open, close it using sqlite3_close; otherwise do nothing.
</dd>
</dl>
<!-- -->
<p>Before calling <code>sqlite3_close</code>, <a href="#sql3::close"><code>close</code></a> finalizes all prepared statements associated with the connection being closed. Sql3 will detect and throw a db_error if an attempt is subsequently made to execute a statement associated with the closed database connection.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> dbp2_sp = prep dbp2 <span class="st">&quot;ci:&quot;</span> <span class="st">&quot;select * from RM&quot;</span>;

&gt; exec dbp2_sp ();
[[<span class="st">&quot;Sam&quot;</span>,<span class="dv">20</span>],[<span class="st">&quot;Fred&quot;</span>,<span class="dv">22</span>]]

&gt; close dbp2;

&gt; <span class="fu">catch</span> error (exec dbp2_sp);
error (sql3::db_error <span class="dv">0</span> <span class="st">&quot;Attempt to exec on a closed db_ptr.&quot;</span>)</code></pre></div>
<p>If a db_ptr goes out of scope, Sql3 will automatically call <code>sqlite3_close</code> to close the referenced database connection, but only if the connection has not already been closed by <a href="#sql3::close"><code>close</code></a>. Thus, for example, it is not necessary to use a catch statement to ensure that Sqlite3 resources are properly finalized when a db_ptr is passed into code that could throw an exception.</p>
<p>When debugging, this activity can be observed by editing sql3.pure, changing “const SHOW_OPEN_CLOSE = 0;” to “const SHOW_OPEN_CLOSE = 1;” and running sudo make install in the pure-sql3 directory. This will cause a message to be printed whenever a db_ptr or stmt_ptr is created or finalized.</p>
<p>N.B. You should never call the native C interface function<code>sqlite3_close</code> with a db_ptr. If the referenced database connection is closed by such a call, a subsequent call to <a href="#sql3::close"><code>close</code></a> on this db_ptr (including the call that will automatically occur when the db_ptr goes out of scope) will cause a seg fault.</p>
<h3 id="prepared-statements">Prepared Statements</h3>
<p>The native SQLite C interface provides five core functions needed to execute a SQL statement.</p>
<ul>
<li>sqlite3_prepare_v2</li>
<li>sqlite3_bind</li>
<li>sqlite3_step</li>
<li>sqlite3_column</li>
<li>sqlite3_finalize</li>
</ul>
<p>Using the C interface, the basic procedure is to prepare a statement using <code>sqlite3_prepare_v2</code>, bind its parameters using <code>sqlite3_bind</code>, step it using <code>sqlite3_step</code> one or more times until it is done and then finalize it using <code>sqlite3_finalize</code>. Each time <code>sqlite3_step</code> returns SQLITE_ROW, use <code>sqlite3_column</code> to fetch the row’s values. Here <code>sqlite3_bind</code> and <code>sqlite3_column</code> represent families of bind and column functions, rather than actual functions, with one member for each of the basic data types recognized by SQLite. Thus, for example, <code>sqlite_bind_double</code> is the function one would use to bind a prepared statement with an argument of type double.</p>
<p>Sql3 encapsulates these procedures in four functions: <a href="#sql3::prep"><code>prep</code></a>, <a href="#sql3::exec"><code>exec</code></a>, <a href="#sql3::lexec"><code>lexec</code></a> and <a href="#sql3::finalize"><code>finalize</code></a>.</p>
<h4 id="constructing-prepared-statements">Constructing Prepared Statements</h4>
<p>In Sql3 you can use <a href="#sql3::prep"><code>prep</code></a> to construct a prepared statement and obtain a stmt_ptr that refers to it.</p>
<dl>
<dt><a name="sql3::prep"></a><code>sql3::prep dbp::db_ptr binding_string::string sql_statement::string</code></dt>
<dd>constructs a prepared statement object and returns a stmt_ptr that references it. <code>dbp</code> must be a db_ptr or the rule will not match. <code>sql_statement</code> is the SQL statement that will be executed when the prepared statement is passed to <a href="#sql3::exec"><code>exec</code></a>.
</dd>
</dl>
<!-- -->
<p>Basically, <a href="#sql3::prep"><code>prep</code></a> just passes <code>dbp</code> and <code>sql_statement</code> on to <code>sqlite3_prepare_v2</code> and returns a sentry guarded version of the sqlite3_stmt* it receives back from <code>sqlite3_prepare_v2</code>. SQL statements passed to <a href="#sql3::prep"><code>prep</code></a> (and <code>sqlite3_prepare_v2</code>) can have argument placeholders, indicated by “?”, “?nnn”, “:AAA”, etc, in which case the argument placeholders must be bound to values using <code>sqlite_bind</code> before the prepared statement is passed to <code>sqlite3_step</code>. Hence the <code>binding_string</code>, which is used by Sql3 to determine how to bind the prepared statement’s argument placeholders, if any. The binding string also tells Sql3 how to fetch values in the <code>sqlite3_column</code> phase of the basic prepare, bind, step, fetch, finalize cycle dictated by the SQlite C interface.</p>
<p>In the following two examples, the “c” and “i” in the binding strings indicate that (a) a string and an int will be used to bind <code>sp1</code>,(b) an int will be used to bind <code>sp2</code> and (c) <code>sp2</code>, when executed, will return a result set in the form of a list of sublists each of which contains a string and an int.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> sp1 = prep dbp <span class="st">&quot;ci&quot;</span> <span class="st">&quot;insert into RM values (?,?)&quot;</span>;

&gt; <span class="kw">let</span> sp2 = prep dbp <span class="st">&quot;ci:i&quot;</span> <span class="st">&quot;select * from RM where age &gt; ?&quot;</span>;</code></pre></div>
<p>In general, the characters in the type string before the “:”, if any, indicate the types in the result set. Those that occur after the “:”, if any, indicate the types of the arguments used to bind the prepared statement object. If the type string does not contain a “:”, the characters in the type string, if any, are the types of binding arguments.</p>
<p>Sql3 provides the following set of “core” binding types:</p>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Pure Argument</th>
<th align="left">SQLite Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">b</td>
<td align="left">(int, pointer)</td>
<td align="left">blob</td>
</tr>
<tr class="even">
<td align="left">c</td>
<td align="left">string</td>
<td align="left">text (utf8)</td>
</tr>
<tr class="odd">
<td align="left">d</td>
<td align="left">double</td>
<td align="left">float</td>
</tr>
<tr class="even">
<td align="left">i</td>
<td align="left">int</td>
<td align="left">int</td>
</tr>
<tr class="odd">
<td align="left">k</td>
<td align="left">int or bigint</td>
<td align="left">int64</td>
</tr>
<tr class="even">
<td align="left">l</td>
<td align="left">bigint</td>
<td align="left">blob</td>
</tr>
<tr class="odd">
<td align="left">n</td>
<td align="left">Sql3::SQLNULL</td>
<td align="left">NULL</td>
</tr>
<tr class="even">
<td align="left">x</td>
<td align="left">expression</td>
<td align="left">blob</td>
</tr>
<tr class="odd">
<td align="left">v</td>
<td align="left">variant</td>
<td align="left">variant</td>
</tr>
</tbody>
</table>
<p>The “<strong>b</strong>” or blob type is different from the rest in that the Pure argument is specified as a pair. The first element of the pair indicates the length in bytes of the object to be stored and the second element indicates its location in memory. The “<strong>c</strong>” type stands for string (as in “char*”), “<strong>d</strong>” stands for double and “<strong>i</strong>” stands for int. The “<strong>k</strong>” type stands for “key” and maps Pure ints and bigints (within the range of int64) to int64 values in the database. This type is useful when dealing with SQLite’s “integer primary keys” and “rowids” both of which are int64. The “<strong>l</strong>” type, in contrast applies to all bigints (and not to ints) and it maps bigints onto blobs, which are generally meaningless in SQL math expressions. The “<strong>n</strong>” type can only appear on the binding side of a type string. The “<strong>v</strong>” type stands for any of “b”, “c”, “d”, “i” or “n”, based on the type of the binding argument. A “v” type will be fetched from SQLite according to the native SQLite column type of the corresponding column. The “<strong>x</strong>” type is used to store and reconstruct Pure expressions as binary objects, using the <a href="purelib.html#val/blob"><code>val</code></a> and <a href="purelib.html#blob"><code>blob</code></a> functions provided by the Pure prelude.</p>
<p>Users can define custom binding types and pass them as a third parameter to <a href="#sql3::open"><code>open</code></a>. The resulting db_ptr can be used with the custom binding types to construct prepared statements using <a href="#sql3::prep"><code>prep</code></a>.</p>
<h4 id="testing-a-stmt_ptr">Testing a stmt_ptr</h4>
<p>You can determine if a given expression is a stmt_ptr using typep.</p>
<dl>
<dt><a name="typep/sql3stmtptr"></a><code>typep stmt_ptr x</code></dt>
<dd>returns 1 if <code>x</code> is a stmt_ptr, otherwise returns 0.
</dd>
</dl>
<!-- -->
<h4 id="executing-prepared-statements">Executing Prepared Statements</h4>
<p>In Sql3, the bind, step, column, step, column … cycle is encapsulated in the <a href="#sql3::exec"><code>exec</code></a> and <a href="#sql3::lexec"><code>lexec</code></a> functions.</p>
<dl>
<dt><a name="sql3::exec"></a><code>sql3::exec sp::stmt_ptr args</code></dt>
<dd>use <code>args</code> to bind the prepared statement referenced by <code>sp</code>, execute it and return the result set as a list. The first parameter, <code>sp</code> must be a valid stmt_ptr or the rule will fail.
</dd>
</dl>
<!-- -->
<p>The second parameter, <code>args</code>, is a tuple or list of arguments whose number and type correspond to the bind parameter types specified in the call to <a href="#sql3::prep"><code>prep</code></a> that produced the first parameter <code>sp</code>.</p>
<p>Thus, using sp1 and sp2 defined in the introductory example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; exec sp1 (<span class="st">&quot;Tom&quot;</span>,<span class="dv">30</span>);  <span class="co">//insert Tom</span>
[]

&gt; exec sp2 <span class="dv">19</span>;          <span class="co">//select age &gt; 19</span>
[[<span class="st">&quot;Sam&quot;</span>,<span class="dv">20</span>],[<span class="st">&quot;Fred&quot;</span>,<span class="dv">22</span>],[<span class="st">&quot;Tom&quot;</span>,<span class="dv">30</span>]]</code></pre></div>
<p>An error is thrown if the args do not correspond to the specified types.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="fu">catch</span> error (exec sp2 <span class="st">&quot;a&quot;</span>);
error (sql3::db_error <span class="dv">0</span> <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">a</span><span class="ch">\&quot;</span><span class="st"> does not have type int&quot;</span>)</code></pre></div>
<p>If a prepared statement does not have any binding parameters, the call to <a href="#sql3::exec"><code>exec</code></a> should use <code>()</code> as the binding argument.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> sp3 = prep dbp <span class="st">&quot;c:&quot;</span> <span class="st">&quot;select name from RM&quot;</span>;

&gt; exec sp3 ();
[[<span class="st">&quot;Sam&quot;</span>],[<span class="st">&quot;Fred&quot;</span>],[<span class="st">&quot;Tom&quot;</span>]]</code></pre></div>
<p>Extra care is required when executing prepared statements that take a blob argument because it must be a pair. In order to preserve the tuple as a pair, binding arguments that include a blob should passed to exec as a list. If passed as a member of a larger tuple, it will be treated as two arguments due to the nature of tuples.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> blb = (<span class="dv">100</span>,ptr);

&gt; (a,blb,c);
a,<span class="dv">100</span>,ptr,c

&gt; [a,blb,c];
[a,(<span class="dv">100</span>,ptr),c]</code></pre></div>
<p>Thus something like “<code>exec stpx [a,blb,c]</code>” would work fine, while “<code>exec stpx (a,blb,c)</code>” would produce a Sql3 binding exception.</p>
<h4 id="executing-lazily">Executing Lazily</h4>
<p>The <a href="#sql3::exec"><code>exec</code></a> function returns result sets as eager lists which can sometimes be inefficient or simply not feasible for large result sets. In such cases it is preferable to use <a href="#sql3::lexec"><code>lexec</code></a> instead of <a href="#sql3::exec"><code>exec</code></a>.</p>
<dl>
<dt><a name="sql3::lexec"></a><code>sql3::lexec stmp::stmt_ptr args</code></dt>
<dd>same as <a href="#sql3::exec"><code>exec</code></a> except that it returns a lazy list.
</dd>
</dl>
<!-- -->
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; lexec sp2 <span class="dv">19</span>;
[<span class="st">&quot;Sam&quot;</span>,<span class="dv">20</span>]:#&lt;thunk <span class="dv">0xb6475ab0</span>&gt;</code></pre></div>
<p>Note that no changes to <code>sp2</code> were required. In addition, for most purposes the lazy list returned by <a href="#sql3::lexec"><code>lexec</code></a> can be processed by the same code that processed the eager list returned by <a href="#sql3::exec"><code>exec</code></a>.</p>
<h4 id="executing-directly-on-a-db_ptr">Executing Directly on a db_ptr</h4>
<p>For statements that have no parameters and which do not return results, <a href="#sql3::exec"><code>exec</code></a> can be applied to a db_ptr.</p>
<dl>
<dt><a name="sql3::exec"></a><code>sql3::exec dbp::db_ptr sql_statement::string</code></dt>
<dd>constructs a temporary prepared statement using <code>sql_statement</code>. The SQL statement cannot contain argument placeholders and cannot be a select statement.
</dd>
</dl>
<!-- -->
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; exec dbp <span class="st">&quot;create table if not exists RM (name varchar, age integer)&quot;</span>;</code></pre></div>
<h4 id="executing-against-a-busy-database">Executing Against a Busy Database</h4>
<p>SQLite allows multiple processes to concurrently read a single database, but when any process wants to write, it locks the entire database file for the duration of its update.</p>
<p>When the native SQLite C interface function <code>sqlite3_step</code> (used by <code>exec</code>) tries to access a file that is locked by another process, it treats the database as “busy” and returns the SQLITE_BUSY error code. If this happens in a call to <a href="#sql3::exec"><code>exec</code></a> or <a href="#sql3::lexec"><code>lexec</code></a>, a <a href="#sql3::db_busy"><code>db_busy</code></a> exception will be thrown.</p>
<p>You can adjust SQLite’s behavior using <code>sqlite3_busy_handler</code> or <code>sqlite3_busy_timeout</code>.</p>
<p>If the statement is a COMMIT or occurs outside of an explicit transaction, then you can retry the statement. If the statement is not a COMMIT and occurs within a explicit transaction then you should rollback the transaction before continuing.</p>
<h4 id="grouping-execution-with-transactions">Grouping Execution with Transactions</h4>
<p>No changes can be made to a SQLite database file except within a transaction. Transactions can be started manually by executing a BEGIN statement (i.e., exec dbp “BEGIN”). Manually started transactions persist until the next COMMIT or ROLLBACK statement is executed. Transactions are also ended if an error occurs before the transaction is manually ended using a COMMIT or ROLLBACK statement. This behavior provides the means make a series of changes “atomically.”</p>
<p>By default, SQLite operates in autocommit mode. In autocommit mode, any SQL statement that changes the database (basically, anything other than SELECT) will automatically start a transaction if one is not already in effect. As opposed to manually started transactions, automatically started transactions are committed as soon as the execution of the related statement completes.</p>
<p>The upshot of this, in Sql3 terms, is that unless a transaction is started manually, the database will be updated each time <a href="#sql3::exec"><code>exec</code></a> is called. For a long series of updates or inserts this a can be very slow. The way to avoid this problem is to manually begin and end transactions manually.</p>
<p>Sql3 provides the following convenience functions all of which simply call <a href="#sql3::exec"><code>exec</code></a> with the appropriate statement. For example <code>begin dbp</code> is exactly the same as <code>exec dbp &quot;BEGIN&quot;</code>.</p>
<dl>
<dt><a name="sql3::begin"></a><code>sql3::begin dbp::db_ptr</code>, <a name="sql3::begin_exclusive"></a><code>sql3::begin_exclusive dbp::db_ptr</code>, <a name="sql3::begin_immediate"></a><code>sql3::begin_immediate dbp::db_ptr</code>, <a name="sql3::commit"></a><code>sql3::commit dbp::db_ptr</code>, <a name="sql3::rollback"></a><code>sql3::rollback dbp::db_ptr</code></dt>
<dd>
</dd>
<dt><a name="sql3::savepoint"></a><code>sql3::savepoint dbp::db_ptr save_point::string</code>, <a name="sql3::release"></a><code>sql3::release dbp::db_ptr save_point::string</code>, <a name="sql3::rollback_to"></a><code>sql3::rollback_to dbp::db_ptr save_point::string</code></dt>
<dd><!-- -->
</dd>
</dl>
<p>Note that transactions created using <a href="#sql3::begin"><code>begin</code></a> and <a href="#sql3::commit"><code>commit</code></a> do not nest. For nested transactions, use <a href="#sql3::savepoint"><code>savepoint</code></a> and <a href="#sql3::release"><code>release</code></a>.</p>
<h4 id="finalizing-prepared-statements">Finalizing Prepared Statements</h4>
<p>When a prepared statement is no longer needed it should be finalized so that SQLite can free the associated resources.</p>
<dl>
<dt><a name="sql3::finalize"></a><code>sql3::finalize sp::stmt_ptr</code></dt>
<dd>finalize the prepared statement referenced by <code>sp</code>, which must be a stmt_ptr previously returned by <a href="#sql3::prep"><code>prep</code></a>.
</dd>
</dl>
<!-- -->
<p>Often there is no need to call <a href="#sql3::finalize"><code>finalize</code></a> for a given stmt_ptr because it will be automatically called when the stmt_ptr goes out of scope.</p>
<p>If the stmt_ptr is associated with a database connection that has been closed (which would have caused an exception to be thrown), an attempt to finalize it, including the automatic finalization can occur when stmt_ptr goes out of scope, will cause an exception to be thrown.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="fu">catch</span> error (finalize dbp2_sp);
error (sql3::db_error <span class="dv">0</span> <span class="st">&quot;finalize: STMT attached to a closed db_ptr.&quot;</span>)</code></pre></div>
<p>Multiple calls to <a href="#sql3::finalize"><code>finalize</code></a> are fine. In contrast, the corresponding native C interface function, <code>sqlite3_finalize</code> will cause a seg fault if called with a pointer to a finalized prepared statement object. This is the main reason why you should never call <code>sqlite3_finalize</code> with a stmt_ptr. If the prepared statement referenced by the stmt_ptr is finalized by such a call, a subsequent call to <a href="#sql3::finalize"><code>finalize</code></a> with the stmt_ptr (including the call that will automatically occur when the stmt_ptr goes out of scope) will cause a seg fault.</p>
<h3 id="exceptions">Exceptions</h3>
<p>Sql3 throws two types of exceptions, one for outright errors and one for database “busy” conditions.</p>
<dl>
<dt><a name="sql3::db_error"></a><code>sql3::db_error ec msg</code></dt>
<dd><p>When a Sql3 function detects an error it throws an exception of the form “<code>db_error ec msg</code>” where ec is an error code and msg is the corresponding error message. If ec&gt;0, the error was detected by SQLite itself, and ec and msg are those returned by SQLite. If ec==0, the error was detected by Sql3 and msg is a Sql3 specific description of the error. E.g.,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; db_error_handler (db_error ec msg) = ()
&gt; <span class="kw">when</span>
&gt;   source = <span class="kw">if</span> ec &gt; <span class="dv">0</span> <span class="kw">then</span> <span class="st">&quot;SQLite&quot;</span> <span class="kw">else</span> <span class="st">&quot;Sql3&quot;</span>;
&gt;   printf <span class="st">&quot;%s db_error: ec %d, %s</span><span class="ch">\n</span><span class="st">&quot;</span> (source,ec,msg);
&gt; <span class="kw">end</span>;
&gt; db_error_handler x = <span class="fu">throw</span> x;

&gt; <span class="fu">catch</span> db_error_handler (exec dbp <span class="st">&quot;select * from NO_TABLE&quot;</span>);
SQLite db_error: ec <span class="dv">1</span>, no such table: NO_TABLE</code></pre></div>
</dd>
<dt><a name="sql3::db_busy"></a><code>sql3::db_busy dbp</code></dt>
<dd>Sql3 functions <a href="#sql3::exec"><code>exec</code></a> and <a href="#sql3::lexec"><code>lexec</code></a> throw exceptions of the form “<code>db_busy dbp</code>”, where <code>dbp</code> is a db_ptr, if they are prevented from executing successfully because the database referenced by <code>dbp</code> is locked (See <a href="#executing-against-a-busy-database">Executing Against a Busy Database</a>).
</dd>
</dl>
<!-- -->
<h4 id="sqlite-error-codes">SQLite Error Codes</h4>
<p>Here is a list, as of January 31, 2011, of SQLite’s error codes.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">SQLITE_ERROR        <span class="dv">1</span>   <span class="co">/* SQL error or missing database */</span>
SQLITE_INTERNAL     <span class="dv">2</span>   <span class="co">/* Internal logic error in SQLite */</span>
SQLITE_PERM         <span class="dv">3</span>   <span class="co">/* Access permission denied */</span>
SQLITE_ABORT        <span class="dv">4</span>   <span class="co">/* Callback routine requested an abort */</span>
SQLITE_BUSY         <span class="dv">5</span>   <span class="co">/* The database file is locked */</span>
SQLITE_LOCKED       <span class="dv">6</span>   <span class="co">/* A table in the database is locked */</span>
SQLITE_NOMEM        <span class="dv">7</span>   <span class="co">/* A malloc() failed */</span>
SQLITE_READONLY     <span class="dv">8</span>   <span class="co">/* Attempt to write a readonly database */</span>
SQLITE_INTERRUPT    <span class="dv">9</span>   <span class="co">/* Operation terminated by sqlite3_interrupt()*/</span>
SQLITE_IOERR       <span class="dv">10</span>   <span class="co">/* Some kind of disk I/O error occurred */</span>
SQLITE_CORRUPT     <span class="dv">11</span>   <span class="co">/* The database disk image is malformed */</span>
SQLITE_NOTFOUND    <span class="dv">12</span>   <span class="co">/* NOT USED. Table or record not found */</span>
SQLITE_FULL        <span class="dv">13</span>   <span class="co">/* Insertion failed because database is full */</span>
SQLITE_CANTOPEN    <span class="dv">14</span>   <span class="co">/* Unable to open the database file */</span>
SQLITE_PROTOCOL    <span class="dv">15</span>   <span class="co">/* NOT USED. Database lock protocol error */</span>
SQLITE_EMPTY       <span class="dv">16</span>   <span class="co">/* Database is empty */</span>
SQLITE_SCHEMA      <span class="dv">17</span>   <span class="co">/* The database schema changed */</span>
SQLITE_TOOBIG      <span class="dv">18</span>   <span class="co">/* String or BLOB exceeds size limit */</span>
SQLITE_CONSTRAINT  <span class="dv">19</span>   <span class="co">/* Abort due to constraint violation */</span>
SQLITE_MISMATCH    <span class="dv">20</span>   <span class="co">/* Data type mismatch */</span>
SQLITE_MISUSE      <span class="dv">21</span>   <span class="co">/* Library used incorrectly */</span>
SQLITE_NOLFS       <span class="dv">22</span>   <span class="co">/* Uses OS features not supported on host */</span>
SQLITE_AUTH        <span class="dv">23</span>   <span class="co">/* Authorization denied */</span>
SQLITE_FORMAT      <span class="dv">24</span>   <span class="co">/* Auxiliary database format error */</span>
SQLITE_RANGE       <span class="dv">25</span>   <span class="co">/* 2nd parameter to sqlite3_bind out of range */</span>
SQLITE_NOTADB      <span class="dv">26</span>   <span class="co">/* File opened that is not a database file */</span></code></pre></div>
<p>New error codes may be added in future versions of SQLite. Note that the SQLite names of the error codes are not exported by the Sql3 module.</p>
<h2 id="advanced-features">Advanced Features</h2>
<p>Sql3’s advanced features include the ability to implement SQL functions in Pure, convenient access to the SQLite C interface and custom binding types.</p>
<h3 id="custom-sql-functions">Custom SQL Functions</h3>
<p>An extremely powerful (albeit complex) feature of the SQLite C interface is the ability to add new SQL scalar or aggregate functions. The new functions can be used in SQL statements the in same way as SQLites’s prepackaged functions. Sql3 hides the complexity and seamlessly integrates all of this functionality, :), into Pure via <a href="#sql3::create_function"><code>create_function</code></a>. This function is used to register both scalar SQL functions and aggregate SQL functions with SQlite.</p>
<h4 id="scalar-sql-functions">Scalar SQL Functions</h4>
<p>You can add a custom SQL scalar function to SQLite by passing a single Pure function to <a href="#sql3::create_function"><code>create_function</code></a>.</p>
<dl>
<dt><a name="sql3::create_function"></a><code>sql3::create_function dbp::db_ptr name::string nargs::int pure_fun</code></dt>
<dd>registers a new SQL scalar function of <code>nargs</code> arguments that can be called, as <code>name</code>, in SQL statements prepared with respect to <code>dbp</code>, a db_ptr. When the SQL function is called in a SQL statement, control is passed to <code>pure_fun</code>, a function written in Pure. If <code>nargs</code> is <code>(-1)</code>, the SQL function <code>name</code> is variadic, and the arguments will be passed to <code>pure_fun</code> as a single list.
</dd>
</dl>
<!-- -->
<p>Note that <a href="#sql3::create_function"><code>create_function</code></a> can also register aggregate functions (see <a href="#aggregate-sql-functions">Aggregate SQL Functions</a>).</p>
<p>Here is an example of a scalar function that takes two parameters. Note that any kind of Pure “function” can be passed here; local functions, global functions, lambdas or partial applications all work.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; create_function dbp::dbp <span class="st">&quot;p_fn&quot;</span> <span class="dv">2</span> plus <span class="kw">with</span> plus x y = x + y; <span class="kw">end</span>;

&gt; <span class="kw">let</span> sp4 = prep dbp <span class="st">&quot;cii:&quot;</span> 
&gt;           <span class="st">&quot;select p_fn(&#39;Hi &#39;,name), age, p_fn(age,10) from RM&quot;</span>;

&gt; exec sp4 ();
[[<span class="st">&quot;Hi Sam&quot;</span>,<span class="dv">20</span>,<span class="dv">30</span>],[<span class="st">&quot;Hi Fred&quot;</span>,<span class="dv">22</span>,<span class="dv">32</span>]]</code></pre></div>
<p>Here is an example of a variadic function:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; create_function dbp <span class="st">&quot;p_qm&quot;</span> (-<span class="dv">1</span>) quasimodo <span class="kw">with</span>
&gt;   quasimodo xs = <span class="st">&quot;quasimodo: &quot;</span>+join <span class="st">&quot;:&quot;</span> [str x | x=xs];
&gt; <span class="kw">end</span>;</code></pre></div>
<p>If the SQL function takes no arguments, the corresponding Pure function must, for technical reasons in Pure, take a single dummy argument. E.g.,</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; create_function dbp <span class="st">&quot;p_count&quot;</span> <span class="dv">0</span> counter <span class="kw">with</span>
&gt;   counter () = put r (get r+<span class="dv">1</span>);
&gt; <span class="kw">end</span> <span class="kw">when</span> r = ref <span class="dv">0</span> <span class="kw">end</span>;</code></pre></div>
<p>Here is how <code>count</code> and <code>quasimodo</code> might be used:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">let</span> sp5 = prep dbp <span class="st">&quot;ic:&quot;</span> <span class="st">&quot;select p_count(), p_qm(name,age) from RM&quot;</span>;

&gt; exec sp5 ();
[[<span class="dv">1</span>,<span class="st">&quot;quasimodo: </span><span class="ch">\&quot;</span><span class="st">Sam</span><span class="ch">\&quot;</span><span class="st">:20&quot;</span>],[<span class="dv">2</span>,<span class="st">&quot;quasimodo: </span><span class="ch">\&quot;</span><span class="st">Fred</span><span class="ch">\&quot;</span><span class="st">:22&quot;</span>]]

&gt; exec sp5 ();
[[<span class="dv">3</span>,<span class="st">&quot;quasimodo: </span><span class="ch">\&quot;</span><span class="st">Sam</span><span class="ch">\&quot;</span><span class="st">:20&quot;</span>],[<span class="dv">4</span>,<span class="st">&quot;quasimodo: </span><span class="ch">\&quot;</span><span class="st">Fred</span><span class="ch">\&quot;</span><span class="st">:22&quot;</span>]]</code></pre></div>
<p>Multiple SQL functions can be registered with the same name if they have differing numbers of arguments. Built-in SQL functions may be overloaded or replaced by new application-defined functions.</p>
<p>Generally, a custom function is permitted to call other Sql3 and native SQLite C interface functions. However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running.</p>
<h4 id="aggregate-sql-functions">Aggregate SQL Functions</h4>
<p>You can use <a href="#sql3::create_function"><code>create_function</code></a> to register an aggregate SQL function with SQLite by passing a triple consisting of two Pure functions and a start value, in lieu of a single Pure function.</p>
<dl>
<dt><a name="sql3::create_function"></a><code>sql3::create_function dbp::db_ptr name::string nargs::int (step,final,start)</code></dt>
<dd>registers a new SQL aggregate function of <code>nargs</code> arguments that can be called, as <code>name</code> in SQL statements prepared with respect to <code>dbp</code>, a db_ptr. <code>step</code> and <code>final</code> are curried Pure functions and <code>start</code> is the initial value for the aggregation. The <code>step</code> function is called repeatedly to accumulate values from the database, starting from the given <code>start</code> value, and finally the <code>final</code> function is applied to the accumulated result.
</dd>
</dl>
<!-- -->
<p>Note that for a single-argument step function, this works exactly as if the functions were invoked as “<code>final (foldl step start values)</code>”, where <code>values</code> is the list of aggregated values from the database.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; create_function dbp <span class="st">&quot;p_avg&quot;</span> <span class="dv">1</span> (step,final,(<span class="dv">0</span>,<span class="dv">0.0</span>)) <span class="kw">with</span>
&gt;   step (n,a) x = n+<span class="dv">1</span>, a+x;
&gt;   final (n,a) = a/n;
&gt; <span class="kw">end</span>;

&gt; <span class="kw">let</span> sp6 = prep dbp <span class="st">&quot;id:&quot;</span> <span class="st">&quot;select count(name), p_avg(age) from RM&quot;</span>;

&gt; exec sp6 ();
[[<span class="dv">2</span>,<span class="dv">21.0</span>]]</code></pre></div>
<h3 id="accessing-the-rest-of-sqlites-c-interface">Accessing the Rest of SQLite’s C Interface</h3>
<p>The db_ptrs returned by <a href="#sql3::open"><code>open</code></a> and stmt_ptrs returned by <a href="#sql3::prep"><code>prep</code></a> are sentry guarded versions of the actual pointers to the data base connection objects and prepared statement objects returned by their corresponding native C interface functions <code>sqlite3_open_v2</code> and <code>sqlite3_prepare_v2</code>. This makes it easy to call almost any external function in SQLite’s C interface directly, passing it the same db_ptr or stmt_ptr that is passed to Sql3’s functions, such as <a href="#sql3::prep"><code>prep</code></a> or <a href="#sql3::exec"><code>exec</code></a>.</p>
<p>For example, you can override SQLite’s default behavior with respect to a busy database as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">int</span> sqlite3_busy_timeout(sqlite3*, <span class="dt">int</span>);

&gt; sqlite3_busy_timeout dbp <span class="dv">10</span>;</code></pre></div>
<p>This sets a busy handler that will “sleep and retry” multiple times until at least 10 milliseconds of sleeping have accumulated. Calling this routine with an argument less than or equal to zero turns off all busy handlers.</p>
<p>Another example is to query the number of database rows that were changed, inserted or deleted by the most recently completed SQL statement executed on a given database connection:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">int</span> sqlite3_changes(sqlite3*);

&gt; exec sp1 (<span class="st">&quot;Harvey&quot;</span>,<span class="dv">30</span>);

&gt; sqlite3_changes dbp;
<span class="dv">1</span></code></pre></div>
<p>As a final example, in this case using a stmt_ptr, you can determine name assigned to a column in a result using <code>sqlite3_column_name</code>:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; <span class="kw">extern</span> <span class="dt">char</span> *sqlite3_column_name(sqlite3_stmt*, <span class="dt">int</span>);

&gt; exec sp2 <span class="dv">29</span>;
[[<span class="st">&quot;Harvey&quot;</span>,<span class="dv">30</span>]]

&gt; sqlite3_column_name sp2 <span class="dv">1</span>;
<span class="st">&quot;age&quot;</span></code></pre></div>
<p>In order to call a native C function you must first make it accessible using an extern statement.</p>
<p>Please note also that directly calling a function provided by the SQLite C interface can be dangerous, as is the case with any call from Pure code to an external C function. Sql3 users should be especially careful in this regard because using a db_ptr or a stmt_ptr in calls to certain native C interface functions, including in particular <code>sqlite3_close</code> and <code>sqlite3_finalize</code>, will corrupt data held by the db_ptr or stmt_ptr, leading to undefined behavior. The reason for this restriction is that Sql3 uses sentries to insure that the resources associated with a db_ptr or a stmt_ptr are automatically finalized by SQLite when they go out of scope. In addition, the sentries carry internal information used by Sql3 for other purposes.</p>
<h3 id="custom-binding-types-for-prepared-statements">Custom Binding Types for Prepared Statements</h3>
<p>You can add your own binding types for preparing and executing prepared statements by specifying a third argument to <a href="#sql3::open"><code>open</code></a>. The third argument must be a list of “hash rocket pairs” in which the left side is a character for the custom binding type and the right side is a list with three members. The second and third members of the list are functions that map objects from the new type to one of the Sql3 core types and back, respectively. The first member of the list is the character for the Sql3 core types referenced by the mapping functions.</p>
<p>The file sql3_user_bind_types.pure in the examples subdirectory shows how this might be done for a couple of user defined types. The example script deals with dates and certain Pure expressions as bigints and native Pure expressions, while the database stores these as utf-8 text. The following snippets show parts of the script that are relevant to this discussion:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure"><span class="kw">const</span> custom_binds = [
  <span class="st">&quot;t&quot;</span>=&gt;[<span class="st">&quot;c&quot;</span>,day_to_str,str_to_day],
  <span class="st">&quot;s&quot;</span>=&gt;[<span class="st">&quot;c&quot;</span>,str,eval]
];

d1 = str_to_day <span class="st">&quot;2010-03-22&quot;</span>;

db = open (<span class="st">&quot;abc.db&quot;</span>, SQLITE_OPEN, custom_binds); 
stm1 = prep db <span class="st">&quot;cts&quot;</span> <span class="st">&quot;insert into TC values(?,?,?)&quot;</span>;  
exec stm1 [<span class="st">&quot;Manny&quot;</span>, d1, s_expr];
stm3a = sql3::prep db <span class="st">&quot;t:&quot;</span> <span class="st">&quot;select t_date from TC&quot;</span>;
stm3b = sql3::prep db <span class="st">&quot;c:&quot;</span> <span class="st">&quot;select t_date from TC&quot;</span>;</code></pre></div>
<p>Executing stm3a and stm3b from the interpreter shows that TC’s date field is stored as a string, but returned to the Pure script as a bigint.</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">&gt; sql3::exec stm3a ());
[[14691L]]

&gt; sql3::exec stm3b ());
[[<span class="st">&quot;2010-03-22&quot;</span>]]</code></pre></div>
<p>The character designating the custom type must not be one of the letters used to designate Sql3 core binding types.</p>
<h2 id="threading-modes">Threading Modes</h2>
<p>SQLite supports three different threading modes:</p>
<ol style="list-style-type: decimal">
<li>Single-thread. In this mode, all mutexes are disabled and SQLite is unsafe to use in more than a single thread at once.</li>
<li>Multi-thread. In this mode, SQLite can be safely used by multiple threads provided that no single database connection is used simultaneously in two or more threads.</li>
<li>Serialized. In serialized mode, SQLite can be safely used by multiple threads with no restriction.</li>
</ol>
<p>SQLite can be compiled with or without support for multithreading and the default is to support it.</p>
<p>In many cases, single-thread mode might be appropriate if only because it is measurably faster. This might be the case, for example, if you are using SQLite as the on-disk file format for a desktop application.</p>
<p>If your version of SQLite was compiled with support for multithreading, you can switch to single-thread mode at runtime by calling sqlite3_config() with the verb SQLITE_CONFIG_SINGLETHREAD.</p>
<p>If you must use threads, it is anticipated that Sql3 probably will not impose an additional burden. Hopefully, you will be fine if you apply the same precautions to a db_ptr or stmt_ptr that you would apply to the underlying sqlite* and sqlite_stmt*s if you were not using Sql3. It is strongly advised however that you look at the underlying Sql3 code to verify that this will work. Since everything that is imposed between the raw pointers returned by the SQlite interface and the corresponding db_ptr and stmt_ptrs is written in Pure, it should be relatively easy to determine how Sql3 and your multithreading strategy will interact. See <a href="http://www.sqlite.org/faq.html#q6">Is SQLite threadsafe?</a> , <a href="http://www.sqlite.org/c3ref/open.html">Opening A New Database Connection</a> and <a href="http://www.sqlite.org/c3ref/threadsafe.html">Test To See If The Library Is Threadsafe</a>.</p>
</body>
</html>
