<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="modern.css" type="text/css" />
</head>
<body>
<p><a name="doc-pd-faust"></a></p>
<h1 id="pd-faust">pd-faust</h1>
<p>Version 0.14, March 06, 2017</p>
<p>Albert Graef &lt;<a href="mailto:aggraef@gmail.com">aggraef@gmail.com</a>&gt;</p>
<p>pd-faust is a dynamic environment for running Faust dsps in Pd. It is based on the author’s <a href="faust2pd.html">faust2pd</a> script, but offers many small improvements and some major additional features:</p>
<ul>
<li>Faust dsps are implemented using two Pd objects, <code>fsynth~</code> and <code>fdsp~</code>, which provide the necessary infrastructure to run Faust synthesizer and effect units in Pd, respectively. As of pd-faust 0.10, there’s also a <code>faust~</code> convenience object which unifies <code>fsynth~</code> and <code>fdsp~</code> and provides reasonable defaults for most creation arguments.</li>
<li>In contrast to faust2pd, the Pd GUI of Faust units is generated dynamically, inside Pd. While pd-faust supports the same global GUI layout options as faust2pd, it also provides various options to adjust the layout of individual control items.</li>
<li>pd-faust recognizes the <code>midi</code> and <code>osc</code> controller attributes in the Faust source and automatically provides corresponding MIDI and OSC controller mappings. OSC-based controller automation is also available.</li>
<li>Perhaps most importantly, Faust dsps can be reloaded at any time (even while the Pd patch is running), in which case the GUI and the controller mappings are regenerated automatically and on the fly as needed.</li>
</ul>
<h2 id="copying">Copying</h2>
<p>Copyright (c) 2011-2017 by Albert Graef</p>
<p>pd-faust is distributed under the GNU LGPL v3+. Please see the included COPYING and COPYING.LESSER files for details.</p>
<p>This package also includes the faust-stk instruments which are distributed under an MIT-style license, please check the examples/dsp/README-STK file and the dsp files for authorship information and licensing details pertaining to these. The original faust-stk sources can be found in the Faust distribution, cf. <a href="http://faust.grame.fr/" class="uri">http://faust.grame.fr/</a>.</p>
<h2 id="installation">Installation</h2>
<p>You’ll need <a href="http://faust.grame.fr/">Faust</a> and <a href="http://puredata.info/">Pd</a>, obviously. Faust versions &gt;= 0.9.46 and 2.0.a3 and Pd version &gt;= 0.43.1 have been tested and are known to work. Note that the examples still use the “old” a.k.a. “legacy” Faust library modules, so they should work out of the box with both “old” Faust versions (up to 0.9.85) and later ones featuring the “new” Faust library (anything after 0.9.85, including current git sources).</p>
<p>The pd-faust objects are written in the <a href="http://purelang.bitbucket.org/">Pure</a> programming language, so you’ll also need an installation of the Pure interpreter (0.51 or later), along with the following packages (minimum required versions are given in parentheses): <a href="pd-pure.html">pd-pure</a> (0.15), <a href="pure-faust.html">pure-faust</a> (0.8), <a href="pure-midi.html">pure-midi</a> (0.5) and <a href="pure-stldict.html">pure-stldict</a> (0.3).</p>
<p>Finally, gcc and GNU make (or compatible) are required to compile the helper dsps and the example instruments; please check the Makefile for details.</p>
<p>For a basic installation run <code>make</code>, then <code>sudo make install</code>. This will install the pd-faust objects in your lib/pd/extra/faust folder as a Pd object library which can be loaded with Pd’s <code>-lib</code> option. To complete the installation, you still have to make sure that the library is loaded automatically at startup. This is done most conveniently by adding <code>faust/pdfaust</code> to your preloaded library modules in Pd’s <code>Preferences/Startup</code> dialog.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> The <code>faust/pdfaust</code> module must come <em>after</em> the <code>pure</code> entry which loads pd-pure, otherwise you’ll get an error message. In any case the pd-pure loader will be required to run these objects, so it should be configured accordingly; please check the <a href="pd-pure.html">pd-pure</a> documentation for details.</p>
</blockquote>
<hr />
<p>The <code>make</code> command also compiles the Faust dsps included in the distribution, so that the provided examples will be ready to run afterwards well (see <a href="#examples">Examples</a> below).</p>
<p>The Makefile tries to guess the installation prefix under which Pd is installed. If it guesses wrong, you can tell it the right prefix with <code>make prefix=/some/path</code>. Or you can specify the exact path of the lib/pd directory with <code>make pdlibdir=/some/path</code>; by default the Makefile assumes <code>$(prefix)/lib/pd</code>.</p>
<p>It is also possible to specify an alternative flavour of Pd when building and installing the module, by adding a definition like <code>PD=pd-extended</code> to the <code>make</code> command line. This is known to work with <a href="http://puredata.info/downloads/pd-extended">pd-extended</a> and <a href="http://l2ork.music.vt.edu/main/?page_id=56">pd-l2ork</a>, two popular alternative Pd distributions available on the web, as well as <a href="https://git.purrdata.net/jwilkes/purr-data">purr-data</a> (the new cross-platform version of <a href="http://l2ork.music.vt.edu/main/?page_id=56">pd-l2ork</a>).</p>
<p>Some further build options are described in the Makefile. In particular, it is possible to compile the Faust dsps to LLVM bitcode which can be loaded directly by the Pure interpreter, but for that you’ll need a special Faust version (see the <a href="https://bitbucket.org/purelang/pure-lang/wiki/Faust2">Faust2</a> website for how to get this version up and running) and an LLVM-capable C/C++ compiler such as clang or gcc with the dragonegg plugin (please check the Makefile and the <a href="http://llvm.org/">LLVM</a> website for details).</p>
<p>If you have the required tools then you can build the bitcode modules by running <code>make bitcode</code> after <code>make</code>. If you run <code>make install</code> afterwards, the bitcode modules will be installed along with the “normal” Faust plugins. In addition, a second object library called <code>pdfaust2</code> will be built and installed, which can be used as a drop-in replacement for <code>pdfaust</code> and lets you run the bitcode modules. (Note that in the present implementation it is not possible to load both <code>pdfaust</code> and <code>pdfaust2</code> in Pd, you’ll have to pick one or the other.)</p>
<h2 id="usage">Usage</h2>
<p>Working with pd-faust basically involves adding a bunch of <code>faust~</code> (or the underlying <code>fsynth~</code> and <code>fdsp~</code>) objects to a Pd patch along with the corresponding GUI subpatches, and wiring up the Faust units in some variation of a synth-effects chain which typically takes input from Pd’s MIDI interface (<code>notein</code>, <code>ctlin</code>, etc.) and outputs the signals produced by the Faust units to Pd’s audio interface (<code>dac~</code>).</p>
<p>For convenience, pd-faust also includes the <code>midiseq</code> and <code>oscseq</code> objects and a corresponding <code>midiosc</code> abstraction which can be used to handle MIDI input and playback as well as OSC controller automation. This useful helper abstraction is described in more detail under <a href="#operating-the-patches">Operating the Patches</a> below.</p>
<p>pd-faust interprets MIDI, OSC and Faust dsp filenames relative to the hosting Pd patch by default. It will also search the <code>midi</code>, <code>osc</code> and <code>dsp</code> subfolders, if they exist, for the corresponding types of files. Failing that, it finally searches the directories on the Pd library path (including their <code>midi</code>, <code>osc</code> and <code>dsp</code> subfolders). To disable this search, just use absolute pathnames (or pathnames relative to the <code>.</code> or <code>..</code> directory) instead.</p>
<p>Like pd-pure, pd-faust remaps Pd’s <code>menu-open</code> command so that it lets you edit the Faust source of a <code>faust~</code>, <code>fdsp~</code> or <code>fsynth~</code> object by right-clicking on the object and choosing <code>Open</code> from the context menu.</p>
<h3 id="the-fdsp-and-fsynth-objects">The fdsp~ and fsynth~ Objects</h3>
<p>The <code>fdsp~</code> object is invoked as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fdsp~ dspname instname channel</code></pre></div>
<ul>
<li><code>dspname</code> denotes the name of the Faust dsp (usually this is just the name of the .dsp file with the extension stripped off). Please note that the Faust dsp must be provided in a form which can be loaded in <em>Pure</em> (not Pd!), so the <code>pure.cpp</code> architecture (included in the Faust distribution) must be used to compile the dsp to a shared library. (If you’re already running <a href="https://bitbucket.org/purelang/pure-lang/wiki/Faust2">Faust2</a>, you can also compile to an LLVM bitcode file instead; Pure has built-in support for loading these.) There’s a GNU Makefile in the examples/dsp subdirectory which shows how to do this. This Makefile is self-contained, so you can just drop it into any directory with Faust dsp sources and run <code>make</code> there to compile the modules to a format which is ready to be loaded with pd-faust.</li>
<li><code>instname</code> denotes the name of the instance of the Faust unit. Multiple instances of the same Faust dsp can be used in a Pd patch, which must all have different instance names. In addition, the instance name is also used to identify the GUI subpatch of the unit (see below) and to generate unique OSC addresses for the unit’s control elements.</li>
<li><code>channel</code> is the number of the MIDI channel the unit responds to. This can be 1..16, or 0 to specify “omni” operation (listen to MIDI messages on all channels).</li>
</ul>
<hr />
<blockquote>
<p><strong>Note:</strong> Since the <code>fdsp~</code> and <code>fsynth~</code> objects are written in Pure, their creation arguments should be specified in Pure syntax. In particular, both <code>dspname</code> or <code>instname</code> may either be Pure identifiers or double-quoted strings (the former will automatically be translated to the latter). Similarly, the <code>channel</code> argument (as well as the <code>numvoices</code> argument of the <code>fsynth~</code> object, see below) must be an integer constant in Pure syntax, which is pretty much like Pd syntax but also allows the integer to be specified in hexadecimal, octal or binary.</p>
</blockquote>
<hr />
<p>The <code>fdsp~</code> object requires a Faust dsp which can work as an effect unit, processing audio input and producing audio output. The unit can have as many audio input and output channels as you like (including zero).</p>
<p>The <code>fsynth~</code> object works in a similar fashion, but has an additional creation argument specifying the desired number of voices:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fsynth~ dspname instname channel numvoices</code></pre></div>
<p>The <code>fsynth~</code> object requires a Faust dsp which can work as a monophonic synthesizer. This typically means that the unit has zero audio inputs and a nonzero number of audio outputs, although it is possible to have synths processing any number of audio input channels as well. (You can even have synths producing zero audio outputs, but this is generally not very useful.) In addition, pd-faust assumes that the Faust unit provides three so-called “voice controls” which indicate which note to play:</p>
<ul>
<li><code>freq</code> is the fundamental frequency of the note in Hz.</li>
<li><code>gain</code> is the velocity of the note, as a normalized value between 0 and 1. This usually controls the volume of the output signal.</li>
<li><code>gate</code> indicates whether a note is currently playing. This value is either 0 (no note to play) or 1 (play a note), and usually triggers the envelop function (ADSR or similar).</li>
</ul>
<p>pd-faust doesn’t care at which path inside the Faust dsp these controls are located, but they must all be there, and the basenames of the controls must be unique throughout the entire dsp. Otherwise the synth will not work as expected.</p>
<p>Like <a href="faust2pd.html">faust2pd</a>, pd-faust implements the necessary logic to drive the given number of voices of an <code>fsynth~</code> object. That is, it will actually create a separate instance of the Faust dsp for each voice and handle polyphony by allocating voices from this pool in a round-robin fashion, performing the usual voice stealing if the number of simultaneous notes to play exceeds the number of voices. Also note that an <code>fsynth~</code> operated in omni mode (<code>channel = 0</code>) automatically filters out messages on channel 10 which is reserved for percussion in the General MIDI standard.</p>
<p>The <code>fdsp~</code> and <code>fsynth~</code> objects respond to the following messages:</p>
<ul>
<li><code>bang</code> outputs the current control settings on the control outlet in OSC format.</li>
<li><code>write</code> outputs the current control settings to external MIDI and/or OSC devices. This message can also be invoked with a numeric argument to toggle the “write mode” of the unit; please see <a href="#external-midi-and-osc-controllers">External MIDI and OSC Controllers</a> below for details.</li>
<li><code>reload</code> reloads the Faust unit. This also reloads the shared library or bitcode file if the unit was recompiled since the object was last loaded. (Instead of feeding a <code>reload</code> message to the control inlet of a Faust unit, you can also just send a <code>bang</code> to the <code>reload</code> receiver.)</li>
<li><code>addr value</code> changes the control indicated by the OSC address <code>addr</code>. This is also used internally for communication with the Pd GUI and for controller automation.</li>
</ul>
<p>The <code>fdsp~</code> and <code>fsynth~</code> objects also respond to MIDI controller messages of the form <code>ctl val num chan</code>, and the <code>fsynth~</code> object understands note-related messages of the form <code>note num vel chan</code> (note on/off) and <code>bend val chan</code> (pitch bend). In either case, pd-faust provides the necessary logic to map controller and note-related messages to the corresponding control changes in the Faust unit.</p>
<p>In addition, pd-faust 0.13 and later offer support for the MIDI Tuning Standard (MTS), so that instruments can be retuned using the corresponding sysex messages for octave-based tunings. To these ends, the <code>fsynth~</code> object accepts messages of the form <code>sysex b1 b2 ...</code> where <code>b1</code>, <code>b2</code>, … are the individual data bytes of the message. A description of the MIDI Tuning Standard is beyond the scope of this manual. However, there are some tools which let you construct such messages from various input formats, such as the author’s <a href="https://bitbucket.org/agraef/sclsyx">sclsyx</a> program. You can then either include the tuning messages in a MIDI file or transmit them directly to Pd’s MIDI input. There’s also a version of sclsyx.pure included in the author’s <a href="https://bitbucket.org/agraef/pd-smmf">pd-smmf</a> package, which can be run as a Pd external to output tunings in the format understood by the <code>fsynth~</code> object.</p>
<h3 id="the-faust-object">The faust~ Object</h3>
<p>Starting with version 0.10, pd-faust includes the <code>faust~</code> external as a convenience which provides the functionality of both <code>fdsp~</code> and <code>fsynth~</code> in a single object. This object also supplies reasonable defaults for most arguments. While the underlying <code>fdsp~</code> and <code>fsynth~</code> objects are still available for backward compatibility, the <code>faust~</code> object is often much easier to use and should be considered the preferred way to create Faust objects in a Pd patch now.</p>
<p>The <code>faust~</code> object is invoked as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">fsynth~ dspname [instname] [channel] [numvoices]</code></pre></div>
<p>As indicated, all creation arguments except the first, <code>dspname</code> argument are optional. The meaning of these arguments is the same as with the <code>fdsp~</code> and <code>fsynth~</code> objects. A <code>numvoices</code> value of zero can be used to indicate an effect unit. If the <code>numvoices</code> argument is omitted, the <code>faust~</code> object checks the meta data of the Faust module to see whether the loaded Faust module is an effect or a synth and creates an instance of the corresponding underlying object (<code>fdsp~</code> or <code>fsynth~</code>).</p>
<p>Note that if only a single number follows the <code>dspname</code> or <code>instname</code> argument then it is always interpreted as a channel number; thus, if you want to denote the <code>numvoices</code> argument then you’ll have to specify <em>both</em> <code>channel</code> and <code>numvoices</code>, in that order.</p>
<p>By default, the instance name is assumed to be the same as the dsp name, the default MIDI channel is 0 (omni), and the number of voices of an instrument is determined using the value of the <code>nvoices</code> meta key declared in the dsp source. Thus, to turn a Faust dsp into a synth with 8 voices you can use a declaration like the following anywhere in the Faust program:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">declare nvoices <span class="st">&quot;8&quot;</span>;</code></pre></div>
<p>The format of this declaration is the same as for the <a href="https://bitbucket.org/agraef/faust-lv2">faust-lv2</a> and <a href="https://bitbucket.org/agraef/faust-vst">faust-vst</a> plugin architectures.</p>
<p>If the <code>nvoices</code> declaration isn’t present, the dsp is considered to be an effect unit by default. All default choices can be overridden by explicitly specifying the corresponding creation argument. In particular, you can specify the number of synth voices (overriding the <code>nvoices</code> key in the dsp source), or use a <code>numvoices</code> value of zero to force a synth to be loaded as an ordinary effect unit. Also, if there are multiple instances of the same dsp in a patch then you can explicitly specify different instance names using the <code>instname</code> argument, and the default <code>channel</code> value of zero (denoting omni input) can be overridden as needed if the unit should only listen on a specific MIDI channel.</p>
<h3 id="gui-subpatches">GUI Subpatches</h3>
<p>For each <code>faust~</code>, <code>fdsp~</code> and <code>fsynth~</code> object, the Pd patch may contain an (initially empty) “one-off” graph-on-parent subpatch with the same name as the instance name of the Faust unit:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">pd instname</code></pre></div>
<p>You shouldn’t insert anything into this subpatch, its contents (a bunch of Pd GUI elements corresponding to the control elements of the Faust unit) will be generated automatically by pd-faust when the corresponding <code>faust~</code>, <code>fdsp~</code> or <code>fsynth~</code> object is created, and whenever the unit gets reloaded at runtime.</p>
<p>As with faust2pd, the default appearance of the GUI can be adjusted in various ways; see <a href="#tweaking-the-gui-layout">Tweaking the GUI Layout</a> below for details.</p>
<p>The relative order in which you insert a <code>faust~</code>, <code>fdsp~</code> or <code>fsynth~</code> object and its GUI subpatch into the main patch matters. Normally, the GUI subpatch should be inserted <em>first</em>, so that it will be updated automatically when its associated Faust unit is first created, and also when the main patch is saved and then reloaded later.</p>
<p>However, in some situations it may be preferable to insert the GUI subpatch <em>after</em> its associated Faust unit. If you do this, the GUI will <em>not</em> be updated automatically when the main patch is loaded, so you’ll have to reload the dsp manually (sending it a <code>reload</code> message) to force an update of the GUI subpatch. This is useful, in particular, if you’d like to edit the GUI patch manually after it has been generated.</p>
<p>In some cases it may even be desirable to completely “lock down” the GUI subpatch. This can be done by simply <em>renaming</em> the GUI subpatch after it has been generated. When Pd saves the main patch, it saves the current status of the GUI subpatches along with it, so that the renamed subpatch will remain static and will <em>never</em> be updated, even if its associated Faust unit gets reloaded. This generally makes sense only if the control interface of the Faust unit isn’t changed after locking down its GUI patch. To “unlock” a GUI subpatch, you just rename it back to its original name. (In this case you might also want to reinsert the corresponding Faust unit afterwards, if you want to have the GUI generated automatically without an explicit <code>reload</code> again.)</p>
<h3 id="examples">Examples</h3>
<p>The examples folder contains a few example patches which illustrate how this all works. Having installed pd-faust as described above, you can run these from the examples directory, e.g.: <code>pd test.pd</code>. (You can also run the examples without actually installing pd-faust if you invoke Pd from the main pd-faust source directory, e.g., as follows: <code>pd -lib lib/pdfaust examples/test.pd</code>.)</p>
<p>Here are some of the examples that are currently available:</p>
<ul>
<li>test.pd: Simple patch running a single Faust instrument.</li>
<li>synth.pd: Slightly more elaborate patch featuring a synth-effects chain.</li>
<li>bouree.pd: Full-featured example running various instruments.</li>
</ul>
<p>For your convenience, related MIDI and OSC files as well as the Faust sources of the instruments and effects are contained in corresponding subdirectories (midi, osc, dsp) of the examples directory. A slightly modified version of the faust-stk instruments from the Faust distribution is also included, please check the examples/dsp/README-STK file for more information about these.</p>
<p>The MIDI files are all in standard MIDI file format. (Some of these come from the faust-stk distribution, others can be found on the web.) The OSC files used by pd-faust for controller automation are plain ASCII files suitable for hand-editing if you know what you are doing; the format should be fairly self-explanatory.</p>
<h3 id="operating-the-patches">Operating the Patches</h3>
<p>The generated Pd GUI elements for the Faust dsps are pretty much the same as with <a href="faust2pd.html">faust2pd</a> (which see). The only obvious change is the addition of a “record” button (gray toggle in the upper right corner) which enables recording of OSC automation data.</p>
<p>In each example distributed with pd-faust you can also find an instance of the <code>midiosc</code> abstraction which serves as a little sequencer applet that enables you to control MIDI playback and OSC recording. The usage of this abstraction should be fairly obvious, but you can also find a brief description below.</p>
<hr />
<blockquote>
<p><strong>Note:</strong> If you use the <code>midiosc</code> abstraction in your own patches, you should copy it to the directory containing your patch and other required files, so that MIDI and OSC files are properly located. Alternatively, you can also set up Pd’s search path as described at the beginning of the <a href="#usage">Usage</a> section.</p>
</blockquote>
<hr />
<p>The first creation argument of <code>midiosc</code> is the name of the MIDI file, either as a Pure identifier (in this case the .mid filename extension is supplied automatically) or as a double-quoted string. Similarly, the second argument specifies the name of the OSC file. Both arguments are optional; if the second argument is omitted, it defaults to the name of the MIDI file with new extension .osc. You can also omit both arguments if neither MIDI file playback nor saving recorded OSC data is required. Or you can leave the first parameter empty (specify <code>&quot;&quot;</code> or <code>0</code> instead) to only set an OSC filename, if you don’t need MIDI playback. The latter is useful, in particular, if you use <code>midiosc</code> with an external MIDI sequencer (see below).</p>
<p>The abstraction has a single control outlet through which it feeds the generated MIDI and other messages to the connected <code>fsynth~</code> and <code>fdsp~</code> objects. Live MIDI input is also accepted and forwarded to the control outlet, after being translated to the format understood by <code>fsynth~</code> and <code>fdsp~</code> objects. In addition, <code>midiosc</code> can also be controlled through an external MIDI sequencer connected to Pd’s MIDI input. To these ends, <a href="http://en.wikipedia.org/wiki/MIDI_Machine_Control">MIDI Machine Control</a> (MMC) can be used to start and stop OSC playback and recording with the transport controls of the external sequencer program. To make this work, the external sequencer must be configured as an MMC master.</p>
<p>At the bottom of the abstraction there is a little progress bar along with a time display which indicates the current song position. If playback is stopped, you can also use these to change the current position for playback, recording and a number of other operations as described below. Note that if you drive <code>midiosc</code> from an external MIDI sequencer instead, then it is a good idea to load the same MIDI file in <code>midiosc</code> anyway, so that it knows about the length of the MIDI sequence. This will make the progress bar display the proper position in the file.</p>
<p>Here is a brief rundown of the available controls:</p>
<ul>
<li>The <code>start</code>, <code>stop</code> and <code>cont</code> controls in the <em>first</em> row of control elements start, stop and continue MIDI and OSC playback, respectively. The <code>midi</code> toggle in this row causes played MIDI events to be printed in the Pd main window.</li>
<li>The gray “record” toggle in the upper right corner of the abstraction enables recording of OSC controller automation data. Note that this toggle merely <em>arms</em> the OSC recorder; you still have to actually start the recording with the <code>start</code> button. However, you can also first start playback with <code>start</code> and then switch recording on and off as needed at any point in the sequence (this is also known as “punch in/out” recording). In either case, pushing the <code>stop</code> button stores the recorded sequence for later playback. Also note that before you can start recording any OSC data, you first have to arm the Faust units that you want to record. This is done with the “record” toggle in the Pd GUI of each unit.</li>
<li>The “bang” button next to the “record” toggle lets you record a static snapshot of the current parameter settings of all armed units. This is also done automatically when starting a fresh recording. The “bang” button lets you change the starting defaults of parameters of an existing recording. It is also useful if you just want to record a static snapshot of the current parameter settings without recording any live parameter changes. Moreover, you can also set the parameters at any given point in the piece if you first position the progress bar or the time display accordingly; in this case you may first want to recall the parameter settings at the given point with the <code>send</code> button described below. In either case, recording must be enabled and playback must be <em>off</em>. Then just arm the Faust units that you wish to record, set the playback position as needed, change the controls to what you want their values to be (maybe after recalling the current settings), and finally push the “bang” button.</li>
<li>There are some additional controls related to OSC recording in the <em>second</em> row: <code>save</code> saves the currently recorded data in an OSC file for later use; <code>abort</code> is like <code>stop</code> in that it stops recording and playback, but also throws away the data recorded in this take (rather than keeping it for later playback); and <code>clear</code> purges the entire recorded OSC sequence so that you can start a new one.</li>
<li>Once some automation data has been recorded, it will be played back along with the MIDI file. You can then just listen to it, or go on to record more automation data as needed. Use the <code>osc</code> toggle in the second row to print the OSC messages as they are played back. If you save the automation data with the <code>save</code> button, it will be reloaded from its OSC file next time the patch is opened.</li>
<li>The controls in the <em>third</em> row provide some additional ways to configure the playback process. The <code>loop</code> button can be used to enable looping, which repeats the playback of the MIDI (and OSC) sequence ad infinitum. The <code>thru</code> button, when switched on, routes the MIDI data during playback through Pd’s MIDI output so that it can be used to drive an external MIDI device in addition to the Faust instruments. The <code>write</code> button does the same with MIDI and OSC controller data generated either through automation data or by manually operating the control elements in the Pd GUI, see <a href="#external-midi-and-osc-controllers">External MIDI and OSC Controllers</a> below for details.</li>
<li>There’s one additional button in the third row, the <code>send</code> button which recalls the recorded OSC parameter settings at a given point in the sequence. Playback must be off for this to work. After setting the playback position as desired, just push the <code>send</code> button. This sets the controls to the current parameter values at the given point, for <em>all</em> parameters which have been recorded up to (and including) this point.</li>
</ul>
<p>Please note that <code>midiosc</code> is merely a prototypical implementation which should cover most common uses. It can also be used as a starting point for your own abstractions if you need more elaborate input/output interfacing than what <code>midiosc</code> provides. On the other hand, for simple uses your patches may just feed control messages directly into <code>faust~</code>, <code>fdsp~</code> and <code>fsynth~</code> objects instead. If you just need plain MIDI input, another possibility is to use the <code>midi-input</code> abstraction contained in the author’s <a href="https://bitbucket.org/agraef/pd-lv2plugin">pd-lv2plugin</a> package which encodes incoming MIDI messages in a format compatible with the <code>faust~</code>, <code>fdsp~</code> and <code>fsynth~</code> objects.</p>
<h3 id="external-midi-and-osc-controllers">External MIDI and OSC Controllers</h3>
<p>The <code>fsynth~</code> object has built-in (and hard-wired) support for MIDI notes, pitch bend and MIDI controller 123 (all notes off). Other controller data received from external MIDI and OSC devices is interpreted according to the controller mappings defined in the Faust source (this is explained below), by updating the corresponding GUI elements and the control variables of the Faust dsp. For obvious reasons, this only works with <em>active</em> Faust controls.</p>
<p>A <code>faust~</code>, <code>fdsp~</code> or <code>fsynth~</code> object can also be put in <em>write mode</em> by feeding a message of the form <code>write 1</code> into its control inlet (the <code>write 0</code> message disables write mode again). For convenience, the <code>write</code> toggle in the <code>midiosc</code> abstraction allows you to do this simultaneously for all Faust units connected to <code>midiosc</code>’s control outlet.</p>
<p>When an object is in write mode, it also <em>outputs</em> MIDI and OSC controller data in response to both automation data and the manual operation of the Pd GUI elements, again according to the controller mappings defined in the Faust source, so that it can drive an external device such as a MIDI fader box or a multitouch OSC controller. Note that this works with both <em>active</em> and <em>passive</em> Faust controls.</p>
<p>To configure MIDI controller assignments, the labels of the Faust control elements have to be marked up with the special <code>midi</code> attribute in the Faust source. For instance, a pan control (MIDI controller 10) may be implemented in the Faust source as follows:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">pan = hslider(<span class="st">&quot;pan [midi:ctrl 10]&quot;</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0.01</span>);</code></pre></div>
<p>pd-faust will then provide the necessary logic to handle MIDI input from controller 10 by changing the pan control in the Faust unit accordingly, mapping the controller values 0..127 to the range and step size given in the Faust source. Moreover, in write mode corresponding MIDI controller data will be generated and sent to Pd’s MIDI output, on the MIDI channel specified in the creation arguments of the Faust unit (0 meaning “omni”, i.e., output on all MIDI channels).</p>
<p>The same functionality is also available for external OSC devices, employing explicit OSC controller assignments in the Faust source by means of the <code>osc</code> attribute. E.g., the following enables input and output of OSC messages for the OSC <code>/pan</code> address:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">pan = hslider(<span class="st">&quot;pan [osc:/pan]&quot;</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0.01</span>);</code></pre></div>
<hr />
<blockquote>
<p><strong>Note:</strong> In contrast to some other architectures included in the Faust distribution, at present pd-faust only allows literal OSC addresses (no glob-style patterns), and there is no way to specify an OSC value range (so the value ranges of the controls of an external OSC device must match the ranges of the corresponding controls in the Faust program).</p>
</blockquote>
<hr />
<p>To actually connect with external OSC devices, you will also need some OSC input and output facilities. Neither vanilla Pd nor pd-faust includes any of these, so you will have to rely on 3rd party externals for that. We recommend Martin Peach’s <a href="http://puredata.info/Members/martinrp/OSCobjects">OSC externals</a> which are included in Hans-Christoph Steiner’s <a href="http://puredata.info/downloads/pd-extended">Pd-extended</a> distribution. pd-faust includes a version of the <code>midiosc</code> abstraction named <code>midiosc-mrpeach</code> which can be used as a drop-in replacement for <code>midiosc</code> and implements OSC input and output using Martin Peach’s objects. You most likely have to edit this abstraction to make it work for your local network setup; at least you’ll probably have to change the network addresses in the abstraction so that it works with the OSC device or application that you use.</p>
<p>Another useful abstraction is the <code>oscbrowser</code> object available in the author’s separate <a href="https://bitbucket.org/agraef/pd-mdnsbrowser">pd-mdnsbrowser</a> package. It lets you discover and publish Zeroconf (Avahi/Bonjour) services in the local network, so that your Pd patches can establish OSC connections in an automatic fashion.</p>
<h3 id="tweaking-the-gui-layout">Tweaking the GUI Layout</h3>
<p>As already mentioned, pd-faust provides the same global GUI layout options as <a href="faust2pd.html">faust2pd</a>. Please check the faust2pd documentation for details. There are a few minor changes in the meaning of some of the options, though, which we consider notable improvements after some experience working with faust2pd. Here is a brief rundown of the available options, as they are implemented in pd-faust:</p>
<ul>
<li><code>width=wd</code>, <code>height=ht</code>: Specify the maximum horizontal and/or vertical dimensions of the layout area. If one or both of these values are nonzero, pd-faust will try to make the GUI fit within this area.</li>
<li><code>font-size=sz</code>: Specify the font size (default is 10).</li>
<li><code>fake-buttons</code>: Render <code>button</code> controls as Pd toggles rather than bangs.</li>
<li><code>radio-sliders=max</code>: Render sliders with up to <code>max</code> different values as Pd radio controls rather than Pd sliders. Note that in pd-faust this option not only applies to sliders, but also to numeric entries, i.e., <code>nentry</code> in the Faust source. However, as with faust2pd’s <code>radio-sliders</code> option, the option is only applicable if the control is zero-based and has a stepsize of 1.</li>
<li><code>slider-nums</code>: Add a number box to each slider control. Note that in pd-faust this is actually the default, which can be disabled with the <code>no-slider-nums</code> option.</li>
<li><code>exclude=pat,...</code>: Exclude the controls whose labels match the given glob patterns from the Pd GUI.</li>
</ul>
<p>In pd-faust there is no way to specify the above options on the command line, so you’ll have to put them as <code>pd</code> attributes on the <em>main</em> group of your Faust program, as described in the faust2pd documentation. For instance:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">process = vgroup(<span class="st">&quot;[pd:no-slider-nums][pd:font-size=12]&quot;</span>, ...);</code></pre></div>
<p>In addition, the following options can be used to change the appearance of individual control items. If present, these options override the corresponding defaults. Each option can also be prefixed with “<code>no-</code>” to negate the option value. (Thus, e.g., <code>no-hidden</code> makes items visible which would otherwise, by means of the global <code>exclude</code> option, be removed from the GUI.)</p>
<ul>
<li><code>hidden</code>: Hides the corresponding control in the Pd GUI. This is the only option which can also be used for group controls, in which case <em>all</em> controls in the group will become invisible in the Pd GUI.</li>
<li><code>fake-button</code>, <code>radio-slider</code>, <code>slider-num</code>: These have the same meaning as the corresponding global options, but apply to individual control items.</li>
</ul>
<p>Again, these options are specified with the <code>pd</code> attribute in the label of the corresponding Faust control. For instance, the following Faust code hides the controls in the <code>aux</code> group, removes the number entry from the <code>pan</code> control, and renders the <code>preset</code> item as a Pd radio control:</p>
<div class="sourceCode"><pre class="sourceCode pure"><code class="sourceCode pure">aux = vgroup(<span class="st">&quot;aux [pd:hidden]&quot;</span>, aux_part);
pan = hslider(<span class="st">&quot;pan [pd:no-slider-num]&quot;</span>, <span class="dv">0</span>, -<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0.01</span>);
preset = nentry(<span class="st">&quot;preset [pd:radio-slider]&quot;</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">1</span>);</code></pre></div>
<h3 id="remote-control">Remote Control</h3>
<p>Also included in the sources is a helper abstraction faust-remote.pd and an accompanying elisp program faust-remote.el. These work pretty much like pure-remote.pd and pure-remote.el in the <a href="pd-pure.html">pd-pure</a> distribution, but are tailored for the remote control of Faust dsps in a Pd patch. In particular, they enable you to quickly reload the Faust dsps in Pd using a simple keyboard command (<code>C-C C-X</code> by default) from Emacs. The faust-remote.el program was designed to be used with Juan Romero’s Emacs <a href="https://github.com/rukano/emacs-faust-mode">Faust mode</a>; please see etc/faust-remote.el in the pd-faust source for usage instructions.</p>
<h2 id="caveats-and-bugs">Caveats and Bugs</h2>
<p>Some parts of this software might still be experimental, under construction and/or bug-ridden. Bug reports, patches and suggestions are welcome. Please send these directly to the author, or post them either to the Faust or the Pure mailing list.</p>
<p>In particular, please note the following known limitations in the current implementation:</p>
<ul>
<li>Passive Faust controls are only supported in <code>fdsp~</code> objects.</li>
<li>The names of the voice controls in the <code>fsynth~</code> object (<code>freq</code>, <code>gain</code>, <code>gate</code>) are currently hard-coded, as are the names of the <code>midi</code>, <code>osc</code> and <code>dsp</code> subfolders used to locate various kinds of files.</li>
<li>Polyphonic aftertouch and channel pressure messages are not supported in the MIDI interface right now, so you’ll have to use ordinary MIDI controllers for these parameters instead. Coarse/fine pairs of MIDI controllers aren’t directly supported either, so you’ll have to implement these yourself as two separate Faust controls.</li>
<li>There’s no translation of OSC values. pd-faust thus always assumes that the controls of an external OSC device have the ranges specified in the Faust program. If this isn’t the case then you’ll have to adjust either the OSC controller setup or the control ranges in the Faust program, or use an external tool like <a href="http://www.osculator.net/">OSCulator</a> to translate the messages.</li>
</ul>
<p>Also, please check the TODO file included in the distribution for other issues which we are already aware of and which will hopefully be addressed in future pd-faust versions.</p>
</body>
</html>
